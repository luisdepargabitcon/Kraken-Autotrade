TELEGRAM: MENSAJES â€œCOMO CAPTURASâ€ CON NEGRITAS + EMOJIS (USAR parse_mode HTML)

PROBLEMA
Los mensajes salen sin negrita porque se envÃ­an como texto plano. Quiero el estilo de las capturas:
- TÃ­tulos y secciones en NEGRITA
- Emojis/bullets como antes (âœ… ğŸ“Œ ğŸ“Š ğŸ§  ğŸ’— ğŸŸ¢ ğŸ”´ ğŸŸ  etc.)
- Mismo â€œdiseÃ±oâ€ visual, NO el formato minimalista

SOLUCIÃ“N
1) Enviar TODOS los mensajes con parse_mode="HTML".
2) Usar <b>...</b> para tÃ­tulos y encabezados de secciÃ³n.
3) Escapar HTML en valores dinÃ¡micos (pair, reason, ids) para evitar que rompa el markup.

CAMBIO 1 â€” Helper de escape HTML (OBLIGATORIO)
En server/services/telegram.ts (o archivo util):
function escapeHtml(s: unknown): string {
  const str = String(s ?? "");
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

CAMBIO 2 â€” Wrapper de envÃ­o que SIEMPRE use HTML
Centralizar el envÃ­o (para no olvidarlo en cada sitio):
async function sendTelegram(chatId: string, text: string, extra?: any) {
  return bot.telegram.sendMessage(chatId, text, {
    parse_mode: "HTML",
    disable_web_page_preview: true,
    ...extra,
  });
}

Asegurar que sendAlertToMultipleChats() usa sendTelegram() internamente.

CAMBIO 3 â€” Plantillas â€œcomo capturasâ€ (HTML)
Crear funciones builder (en telegram.ts o telegramTemplates.ts):

A) BOT INICIADO (como tu canal KRAKEN)
function buildBotStartedMessageHTML(ctx: { env; strategy; risk; pairs; balanceUsd; mode; }): string {
  return [
    `<b>${escapeHtml(ctx.env)} ğŸŸ¢ KrakenBot Iniciado</b>`,
    ``,
    `El bot de trading autÃ³nomo estÃ¡ activo.`,
    `<b>Estrategia:</b> ${escapeHtml(ctx.strategy)}`,
    `<b>Nivel de riesgo:</b> ${escapeHtml(ctx.risk)}`,
    `<b>Pares activos:</b> ${escapeHtml(ctx.pairs.join(", "))}`,
    `<b>Balance USD:</b> $${escapeHtml(ctx.balanceUsd)}`,
    `âš ï¸ <b>Modo:</b> ${escapeHtml(ctx.mode)}`
  ].join("\n");
}

B) HEARTBEAT / VERIFICACIÃ“N OPERATIVIDAD (como tus capturas â€œSISTEMA OPERATIVOâ€)
function buildHeartbeatMessageHTML(ctx: { title; channelName; ts; cpu; mem; disk; uptime; conns; tasks; }): string {
  return [
    `<b>ğŸŸ¥ SISTEMA OPERATIVO</b>`,
    `<b>âœ… VERIFICACIÃ“N DE OPERATIVIDAD ${escapeHtml(ctx.title)} - CANAL ${escapeHtml(ctx.channelName)} ğŸ“Œ</b>`,
    ``,
    `Este mensaje confirma que el bot de trading estÃ¡ activo y`,
    `monitorizando el mercado.`,
    ``,
    `<b>ğŸ“Š Estado del sistema:</b>`,
    `CPU: ${escapeHtml(ctx.cpu)} | Memoria: ${escapeHtml(ctx.mem)} | Disco: ${escapeHtml(ctx.disk)}`,
    `Tiempo activo: ${escapeHtml(ctx.uptime)}`,
    ``,
    `<b>âœ… Conexiones:</b>`,
    `${ctx.conns.kraken ? "âœ…" : "âŒ"} Kraken`,
    `${ctx.conns.telegram ? "âœ…" : "âŒ"} Telegram`,
    `${ctx.conns.db ? "âœ…" : "âŒ"} DB`,
    ``,
    `<b>ğŸ“Œ Canal:</b> ${escapeHtml(ctx.channelName)}`,
    `<b>ğŸ•’ Hora:</b> ${escapeHtml(ctx.ts)}`,
    ``,
    `âœ… Sistema operativo 24x7 - VerificaciÃ³n automÃ¡tica de funcionamiento`
  ].join("\n");
}

C) SEÃ‘AL (como tus capturas â€œğŸŸ¢ SEÃ‘AL: COMPRAR SOLâ€)
function buildSignalMessageHTML(ctx: { side; symbol; price; investPct; rsi; macd; adx; regime; ts; }): string {
  const sideEmoji = ctx.side === "BUY" ? "ğŸŸ¢" : "ğŸ”´";
  const sideText  = ctx.side === "BUY" ? "COMPRAR" : "VENDER";
  return [
    `<b>${sideEmoji} SEÃ‘AL: ${sideText} ${escapeHtml(ctx.symbol)} ${sideEmoji}</b>`,
    ``,
    `ğŸ“Œ Precio: ${escapeHtml(ctx.price)}`,
    `ğŸ’° InversiÃ³n recomendada: ${escapeHtml(ctx.investPct)}%`,
    ``,
    `<b>ğŸ“Š Indicadores tÃ©cnicos:</b>`,
    `â€¢ RSI: ${escapeHtml(ctx.rsi)}`,
    `â€¢ MACD: ${escapeHtml(ctx.macd)}`,
    `â€¢ ADX: ${escapeHtml(ctx.adx)}`,
    ``,
    `ğŸ§­ RÃ©gimen de mercado: ${escapeHtml(ctx.regime)}`,
    `ğŸ•’ ${escapeHtml(ctx.ts)}`
  ].join("\n");
}

D) OPERACIÃ“N EJECUTADA (BUY) â€” estilo â€œOperaciÃ³n AutomÃ¡tica Ejecutadaâ€ pero con negritas
function buildTradeBuyExecutedHTML(ctx: { env; pair; amount; price; total; orderId; strategyLabel; confPct; reason; signalsSummary; mode; }): string {
  return [
    `<b>${escapeHtml(ctx.env)} ğŸŸ¢ OperaciÃ³n AutomÃ¡tica Ejecutada</b>`,
    ``,
    `<b>ğŸ“Œ Tipo:</b> BUY`,
    `<b>ğŸ“Œ Par:</b> ${escapeHtml(ctx.pair)}`,
    `<b>ğŸ“Œ Cantidad:</b> ${escapeHtml(ctx.amount)}`,
    `<b>ğŸ“Œ Precio:</b> $${escapeHtml(ctx.price)}`,
    `<b>ğŸ“Œ Total:</b> $${escapeHtml(ctx.total)}`,
    `<b>ğŸ”— ID:</b> <code>${escapeHtml(ctx.orderId)}</code>`,
    ``,
    `<b>ğŸ§  Estrategia:</b> ${escapeHtml(ctx.strategyLabel)} | <b>Confianza:</b> ${escapeHtml(ctx.confPct)}%`,
    `<b>ğŸ“ RazÃ³n:</b> ${escapeHtml(ctx.reason)}`,
    ctx.signalsSummary ? `<b>ğŸ“Š SeÃ±ales:</b> ${escapeHtml(ctx.signalsSummary)}` : ``,
    ``,
    `<b>ğŸ›¡ï¸ Modo:</b> ${escapeHtml(ctx.mode)}`
  ].filter(Boolean).join("\n");
}

E) OPERACIÃ“N EJECUTADA (SELL) â€” con PnL cierre USD en NEGRITA (lo que pediste)
function buildTradeSellExecutedHTML(ctx: { env; pair; amount; price; total; orderId; exitType; trigger; pnlUsd; pnlPct; feeUsd; strategyLabel; confPct; reason; mode; }): string {
  const pnlSign = Number(ctx.pnlUsd) >= 0 ? "+" : "";
  const pnlUsdTxt = (ctx.pnlUsd === null || ctx.pnlUsd === undefined)
    ? "N/A (sin entryPrice)"
    : `${pnlSign}$${Number(ctx.pnlUsd).toFixed(2)}${(ctx.pnlPct !== null && ctx.pnlPct !== undefined) ? ` (${Number(ctx.pnlPct).toFixed(2)}%)` : ""}`;

  const feeTxt = (ctx.feeUsd === null || ctx.feeUsd === undefined) ? "N/A" : `$${Number(ctx.feeUsd).toFixed(2)}`;

  return [
    `<b>${escapeHtml(ctx.env)} ğŸ”´ OperaciÃ³n AutomÃ¡tica Ejecutada</b>`,
    ``,
    `<b>ğŸ“Œ Tipo:</b> SELL`,
    `<b>ğŸ“Œ Par:</b> ${escapeHtml(ctx.pair)}`,
    `<b>ğŸ“Œ Cantidad:</b> ${escapeHtml(ctx.amount)}`,
    `<b>ğŸ“Œ Precio:</b> $${escapeHtml(ctx.price)}`,
    `<b>ğŸ“Œ Total:</b> $${escapeHtml(ctx.total)}`,
    `<b>ğŸ”— ID:</b> <code>${escapeHtml(ctx.orderId)}</code>`,
    ``,
    `<b>ğŸ’° Resultado del cierre:</b>`,
    `â€¢ <b>PnL cierre:</b> <b>${escapeHtml(pnlUsdTxt)}</b>`,
    `â€¢ <b>Fee:</b> ${escapeHtml(feeTxt)}`,
    ``,
    `<b>ğŸ›¡ï¸ Salida (SMART_GUARD):</b>`,
    `â€¢ <b>Tipo:</b> ${escapeHtml(ctx.exitType)}`,
    ctx.trigger ? `â€¢ <b>Trigger:</b> ${escapeHtml(ctx.trigger)}` : ``,
    ``,
    `<b>ğŸ§  Estrategia origen:</b> ${escapeHtml(ctx.strategyLabel)} | <b>Confianza:</b> ${escapeHtml(ctx.confPct)}%`,
    `<b>ğŸ“ RazÃ³n:</b> ${escapeHtml(ctx.reason)}`,
    ``,
    `<b>ğŸ›¡ï¸ Modo:</b> ${escapeHtml(ctx.mode)}`
  ].filter(Boolean).join("\n");
}

F) ORPHAN (como antes, con negritas)
function buildOrphanSellHTML(ctx: { env; assetOrPair; amount; price; total; orderId; reasonCode; }): string {
  return [
    `<b>${escapeHtml(ctx.env)} ğŸŸ  LIQUIDACIÃ“N HUÃ‰RFANA</b>`,
    ``,
    `<b>ğŸ“Œ OperaciÃ³n:</b>`,
    `â€¢ Par/Activo: ${escapeHtml(ctx.assetOrPair)}`,
    `â€¢ Cantidad: ${escapeHtml(ctx.amount)}`,
    `â€¢ Precio: ${escapeHtml(ctx.price)}`,
    `â€¢ Total: ${escapeHtml(ctx.total)}`,
    `â€¢ ID: <code>${escapeHtml(ctx.orderId)}</code>`,
    ``,
    `<b>âš ï¸ Resultado:</b>`,
    `â€¢ <b>PnL cierre:</b> N/A (sin entryPrice)`,
    `â€¢ Reason: ${escapeHtml(ctx.reasonCode)}`
  ].join("\n");
}

CAMBIO 4 â€” Aplicar estas plantillas en los puntos reales (trades, heartbeat, signals, comandos)
- Reemplazar los textos actuales por builders HTML.
- Asegurar que cada sendMessage usa parse_mode="HTML".
- Para comandos (/estado, /balance, /exposicion, etc.) usar el mismo estilo: tÃ­tulos <b>...</b> y secciones.

CRITERIOS DE ACEPTACIÃ“N
1) En Telegram se ven negritas en tÃ­tulos y encabezados (como en tus capturas).
2) Se mantienen los emoticonos/bullets (âœ… ğŸ“Œ ğŸ“Š ğŸ’— etc.).
3) No se rompe el mensaje por caracteres especiales (escapeHtml aplicado).
