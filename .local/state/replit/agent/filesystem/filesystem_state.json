{"file_contents":{"client/src/components/ui/dropdown-menu.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as DropdownMenuPrimitive from \"@radix-ui/react-dropdown-menu\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst DropdownMenu = DropdownMenuPrimitive.Root\n\nconst DropdownMenuTrigger = DropdownMenuPrimitive.Trigger\n\nconst DropdownMenuGroup = DropdownMenuPrimitive.Group\n\nconst DropdownMenuPortal = DropdownMenuPrimitive.Portal\n\nconst DropdownMenuSub = DropdownMenuPrimitive.Sub\n\nconst DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup\n\nconst DropdownMenuSubTrigger = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <DropdownMenuPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto\" />\n  </DropdownMenuPrimitive.SubTrigger>\n))\nDropdownMenuSubTrigger.displayName =\n  DropdownMenuPrimitive.SubTrigger.displayName\n\nconst DropdownMenuSubContent = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <DropdownMenuPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuSubContent.displayName =\n  DropdownMenuPrimitive.SubContent.displayName\n\nconst DropdownMenuContent = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>\n>(({ className, sideOffset = 4, ...props }, ref) => (\n  <DropdownMenuPrimitive.Portal>\n    <DropdownMenuPrimitive.Content\n      ref={ref}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md\",\n        \"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]\",\n        className\n      )}\n      {...props}\n    />\n  </DropdownMenuPrimitive.Portal>\n))\nDropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName\n\nconst DropdownMenuItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <DropdownMenuPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName\n\nconst DropdownMenuCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <DropdownMenuPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <DropdownMenuPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </DropdownMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </DropdownMenuPrimitive.CheckboxItem>\n))\nDropdownMenuCheckboxItem.displayName =\n  DropdownMenuPrimitive.CheckboxItem.displayName\n\nconst DropdownMenuRadioItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <DropdownMenuPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <DropdownMenuPrimitive.ItemIndicator>\n        <Circle className=\"h-2 w-2 fill-current\" />\n      </DropdownMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </DropdownMenuPrimitive.RadioItem>\n))\nDropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName\n\nconst DropdownMenuLabel = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <DropdownMenuPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName\n\nconst DropdownMenuSeparator = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <DropdownMenuPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nDropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName\n\nconst DropdownMenuShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\"ml-auto text-xs tracking-widest opacity-60\", className)}\n      {...props}\n    />\n  )\n}\nDropdownMenuShortcut.displayName = \"DropdownMenuShortcut\"\n\nexport {\n  DropdownMenu,\n  DropdownMenuTrigger,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuCheckboxItem,\n  DropdownMenuRadioItem,\n  DropdownMenuLabel,\n  DropdownMenuSeparator,\n  DropdownMenuShortcut,\n  DropdownMenuGroup,\n  DropdownMenuPortal,\n  DropdownMenuSub,\n  DropdownMenuSubContent,\n  DropdownMenuSubTrigger,\n  DropdownMenuRadioGroup,\n}\n","path":null,"size_bytes":7606,"size_tokens":null},"client/src/components/ui/card.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Card = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"rounded-xl border bg-card text-card-foreground shadow\",\n      className\n    )}\n    {...props}\n  />\n))\nCard.displayName = \"Card\"\n\nconst CardHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex flex-col space-y-1.5 p-6\", className)}\n    {...props}\n  />\n))\nCardHeader.displayName = \"CardHeader\"\n\nconst CardTitle = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"font-semibold leading-none tracking-tight\", className)}\n    {...props}\n  />\n))\nCardTitle.displayName = \"CardTitle\"\n\nconst CardDescription = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nCardDescription.displayName = \"CardDescription\"\n\nconst CardContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n))\nCardContent.displayName = \"CardContent\"\n\nconst CardFooter = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex items-center p-6 pt-0\", className)}\n    {...props}\n  />\n))\nCardFooter.displayName = \"CardFooter\"\n\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }\n","path":null,"size_bytes":1828,"size_tokens":null},"client/src/components/ui/alert.tsx":{"content":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst alertVariants = cva(\n  \"relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-background text-foreground\",\n        destructive:\n          \"border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst Alert = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>\n>(({ className, variant, ...props }, ref) => (\n  <div\n    ref={ref}\n    role=\"alert\"\n    className={cn(alertVariants({ variant }), className)}\n    {...props}\n  />\n))\nAlert.displayName = \"Alert\"\n\nconst AlertTitle = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLHeadingElement>\n>(({ className, ...props }, ref) => (\n  <h5\n    ref={ref}\n    className={cn(\"mb-1 font-medium leading-none tracking-tight\", className)}\n    {...props}\n  />\n))\nAlertTitle.displayName = \"AlertTitle\"\n\nconst AlertDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm [&_p]:leading-relaxed\", className)}\n    {...props}\n  />\n))\nAlertDescription.displayName = \"AlertDescription\"\n\nexport { Alert, AlertTitle, AlertDescription }\n","path":null,"size_bytes":1598,"size_tokens":null},"server/services/telegram.ts":{"content":"import TelegramBot from \"node-telegram-bot-api\";\nimport cron from \"node-cron\";\nimport si from \"systeminformation\";\nimport { storage } from \"../storage\";\nimport type { TelegramChat } from \"@shared/schema\";\nimport { environment } from \"./environment\";\n\n// ============================================================\n// HTML ESCAPE HELPER - Previene markup roto en mensajes\n// ============================================================\nfunction escapeHtml(s: unknown): string {\n  const str = String(s ?? \"\");\n  return str\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#039;\");\n}\n\n// ============================================================\n// SPANISH DATE FORMATTER - Formato profesional de fecha/hora\n// ============================================================\nfunction formatSpanishDate(dateInput?: string | Date): string {\n  try {\n    const date = dateInput ? new Date(dateInput) : new Date();\n    return date.toLocaleString(\"es-ES\", { \n      timeZone: \"Europe/Madrid\",\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\"\n    });\n  } catch {\n    return new Date().toLocaleString(\"es-ES\", { timeZone: \"Europe/Madrid\" });\n  }\n}\n\n// ============================================================\n// TELEGRAM MESSAGE TEMPLATES (HTML format)\n// ============================================================\n\ninterface BotStartedContext {\n  env: string;\n  strategy: string;\n  risk: string;\n  pairs: string[];\n  balanceUsd: string;\n  mode: string;\n  positionCount: number;\n}\n\nfunction buildBotStartedHTML(ctx: BotStartedContext): string {\n  return [\n    `ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸`,\n    `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`,\n    `âœ… <b>Bot Iniciado</b>`,\n    ``,\n    `ğŸ“Š <b>ConfiguraciÃ³n:</b>`,\n    `   â€¢ Estrategia: <code>${escapeHtml(ctx.strategy)}</code>`,\n    `   â€¢ Riesgo: <code>${escapeHtml(ctx.risk)}</code>`,\n    `   â€¢ Pares: <code>${escapeHtml(ctx.pairs.join(\", \"))}</code>`,\n    ``,\n    `ğŸ’° <b>Estado:</b>`,\n    `   â€¢ Balance: <code>$${escapeHtml(ctx.balanceUsd)}</code>`,\n    `   â€¢ Posiciones: <code>${ctx.positionCount}</code>`,\n    ``,\n    `âš™ï¸ <b>Modo:</b> <code>${escapeHtml(ctx.mode)}</code>`,\n    `ğŸ·ï¸ <b>Entorno:</b> <code>${escapeHtml(ctx.env)}</code>`,\n    `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`\n  ].join(\"\\n\");\n}\n\ninterface HeartbeatContext {\n  env: string;\n  cpu: string;\n  mem: string;\n  disk: string;\n  uptime: string;\n  krakenOk: boolean;\n  telegramOk: boolean;\n  dbOk: boolean;\n  ts: string;\n}\n\nfunction buildHeartbeatHTML(ctx: HeartbeatContext): string {\n  return [\n    `ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸`,\n    `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`,\n    `âœ… <b>Sistema operativo 24x7</b>`,\n    `VerificaciÃ³n automÃ¡tica de funcionamiento`,\n    ``,\n    `ğŸ“Š <b>Recursos del sistema:</b>`,\n    `   â€¢ CPU: <code>${escapeHtml(ctx.cpu)}</code>`,\n    `   â€¢ Memoria: <code>${escapeHtml(ctx.mem)}</code>`,\n    `   â€¢ Disco: <code>${escapeHtml(ctx.disk)}</code>`,\n    `   â€¢ Uptime: <code>${escapeHtml(ctx.uptime)}</code>`,\n    ``,\n    `ğŸ”Œ <b>Conexiones:</b>`,\n    `   ${ctx.krakenOk ? \"âœ…\" : \"âŒ\"} Kraken`,\n    `   ${ctx.telegramOk ? \"âœ…\" : \"âŒ\"} Telegram`,\n    `   ${ctx.dbOk ? \"âœ…\" : \"âŒ\"} Base de datos`,\n    ``,\n    `ğŸ“… ${formatSpanishDate(ctx.ts)}`,\n    `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`\n  ].join(\"\\n\");\n}\n\ninterface DailyReportContext {\n  env: string;\n  cpu: string;\n  mem: string;\n  disk: string;\n  uptime: string;\n  krakenOk: boolean;\n  telegramOk: boolean;\n  dbOk: boolean;\n  dryRun: boolean;\n  mode: string;\n  strategy: string;\n  pairs: string;\n  positionCount: number;\n  exposureUsd: string;\n  ts: string;\n}\n\nfunction buildDailyReportHTML(ctx: DailyReportContext): string {\n  return [\n    `ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸`,\n    `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`,\n    `ğŸ“‹ <b>REPORTE DIARIO (14:00)</b>`,\n    ``,\n    `ğŸ”Œ <b>Estado de conexiones:</b>`,\n    `   ${ctx.krakenOk ? \"âœ…\" : \"âŒ\"} Kraken`,\n    `   ${ctx.dbOk ? \"âœ…\" : \"âŒ\"} Base de datos`,\n    `   ${ctx.telegramOk ? \"âœ…\" : \"âŒ\"} Telegram`,\n    ``,\n    `ğŸ“Š <b>Recursos del sistema:</b>`,\n    `   â€¢ CPU: <code>${escapeHtml(ctx.cpu)}</code>`,\n    `   â€¢ Memoria: <code>${escapeHtml(ctx.mem)}</code>`,\n    `   â€¢ Disco: <code>${escapeHtml(ctx.disk)}</code>`,\n    `   â€¢ Uptime: <code>${escapeHtml(ctx.uptime)}</code>`,\n    ``,\n    `ğŸ¤– <b>Estado del bot:</b>`,\n    `   â€¢ Entorno: <code>${escapeHtml(ctx.env)}</code>`,\n    `   â€¢ DRY_RUN: <code>${ctx.dryRun ? \"SÃ\" : \"NO\"}</code>`,\n    `   â€¢ Modo: <code>${escapeHtml(ctx.mode)}</code>`,\n    `   â€¢ Estrategia: <code>${escapeHtml(ctx.strategy)}</code>`,\n    `   â€¢ Pares: <code>${escapeHtml(ctx.pairs)}</code>`,\n    ``,\n    `ğŸ’° <b>Portfolio:</b>`,\n    `   â€¢ Posiciones: <code>${ctx.positionCount}</code>`,\n    `   â€¢ ExposiciÃ³n: <code>$${escapeHtml(ctx.exposureUsd)}</code>`,\n    ``,\n    `ğŸ“… ${formatSpanishDate(ctx.ts)}`,\n    `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`\n  ].join(\"\\n\");\n}\n\ninterface TradeBuyContext {\n  env: string;\n  pair: string;\n  amount: string;\n  price: string;\n  total: string;\n  orderId: string;\n  strategyLabel: string;\n  confPct: string;\n  reason: string;\n  signalsSummary?: string;\n  mode: string;\n}\n\nfunction buildTradeBuyHTML(ctx: TradeBuyContext): string {\n  const lines = [\n    `ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸`,\n    `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`,\n    `ğŸŸ¢ <b>SEÃ‘AL: COMPRAR ${escapeHtml(ctx.pair)}</b> ğŸŸ¢`,\n    ``,\n    `ğŸ’µ <b>Precio:</b> <code>$${escapeHtml(ctx.price)}</code>`,\n    `ğŸ“¦ <b>Cantidad:</b> <code>${escapeHtml(ctx.amount)}</code>`,\n    `ğŸ’° <b>Total:</b> <code>$${escapeHtml(ctx.total)}</code>`,\n    ``\n  ];\n  \n  if (ctx.signalsSummary) {\n    lines.push(\n      `ğŸ“Š <b>Indicadores TÃ©cnicos:</b>`,\n      `${escapeHtml(ctx.signalsSummary)}`,\n      ``\n    );\n  }\n  \n  lines.push(\n    `ğŸ§  <b>Estrategia:</b> ${escapeHtml(ctx.strategyLabel)}`,\n    `ğŸ“ˆ <b>Confianza:</b> <code>${escapeHtml(ctx.confPct)}%</code>`,\n    ``,\n    `ğŸ›¡ï¸ <b>Modo:</b> <code>${escapeHtml(ctx.mode)}</code>`,\n    `ğŸ”— <b>ID:</b> <code>${escapeHtml(ctx.orderId)}</code>`,\n    ``,\n    `ğŸ“… ${formatSpanishDate()}`,\n    `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`\n  );\n  return lines.join(\"\\n\");\n}\n\ninterface TradeSellContext {\n  env: string;\n  pair: string;\n  amount: string;\n  price: string;\n  total: string;\n  orderId: string;\n  exitType: string;\n  trigger?: string;\n  pnlUsd: number | null;\n  pnlPct: number | null;\n  feeUsd?: number | null;\n  strategyLabel: string;\n  confPct: string;\n  reason: string;\n  mode: string;\n}\n\nfunction buildTradeSellHTML(ctx: TradeSellContext): string {\n  const pnlSign = (ctx.pnlUsd !== null && ctx.pnlUsd >= 0) ? \"+\" : \"\";\n  const pnlEmoji = (ctx.pnlUsd !== null && ctx.pnlUsd >= 0) ? \"ğŸ“ˆ\" : \"ğŸ“‰\";\n  const pnlUsdTxt = (ctx.pnlUsd === null || ctx.pnlUsd === undefined)\n    ? \"N/A\"\n    : `${pnlSign}$${ctx.pnlUsd.toFixed(2)}`;\n  const pnlPctTxt = (ctx.pnlPct !== null && ctx.pnlPct !== undefined)\n    ? `${pnlSign}${ctx.pnlPct.toFixed(2)}%`\n    : \"\";\n  const feeTxt = (ctx.feeUsd === null || ctx.feeUsd === undefined) ? \"N/A\" : `$${ctx.feeUsd.toFixed(2)}`;\n\n  const lines = [\n    `ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸`,\n    `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`,\n    `ğŸ”´ <b>SEÃ‘AL: VENDER ${escapeHtml(ctx.pair)}</b> ğŸ”´`,\n    ``,\n    `ğŸ’µ <b>Precio:</b> <code>$${escapeHtml(ctx.price)}</code>`,\n    `ğŸ“¦ <b>Cantidad:</b> <code>${escapeHtml(ctx.amount)}</code>`,\n    `ğŸ’° <b>Total:</b> <code>$${escapeHtml(ctx.total)}</code>`,\n    ``,\n    `${pnlEmoji} <b>Resultado:</b>`,\n    `   â€¢ PnL: <code>${escapeHtml(pnlUsdTxt)}</code> ${pnlPctTxt ? `(<code>${escapeHtml(pnlPctTxt)}</code>)` : \"\"}`,\n    `   â€¢ Fee: <code>${escapeHtml(feeTxt)}</code>`,\n    ``,\n    `ğŸ›¡ï¸ <b>Tipo de salida:</b> <code>${escapeHtml(ctx.exitType)}</code>`\n  ];\n  \n  if (ctx.trigger) {\n    lines.push(`âš¡ <b>Trigger:</b> <code>${escapeHtml(ctx.trigger)}</code>`);\n  }\n  \n  lines.push(\n    ``,\n    `ğŸ§  <b>Estrategia:</b> ${escapeHtml(ctx.strategyLabel)}`,\n    `ğŸ“ˆ <b>Confianza:</b> <code>${escapeHtml(ctx.confPct)}%</code>`,\n    ``,\n    `âš™ï¸ <b>Modo:</b> <code>${escapeHtml(ctx.mode)}</code>`,\n    `ğŸ”— <b>ID:</b> <code>${escapeHtml(ctx.orderId)}</code>`,\n    ``,\n    `ğŸ“… ${formatSpanishDate()}`,\n    `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`\n  );\n  return lines.join(\"\\n\");\n}\n\ninterface OrphanSellContext {\n  env: string;\n  assetOrPair: string;\n  amount: string;\n  price: string;\n  total: string;\n  orderId: string;\n  reasonCode: string;\n}\n\nfunction buildOrphanSellHTML(ctx: OrphanSellContext): string {\n  return [\n    `ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸`,\n    `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`,\n    `ğŸŸ  <b>LIQUIDACIÃ“N HUÃ‰RFANA</b> ğŸŸ `,\n    ``,\n    `ğŸ“¦ <b>OperaciÃ³n:</b>`,\n    `   â€¢ Par/Activo: <code>${escapeHtml(ctx.assetOrPair)}</code>`,\n    `   â€¢ Cantidad: <code>${escapeHtml(ctx.amount)}</code>`,\n    `   â€¢ Precio: <code>${escapeHtml(ctx.price)}</code>`,\n    `   â€¢ Total: <code>${escapeHtml(ctx.total)}</code>`,\n    ``,\n    `âš ï¸ <b>Resultado:</b>`,\n    `   â€¢ PnL cierre: <code>N/A (sin entryPrice)</code>`,\n    `   â€¢ RazÃ³n: <code>${escapeHtml(ctx.reasonCode)}</code>`,\n    ``,\n    `ğŸ”— <b>ID:</b> <code>${escapeHtml(ctx.orderId)}</code>`,\n    ``,\n    `ğŸ“… ${formatSpanishDate()}`,\n    `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`\n  ].join(\"\\n\");\n}\n\ninterface SignalContext {\n  side: \"BUY\" | \"SELL\";\n  symbol: string;\n  price: string;\n  investPct?: string;\n  rsi?: string;\n  macd?: string;\n  adx?: string;\n  regime?: string;\n  ts: string;\n}\n\nfunction buildSignalHTML(ctx: SignalContext): string {\n  const sideEmoji = ctx.side === \"BUY\" ? \"ğŸŸ¢\" : \"ğŸ”´\";\n  const sideText = ctx.side === \"BUY\" ? \"COMPRAR\" : \"VENDER\";\n  const lines = [\n    `ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸`,\n    `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`,\n    `${sideEmoji} <b>SEÃ‘AL: ${sideText} ${escapeHtml(ctx.symbol)}</b> ${sideEmoji}`,\n    ``,\n    `ğŸ’µ <b>Precio:</b> <code>${escapeHtml(ctx.price)} USDT</code>`\n  ];\n  \n  if (ctx.investPct) {\n    lines.push(`ğŸ’° <b>InversiÃ³n recomendada:</b> <code>${escapeHtml(ctx.investPct)}%</code>`);\n  }\n  \n  if (ctx.rsi || ctx.macd || ctx.adx) {\n    lines.push(``, `ğŸ“Š <b>Indicadores TÃ©cnicos:</b>`);\n    if (ctx.rsi) lines.push(`   â€¢ RSI: <code>${escapeHtml(ctx.rsi)}</code>`);\n    if (ctx.macd) lines.push(`   â€¢ MACD: <code>${escapeHtml(ctx.macd)}</code>`);\n    if (ctx.adx) lines.push(`   â€¢ ADX: <code>${escapeHtml(ctx.adx)}</code>`);\n  }\n  \n  if (ctx.regime) {\n    lines.push(``, `ğŸ§­ <b>RÃ©gimen de mercado:</b> <code>${escapeHtml(ctx.regime)}</code>`);\n  }\n  \n  lines.push(\n    ``,\n    `ğŸ“… ${formatSpanishDate(ctx.ts)}`,\n    `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`\n  );\n  return lines.join(\"\\n\");\n}\n\n// Export templates for use in tradingEngine\nexport const telegramTemplates = {\n  escapeHtml,\n  buildBotStartedHTML,\n  buildHeartbeatHTML,\n  buildDailyReportHTML,\n  buildTradeBuyHTML,\n  buildTradeSellHTML,\n  buildOrphanSellHTML,\n  buildSignalHTML,\n};\n\ninterface TelegramConfig {\n  token: string;\n  chatId: string;\n}\n\ntype AlertType = \"trades\" | \"errors\" | \"system\" | \"balance\" | \"status\";\n\ntype EngineController = {\n  start: () => Promise<void>;\n  stop: () => Promise<void>;\n  isActive: () => boolean;\n  getBalance?: () => Promise<Record<string, string>>;\n  getOpenPositions?: () => Map<string, { amount: number; entryPrice: number }>;\n};\n\nexport class TelegramService {\n  private bot: TelegramBot | null = null;\n  private chatId: string = \"\";\n  private engineController: EngineController | null = null;\n  private startTime: Date = new Date();\n  private heartbeatInterval: NodeJS.Timeout | null = null;\n  private dailyReportJob: cron.ScheduledTask | null = null;\n  private lastDailyReportDate: string = \"\";\n\n  setEngineController(controller: EngineController) {\n    this.engineController = controller;\n  }\n\n  initialize(config: TelegramConfig) {\n    if (this.bot) {\n      try {\n        this.bot.stopPolling();\n        this.bot.removeAllListeners();\n      } catch (e) {}\n    }\n    \n    // Activar polling solo en Docker (NAS) - detectamos por variable de entorno\n    const isDocker = process.env.DOCKER_ENV === 'true' || process.env.NODE_ENV === 'production';\n    const enablePolling = isDocker;\n    \n    console.log(`[telegram] Inicializando bot - Polling: ${enablePolling ? 'ACTIVADO (Docker/NAS)' : 'DESACTIVADO (Replit)'}`);\n    \n    this.bot = new TelegramBot(config.token, { polling: enablePolling });\n    this.chatId = config.chatId;\n    this.setupCommands();\n  }\n\n  private setupCommands() {\n    if (!this.bot) return;\n\n    this.bot.onText(/\\/estado/, async (msg) => {\n      await this.handleEstado(msg.chat.id);\n    });\n\n    this.bot.onText(/\\/pausar/, async (msg) => {\n      await this.handlePausar(msg.chat.id);\n    });\n\n    this.bot.onText(/\\/reanudar/, async (msg) => {\n      await this.handleReanudar(msg.chat.id);\n    });\n\n    this.bot.onText(/\\/ultimas/, async (msg) => {\n      await this.handleUltimas(msg.chat.id);\n    });\n\n    this.bot.onText(/\\/ayuda/, async (msg) => {\n      await this.handleAyuda(msg.chat.id);\n    });\n\n    this.bot.onText(/\\/balance/, async (msg) => {\n      await this.handleBalance(msg.chat.id);\n    });\n\n    this.bot.onText(/\\/config/, async (msg) => {\n      await this.handleConfig(msg.chat.id);\n    });\n\n    this.bot.onText(/\\/exposicion/, async (msg) => {\n      await this.handleExposicion(msg.chat.id);\n    });\n\n    this.bot.onText(/\\/uptime/, async (msg) => {\n      await this.handleUptime(msg.chat.id);\n    });\n\n    this.bot.onText(/\\/menu/, async (msg) => {\n      await this.handleMenu(msg.chat.id);\n    });\n\n    this.bot.onText(/\\/channels/, async (msg) => {\n      await this.handleChannels(msg.chat.id);\n    });\n\n    // Callback query handler for inline buttons\n    this.bot.on(\"callback_query\", async (query) => {\n      if (!query.data || !query.message) return;\n      await this.handleCallbackQuery(query);\n    });\n\n    this.bot.on(\"polling_error\", (error) => {\n      console.error(\"Telegram polling error:\", error.message);\n    });\n  }\n\n  private async handleEstado(chatId: number) {\n    try {\n      const config = await storage.getBotConfig();\n      \n      const engineActive = this.engineController?.isActive() ?? false;\n      const configActive = config?.isActive ?? false;\n      const status = engineActive ? \"âœ… ACTIVO (motor funcionando)\" : \n                     configActive ? \"âš ï¸ ACTIVADO (motor detenido)\" : \"â¸ï¸ PAUSADO\";\n      const strategy = config?.strategy || \"momentum\";\n      const riskLevel = config?.riskLevel || \"medium\";\n      const pairs = config?.activePairs?.join(\", \") || \"BTC/USD, ETH/USD, SOL/USD\";\n\n      const chats = await storage.getActiveTelegramChats();\n      const chatsInfo = chats.length > 0 \n        ? `${chats.length} chat(s) configurados` \n        : \"Sin chats adicionales\";\n\n      const message = `\n<b>ğŸ“Š Estado del Bot</b>\n\n<b>Estado:</b> ${escapeHtml(status)}\n<b>Estrategia:</b> ${escapeHtml(strategy)}\n<b>Nivel de riesgo:</b> ${escapeHtml(riskLevel)}\n<b>Pares activos:</b> ${escapeHtml(pairs)}\n<b>Chats Telegram:</b> ${escapeHtml(chatsInfo)}\n\n<i>Usa /ayuda para ver los comandos disponibles</i>\n      `.trim();\n\n      await this.bot?.sendMessage(chatId, message, { parse_mode: \"HTML\" });\n    } catch (error: any) {\n      await this.bot?.sendMessage(chatId, `âŒ Error obteniendo estado: ${escapeHtml(error.message)}`);\n    }\n  }\n\n  private async handlePausar(chatId: number) {\n    try {\n      await storage.updateBotConfig({ isActive: false });\n      \n      if (this.engineController) {\n        await this.engineController.stop();\n      }\n      \n      await this.bot?.sendMessage(chatId, \"<b>â¸ï¸ Bot pausado correctamente</b>\\n\\nEl motor de trading se ha detenido.\\nUsa /reanudar para volver a activarlo.\", { parse_mode: \"HTML\" });\n    } catch (error: any) {\n      await this.bot?.sendMessage(chatId, `âŒ Error pausando bot: ${escapeHtml(error.message)}`);\n    }\n  }\n\n  private async handleReanudar(chatId: number) {\n    try {\n      await storage.updateBotConfig({ isActive: true });\n      \n      if (this.engineController) {\n        await this.engineController.start();\n      }\n      \n      await this.bot?.sendMessage(chatId, \"<b>âœ… Bot activado correctamente</b>\\n\\nEl motor de trading ha comenzado a analizar el mercado.\", { parse_mode: \"HTML\" });\n    } catch (error: any) {\n      await this.bot?.sendMessage(chatId, `âŒ Error activando bot: ${escapeHtml(error.message)}`);\n    }\n  }\n\n  private async handleUltimas(chatId: number) {\n    try {\n      const trades = await storage.getTrades(5);\n      \n      if (trades.length === 0) {\n        await this.bot?.sendMessage(chatId, \"ğŸ“­ No hay operaciones recientes.\");\n        return;\n      }\n\n      let message = \"<b>ğŸ“ˆ Ãšltimas operaciones:</b>\\n\\n\";\n      \n      for (const trade of trades) {\n        const emoji = trade.type === \"buy\" ? \"ğŸŸ¢\" : \"ğŸ”´\";\n        const tipo = trade.type === \"buy\" ? \"Compra\" : \"Venta\";\n        const fecha = trade.executedAt ? new Date(trade.executedAt).toLocaleDateString(\"es-ES\") : \"Pendiente\";\n        \n        message += `${emoji} <b>${tipo}</b> ${escapeHtml(trade.pair)}\\n`;\n        message += `   Precio: $${parseFloat(trade.price).toFixed(2)}\\n`;\n        message += `   Cantidad: ${escapeHtml(trade.amount)}\\n`;\n        message += `   Fecha: ${fecha}\\n\\n`;\n      }\n\n      await this.bot?.sendMessage(chatId, message.trim(), { parse_mode: \"HTML\" });\n    } catch (error: any) {\n      await this.bot?.sendMessage(chatId, `âŒ Error obteniendo operaciones: ${escapeHtml(error.message)}`);\n    }\n  }\n\n  private async handleAyuda(chatId: number) {\n    const message = `\n<b>ğŸ¤– Comandos disponibles:</b>\n\n/estado - Ver estado del bot\n/balance - Ver balance actual\n/config - Ver configuraciÃ³n de riesgo\n/exposicion - Ver exposiciÃ³n por par\n/uptime - Ver tiempo encendido\n/menu - MenÃº interactivo con botones\n/channels - Configurar alertas por chat\n/pausar - Pausar el bot\n/reanudar - Activar el bot\n/ultimas - Ver Ãºltimas operaciones\n/ayuda - Ver esta ayuda\n\n<i>KrakenBot.AI - Trading AutÃ³nomo</i>\n    `.trim();\n\n    await this.bot?.sendMessage(chatId, message, { parse_mode: \"HTML\" });\n  }\n\n  private async handleBalance(chatId: number) {\n    try {\n      if (!this.engineController?.getBalance) {\n        await this.bot?.sendMessage(chatId, \"âš ï¸ Kraken no estÃ¡ conectado. Configura las credenciales primero.\");\n        return;\n      }\n      const balances = await this.engineController.getBalance();\n      const usd = parseFloat(balances?.ZUSD || balances?.USD || \"0\");\n      const btc = parseFloat(balances?.XXBT || balances?.XBT || \"0\");\n      const eth = parseFloat(balances?.XETH || balances?.ETH || \"0\");\n      const sol = parseFloat(balances?.SOL || \"0\");\n\n      const message = `\n<b>ğŸ’° Balance Actual</b>\n\n<b>USD:</b> $${usd.toFixed(2)}\n<b>BTC:</b> ${btc.toFixed(6)}\n<b>ETH:</b> ${eth.toFixed(6)}\n<b>SOL:</b> ${sol.toFixed(4)}\n\n<i>Actualizado: ${new Date().toLocaleString(\"es-ES\")}</i>\n      `.trim();\n\n      await this.bot?.sendMessage(chatId, message, { parse_mode: \"HTML\" });\n    } catch (error: any) {\n      await this.bot?.sendMessage(chatId, `âŒ Error obteniendo balance: ${escapeHtml(error.message)}`);\n    }\n  }\n\n  private async handleConfig(chatId: number) {\n    try {\n      const config = await storage.getBotConfig();\n      const sl = parseFloat(config?.stopLossPercent?.toString() || \"5\");\n      const tp = parseFloat(config?.takeProfitPercent?.toString() || \"7\");\n      const trailing = config?.trailingStopEnabled ? `${config.trailingStopPercent}%` : \"Desactivado\";\n      const pairExp = parseFloat(config?.maxPairExposurePct?.toString() || \"25\");\n      const totalExp = parseFloat(config?.maxTotalExposurePct?.toString() || \"60\");\n      const riskTrade = parseFloat(config?.riskPerTradePct?.toString() || \"15\");\n\n      const message = `\n<b>âš™ï¸ ConfiguraciÃ³n de Riesgo</b>\n\nğŸ›‘ <b>Stop-Loss:</b> ${sl}%\nğŸ¯ <b>Take-Profit:</b> ${tp}%\nğŸ“‰ <b>Trailing Stop:</b> ${escapeHtml(trailing)}\nğŸ’µ <b>Riesgo por trade:</b> ${riskTrade}%\nğŸ”¸ <b>Exp. por par:</b> ${pairExp}%\nğŸ”¹ <b>Exp. total:</b> ${totalExp}%\n\n<i>Estrategia: ${escapeHtml(config?.strategy || \"momentum\")}</i>\n      `.trim();\n\n      await this.bot?.sendMessage(chatId, message, { parse_mode: \"HTML\" });\n    } catch (error: any) {\n      await this.bot?.sendMessage(chatId, `âŒ Error obteniendo configuraciÃ³n: ${escapeHtml(error.message)}`);\n    }\n  }\n\n  private async handleExposicion(chatId: number) {\n    try {\n      const positions = this.engineController?.getOpenPositions?.() || new Map();\n      \n      if (positions.size === 0) {\n        await this.bot?.sendMessage(chatId, \"<b>ğŸ“Š Sin posiciones abiertas</b>\\n\\nNo hay exposiciÃ³n actual.\", { parse_mode: \"HTML\" });\n        return;\n      }\n\n      let message = \"<b>ğŸ“Š ExposiciÃ³n Actual</b>\\n\\n\";\n      let totalExp = 0;\n\n      positions.forEach((pos, pair) => {\n        const exposure = pos.amount * pos.entryPrice;\n        totalExp += exposure;\n        message += `<b>${escapeHtml(pair)}:</b> $${exposure.toFixed(2)}\\n`;\n        message += `   Entrada: $${pos.entryPrice.toFixed(2)}\\n`;\n        message += `   Cantidad: ${pos.amount.toFixed(6)}\\n\\n`;\n      });\n\n      message += `<b>Total expuesto:</b> $${totalExp.toFixed(2)}`;\n\n      await this.bot?.sendMessage(chatId, message.trim(), { parse_mode: \"HTML\" });\n    } catch (error: any) {\n      await this.bot?.sendMessage(chatId, `âŒ Error obteniendo exposiciÃ³n: ${escapeHtml(error.message)}`);\n    }\n  }\n\n  private async handleUptime(chatId: number) {\n    const now = new Date();\n    const diff = now.getTime() - this.startTime.getTime();\n    const days = Math.floor(diff / (1000 * 60 * 60 * 24));\n    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));\n    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));\n\n    const engineActive = this.engineController?.isActive() ?? false;\n    const status = engineActive ? \"âœ… Motor activo\" : \"â¸ï¸ Motor pausado\";\n\n    const message = `\n<b>â±ï¸ Uptime del Bot</b>\n\n<b>Tiempo encendido:</b> ${days}d ${hours}h ${minutes}m\n<b>Estado:</b> ${status}\n<b>Iniciado:</b> ${this.startTime.toLocaleString(\"es-ES\")}\n\n<i>KrakenBot.AI</i>\n    `.trim();\n\n    await this.bot?.sendMessage(chatId, message, { parse_mode: \"HTML\" });\n  }\n\n  private async handleMenu(chatId: number) {\n    const keyboard = {\n      inline_keyboard: [\n        [\n          { text: \"ğŸ“Š Estado\", callback_data: \"MENU_STATUS\" },\n          { text: \"ğŸ’° Balance\", callback_data: \"MENU_BALANCE\" },\n        ],\n        [\n          { text: \"ğŸ“ˆ ExposiciÃ³n\", callback_data: \"MENU_EXPOSURE\" },\n          { text: \"ğŸ”„ Sync Kraken\", callback_data: \"MENU_SYNC\" },\n        ],\n        [\n          { text: \"â¸ï¸ Pausar\", callback_data: \"MENU_PAUSE\" },\n          { text: \"â–¶ï¸ Reanudar\", callback_data: \"MENU_RESUME\" },\n        ],\n        [\n          { text: \"ğŸ“£ Canales\", callback_data: \"MENU_CHANNELS\" },\n          { text: \"â° Reporte diario\", callback_data: \"MENU_DAILY\" },\n        ],\n        [\n          { text: \"â“ Ayuda\", callback_data: \"MENU_HELP\" },\n        ],\n      ],\n    };\n\n    const message = `\n<b>ğŸ¤– MENÃš PRINCIPAL</b>\n\nSelecciona una opciÃ³n:\n    `.trim();\n\n    await this.bot?.sendMessage(chatId, message, {\n      parse_mode: \"HTML\",\n      reply_markup: keyboard,\n    });\n  }\n\n  private async handleChannels(chatId: number) {\n    try {\n      const chatIdStr = chatId.toString();\n      let chat = await storage.getTelegramChatByChatId(chatIdStr);\n      \n      if (!chat) {\n        // Create chat if doesn't exist\n        await storage.createTelegramChat({\n          name: `Chat ${chatId}`,\n          chatId: chatIdStr,\n          alertTrades: true,\n          alertErrors: true,\n          alertSystem: true,\n          alertBalance: false,\n          alertHeartbeat: true,\n          isActive: true,\n        });\n        chat = await storage.getTelegramChatByChatId(chatIdStr);\n      }\n\n      const t = chat?.alertTrades ? \"âœ…\" : \"â¬œ\";\n      const s = chat?.alertSystem ? \"âœ…\" : \"â¬œ\";\n      const e = chat?.alertErrors ? \"âœ…\" : \"â¬œ\";\n      const b = chat?.alertBalance ? \"âœ…\" : \"â¬œ\";\n      const h = chat?.alertHeartbeat ? \"âœ…\" : \"â¬œ\";\n\n      const keyboard = {\n        inline_keyboard: [\n          [\n            { text: `${t} Trades`, callback_data: \"TOGGLE_TRADES\" },\n            { text: `${s} System`, callback_data: \"TOGGLE_SYSTEM\" },\n          ],\n          [\n            { text: `${e} Errors`, callback_data: \"TOGGLE_ERRORS\" },\n            { text: `${b} Balance`, callback_data: \"TOGGLE_BALANCE\" },\n          ],\n          [\n            { text: `${h} Heartbeat`, callback_data: \"TOGGLE_HEARTBEAT\" },\n            { text: \"ğŸ“ƒ Listar\", callback_data: \"LIST_CHATS\" },\n          ],\n          [\n            { text: \"â¬…ï¸ MenÃº\", callback_data: \"MENU_HOME\" },\n          ],\n        ],\n      };\n\n      const message = `\n<b>ğŸ“£ GESTIÃ“N DE CANALES</b>\nChat actual: <code>${chatId}</code>\n\n<b>ConfiguraciÃ³n:</b>\n${t} Trades | ${s} Sistema | ${e} Errores\n${b} Balance | ${h} Heartbeat\n\n<i>Pulsa para activar/desactivar</i>\n      `.trim();\n\n      await this.bot?.sendMessage(chatId, message, {\n        parse_mode: \"HTML\",\n        reply_markup: keyboard,\n      });\n    } catch (error: any) {\n      await this.bot?.sendMessage(chatId, `âŒ Error: ${escapeHtml(error.message)}`);\n    }\n  }\n\n  private async handleCallbackQuery(query: TelegramBot.CallbackQuery) {\n    const chatId = query.message!.chat.id;\n    const data = query.data!;\n\n    try {\n      // Answer callback to remove loading state\n      await this.bot?.answerCallbackQuery(query.id);\n\n      switch (data) {\n        case \"MENU_HOME\":\n          await this.handleMenu(chatId);\n          break;\n        case \"MENU_STATUS\":\n          await this.handleEstado(chatId);\n          break;\n        case \"MENU_BALANCE\":\n          await this.handleBalance(chatId);\n          break;\n        case \"MENU_EXPOSURE\":\n          await this.handleExposicion(chatId);\n          break;\n        case \"MENU_SYNC\":\n          await this.handleSyncCallback(chatId);\n          break;\n        case \"MENU_PAUSE\":\n          await this.handlePausar(chatId);\n          break;\n        case \"MENU_RESUME\":\n          await this.handleReanudar(chatId);\n          break;\n        case \"MENU_CHANNELS\":\n          await this.handleChannels(chatId);\n          break;\n        case \"MENU_DAILY\":\n          await this.handleDailyConfig(chatId);\n          break;\n        case \"MENU_HELP\":\n          await this.handleAyuda(chatId);\n          break;\n        case \"TOGGLE_TRADES\":\n        case \"TOGGLE_SYSTEM\":\n        case \"TOGGLE_ERRORS\":\n        case \"TOGGLE_BALANCE\":\n        case \"TOGGLE_HEARTBEAT\":\n          await this.handleToggleChannel(chatId, data);\n          break;\n        case \"LIST_CHATS\":\n          await this.handleListChats(chatId);\n          break;\n        default:\n          await this.bot?.sendMessage(chatId, \"âš ï¸ OpciÃ³n no reconocida\");\n      }\n    } catch (error: any) {\n      console.error(\"Callback error:\", error);\n      await this.bot?.sendMessage(chatId, `âŒ Error: ${error.message}`);\n    }\n  }\n\n  private async handleSyncCallback(chatId: number) {\n    await this.bot?.sendMessage(chatId, \"<b>ğŸ”„ Sincronizando con Kraken...</b>\", { parse_mode: \"HTML\" });\n    await this.bot?.sendMessage(chatId, \"âœ… Usa la API /api/trades/sync para sincronizar trades.\", { parse_mode: \"HTML\" });\n  }\n\n  private async handleDailyConfig(chatId: number) {\n    const message = `\n<b>â° REPORTE DIARIO</b>\n\nEl reporte tÃ©cnico se envÃ­a automÃ¡ticamente a las <b>14:00</b> (Europe/Madrid) a los canales con <b>System</b> activado.\n\nIncluye:\nâ€¢ Estado conexiones (Kraken/DB/Telegram)\nâ€¢ Recursos NAS (CPU/Mem/Disco)\nâ€¢ Estado del bot y posiciones\nâ€¢ PnL diario\n\n<i>Activa \"System\" en /channels para recibirlo</i>\n    `.trim();\n\n    const keyboard = {\n      inline_keyboard: [\n        [{ text: \"â¬…ï¸ MenÃº\", callback_data: \"MENU_HOME\" }],\n      ],\n    };\n\n    await this.bot?.sendMessage(chatId, message, {\n      parse_mode: \"HTML\",\n      reply_markup: keyboard,\n    });\n  }\n\n  private async handleToggleChannel(chatId: number, action: string) {\n    const chatIdStr = chatId.toString();\n    const field = action.replace(\"TOGGLE_\", \"\").toLowerCase();\n    \n    const fieldMap: Record<string, keyof Pick<import(\"@shared/schema\").TelegramChat, \"alertTrades\" | \"alertErrors\" | \"alertSystem\" | \"alertBalance\" | \"alertHeartbeat\">> = {\n      trades: \"alertTrades\",\n      system: \"alertSystem\",\n      errors: \"alertErrors\",\n      balance: \"alertBalance\",\n      heartbeat: \"alertHeartbeat\",\n    };\n\n    const dbField = fieldMap[field];\n    if (!dbField) return;\n\n    const chat = await storage.getTelegramChatByChatId(chatIdStr);\n    if (!chat) {\n      await this.bot?.sendMessage(chatId, \"âš ï¸ Chat no registrado. Usa /channels primero.\");\n      return;\n    }\n\n    const newValue = !chat[dbField];\n    await storage.updateTelegramChat(chat.id, { [dbField]: newValue });\n\n    const emoji = newValue ? \"âœ…\" : \"â¬œ\";\n    await this.bot?.sendMessage(chatId, `${emoji} <b>${field.charAt(0).toUpperCase() + field.slice(1)}</b> ${newValue ? \"activado\" : \"desactivado\"}`, { parse_mode: \"HTML\" });\n    \n    // Refresh channels view\n    await this.handleChannels(chatId);\n  }\n\n  private async handleListChats(chatId: number) {\n    const chats = await storage.getActiveTelegramChats();\n    \n    if (chats.length === 0) {\n      await this.bot?.sendMessage(chatId, \"ğŸ“­ No hay chats registrados.\");\n      return;\n    }\n\n    let message = \"<b>ğŸ“ƒ Chats Registrados</b>\\n\\n\";\n    for (const chat of chats) {\n      const flags = [\n        chat.alertTrades ? \"T\" : \"\",\n        chat.alertSystem ? \"S\" : \"\",\n        chat.alertErrors ? \"E\" : \"\",\n        chat.alertBalance ? \"B\" : \"\",\n        chat.alertHeartbeat ? \"H\" : \"\",\n      ].filter(Boolean).join(\"\");\n      \n      message += `â€¢ <code>${escapeHtml(chat.chatId)}</code> (${escapeHtml(chat.name)})\\n  Flags: [${flags}]\\n`;\n    }\n\n    const keyboard = {\n      inline_keyboard: [\n        [{ text: \"â¬…ï¸ MenÃº\", callback_data: \"MENU_HOME\" }],\n      ],\n    };\n\n    await this.bot?.sendMessage(chatId, message.trim(), {\n      parse_mode: \"HTML\",\n      reply_markup: keyboard,\n    });\n  }\n\n  startHeartbeat() {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n    }\n\n    const TWELVE_HOURS = 12 * 60 * 60 * 1000;\n    \n    this.heartbeatInterval = setInterval(async () => {\n      await this.sendHeartbeat();\n    }, TWELVE_HOURS);\n\n    console.log(\"[telegram] Heartbeat iniciado (cada 12h)\");\n  }\n\n  private async sendHeartbeat() {\n    try {\n      const config = await storage.getBotConfig();\n      const engineActive = this.engineController?.isActive() ?? false;\n      const status = engineActive ? \"âœ… Activo\" : \"â¸ï¸ Pausado\";\n      \n      const now = new Date();\n      const diff = now.getTime() - this.startTime.getTime();\n      const days = Math.floor(diff / (1000 * 60 * 60 * 24));\n      const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));\n\n      const trades = await storage.getTrades(5);\n      const recentOps = trades.length > 0 ? `${trades.length} recientes` : \"Sin operaciones\";\n\n      const message = `\n<b>ğŸ’“ Heartbeat - KrakenBot</b>\n\n<b>Estado:</b> ${status}\n<b>Uptime:</b> ${days}d ${hours}h\n<b>Estrategia:</b> ${escapeHtml(config?.strategy || \"momentum\")}\n<b>Pares:</b> ${escapeHtml(config?.activePairs?.join(\", \") || \"N/A\")}\n<b>Ops recientes:</b> ${escapeHtml(recentOps)}\n\n<i>${now.toLocaleString(\"es-ES\")}</i>\n      `.trim();\n\n      const chats = await storage.getActiveTelegramChats();\n      for (const chat of chats) {\n        if (chat.alertHeartbeat) {\n          await this.sendToChat(chat.chatId, message);\n        }\n      }\n\n      if (this.chatId) {\n        await this.sendMessage(message);\n      }\n    } catch (error) {\n      console.error(\"[telegram] Error enviando heartbeat:\", error);\n    }\n  }\n\n  startDailyReport() {\n    if (this.dailyReportJob) {\n      this.dailyReportJob.stop();\n    }\n\n    // Schedule daily at 14:00 Europe/Madrid\n    this.dailyReportJob = cron.schedule(\"0 14 * * *\", async () => {\n      await this.sendDailyReport();\n    }, {\n      timezone: \"Europe/Madrid\",\n    });\n\n    console.log(\"[telegram] Reporte diario programado para las 14:00 (Europe/Madrid)\");\n  }\n\n  private async sendDailyReport() {\n    try {\n      // Avoid duplicate reports\n      const today = new Date().toISOString().split(\"T\")[0];\n      if (this.lastDailyReportDate === today) {\n        console.log(\"[telegram] Reporte diario ya enviado hoy, saltando\");\n        return;\n      }\n      this.lastDailyReportDate = today;\n\n      // Get system info\n      const cpu = await si.currentLoad();\n      const mem = await si.mem();\n      const disk = await si.fsSize();\n      const osInfo = await si.osInfo();\n      const uptime = await si.time();\n\n      // Format metrics\n      const cpuLoad = cpu.currentLoad.toFixed(1);\n      const memUsedGb = (mem.used / 1024 / 1024 / 1024).toFixed(1);\n      const memTotalGb = (mem.total / 1024 / 1024 / 1024).toFixed(1);\n      const memPct = ((mem.used / mem.total) * 100).toFixed(1);\n      \n      const mainDisk = disk.find(d => d.mount === \"/\") || disk[0];\n      const diskUsedGb = mainDisk ? (mainDisk.used / 1024 / 1024 / 1024).toFixed(1) : \"N/A\";\n      const diskTotalGb = mainDisk ? (mainDisk.size / 1024 / 1024 / 1024).toFixed(1) : \"N/A\";\n      const diskPct = mainDisk ? mainDisk.use.toFixed(1) : \"N/A\";\n\n      const uptimeDays = Math.floor(uptime.uptime / 86400);\n      const uptimeHours = Math.floor((uptime.uptime % 86400) / 3600);\n      const uptimeMins = Math.floor((uptime.uptime % 3600) / 60);\n\n      // Get bot info\n      const config = await storage.getBotConfig();\n      const engineActive = this.engineController?.isActive() ?? false;\n      const positions = this.engineController?.getOpenPositions?.() || new Map();\n      \n      let totalExposure = 0;\n      positions.forEach((pos) => {\n        totalExposure += pos.amount * pos.entryPrice;\n      });\n\n      const envName = environment.isReplit ? \"REPLIT/DEV\" : \"NAS/PROD\";\n      const dryRunStatus = config?.dryRunMode ? \"SÃ\" : \"NO\";\n      const positionMode = config?.positionMode || \"SINGLE\";\n      const strategy = config?.strategy || \"momentum\";\n      const pairs = config?.activePairs?.join(\", \") || \"N/A\";\n\n      // Check connections\n      const krakenOk = this.engineController?.getBalance ? \"âœ… OK\" : \"âš ï¸ N/A\";\n      const dbOk = \"âœ… OK\"; // If we're here, DB works\n      const telegramOk = this.bot ? \"âœ… OK\" : \"âŒ ERROR\";\n\n      const message = buildDailyReportHTML({\n        env: envName,\n        cpu: `${cpuLoad}%`,\n        mem: `${memUsedGb}/${memTotalGb} GB (${memPct}%)`,\n        disk: `${diskUsedGb}/${diskTotalGb} GB (${diskPct}%)`,\n        uptime: `${uptimeDays}d ${uptimeHours}h ${uptimeMins}m`,\n        krakenOk: !!this.engineController?.getBalance,\n        telegramOk: !!this.bot,\n        dbOk: true,\n        dryRun: config?.dryRunMode ?? false,\n        mode: positionMode,\n        strategy,\n        pairs,\n        positionCount: positions.size,\n        exposureUsd: totalExposure.toFixed(2),\n        ts: new Date().toLocaleString(\"es-ES\", { timeZone: \"Europe/Madrid\" }),\n      });\n\n      // Send to chats with alertSystem enabled\n      const chats = await storage.getActiveTelegramChats();\n      for (const chat of chats) {\n        if (chat.alertSystem) {\n          await this.sendToChat(chat.chatId, message);\n        }\n      }\n\n      // Also send to main chat\n      if (this.chatId) {\n        await this.sendMessage(message);\n      }\n\n      console.log(\"[telegram] Reporte diario enviado\");\n    } catch (error) {\n      console.error(\"[telegram] Error enviando reporte diario:\", error);\n    }\n  }\n\n  isInitialized(): boolean {\n    return this.bot !== null && this.chatId !== \"\";\n  }\n\n  async sendMessage(message: string, options?: { skipPrefix?: boolean; parseMode?: \"HTML\" | \"Markdown\" }): Promise<boolean> {\n    if (!this.bot || !this.chatId) {\n      console.warn(\"Telegram not initialized, skipping notification\");\n      return false;\n    }\n\n    try {\n      const prefix = options?.skipPrefix ? \"\" : await this.getMessagePrefixHTML();\n      const fullMessage = prefix + message;\n      await this.bot.sendMessage(this.chatId, fullMessage, { \n        parse_mode: options?.parseMode ?? \"HTML\",\n        disable_web_page_preview: true \n      });\n      return true;\n    } catch (error) {\n      console.error(\"Failed to send Telegram message:\", error);\n      return false;\n    }\n  }\n\n  private async getMessagePrefixHTML(): Promise<string> {\n    try {\n      const config = await storage.getBotConfig();\n      const dryRun = config?.dryRunMode ?? false;\n      const envLabel = environment.isReplit ? \"REPLIT/DEV\" : \"NAS/PROD\";\n      const dryLabel = dryRun ? \"[DRY_RUN]\" : \"\";\n      return `<b>[${envLabel}]${dryLabel}</b> `;\n    } catch {\n      return \"<b>[UNKNOWN]</b> \";\n    }\n  }\n\n  private async getMessagePrefix(): Promise<string> {\n    try {\n      const config = await storage.getBotConfig();\n      const dryRun = config?.dryRunMode ?? false;\n      return environment.getMessagePrefix(dryRun);\n    } catch {\n      return environment.getMessagePrefix(false);\n    }\n  }\n\n  async sendToChat(chatId: string, message: string, options?: { skipPrefix?: boolean; parseMode?: \"HTML\" | \"Markdown\" }): Promise<boolean> {\n    if (!this.bot) {\n      console.warn(\"Telegram bot not initialized\");\n      return false;\n    }\n\n    try {\n      const prefix = options?.skipPrefix ? \"\" : await this.getMessagePrefixHTML();\n      const fullMessage = prefix + message;\n      await this.bot.sendMessage(chatId, fullMessage, { \n        parse_mode: options?.parseMode ?? \"HTML\",\n        disable_web_page_preview: true \n      });\n      return true;\n    } catch (error) {\n      console.error(`Failed to send message to chat ${chatId}:`, error);\n      return false;\n    }\n  }\n\n  async sendAlertToMultipleChats(message: string, alertType: AlertType): Promise<void> {\n    if (!this.bot) return;\n\n    const sentChatIds = new Set<string>();\n\n    try {\n      if (this.chatId) {\n        await this.sendMessage(message);\n        sentChatIds.add(this.chatId);\n      }\n\n      const chats = await storage.getActiveTelegramChats();\n      \n      for (const chat of chats) {\n        if (sentChatIds.has(chat.chatId)) continue;\n        \n        const shouldSend = this.shouldSendToChat(chat, alertType);\n        if (shouldSend) {\n          await this.sendToChat(chat.chatId, message);\n          sentChatIds.add(chat.chatId);\n        }\n      }\n    } catch (error) {\n      console.error(\"Error sending to multiple chats:\", error);\n    }\n  }\n\n  private shouldSendToChat(chat: TelegramChat, alertType: AlertType): boolean {\n    switch (alertType) {\n      case \"trades\":\n        return chat.alertTrades;\n      case \"errors\":\n        return chat.alertErrors;\n      case \"system\":\n        return chat.alertSystem;\n      case \"balance\":\n        return chat.alertBalance;\n      default:\n        return false;\n    }\n  }\n\n  async sendTradeNotification(trade: {\n    type: string;\n    pair: string;\n    price: string;\n    amount: string;\n    status: string;\n  }) {\n    const emoji = trade.type === \"buy\" || trade.type === \"COMPRA\" ? \"ğŸŸ¢\" : \"ğŸ”´\";\n    const message = `\n${emoji} *Nueva OperaciÃ³n*\n\n*Tipo:* ${trade.type.toUpperCase()}\n*Par:* ${trade.pair}\n*Precio:* $${trade.price}\n*Cantidad:* ${trade.amount}\n*Estado:* ${trade.status}\n\n_KrakenBot.AI - Trading AutÃ³nomo_\n    `.trim();\n\n    await this.sendAlertToMultipleChats(message, \"trades\");\n  }\n\n  async sendAlert(title: string, description: string) {\n    const message = `\nâš ï¸ *${title}*\n\n${description}\n\n_KrakenBot.AI - Sistema de Alertas_\n    `.trim();\n\n    await this.sendAlertToMultipleChats(message, \"errors\");\n  }\n\n  async sendSystemStatus(isActive: boolean, strategy: string) {\n    const emoji = isActive ? \"âœ…\" : \"â¸ï¸\";\n    const status = isActive ? \"EN LÃNEA\" : \"PAUSADO\";\n    const message = `\n${emoji} *Estado del Sistema*\n\n*Status:* ${status}\n*Estrategia:* ${strategy}\n\n_KrakenBot.AI - Monitoreo_\n    `.trim();\n\n    await this.sendAlertToMultipleChats(message, \"system\");\n  }\n\n  async sendBalanceAlert(title: string, description: string) {\n    const message = `\nğŸ’° *${title}*\n\n${description}\n\n_KrakenBot.AI - Balance_\n    `.trim();\n\n    await this.sendAlertToMultipleChats(message, \"balance\");\n  }\n}\n\nexport const telegramService = new TelegramService();\n","path":null,"size_bytes":40736,"size_tokens":null},"client/src/components/ui/breadcrumb.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { ChevronRight, MoreHorizontal } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Breadcrumb = React.forwardRef<\n  HTMLElement,\n  React.ComponentPropsWithoutRef<\"nav\"> & {\n    separator?: React.ReactNode\n  }\n>(({ ...props }, ref) => <nav ref={ref} aria-label=\"breadcrumb\" {...props} />)\nBreadcrumb.displayName = \"Breadcrumb\"\n\nconst BreadcrumbList = React.forwardRef<\n  HTMLOListElement,\n  React.ComponentPropsWithoutRef<\"ol\">\n>(({ className, ...props }, ref) => (\n  <ol\n    ref={ref}\n    className={cn(\n      \"flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5\",\n      className\n    )}\n    {...props}\n  />\n))\nBreadcrumbList.displayName = \"BreadcrumbList\"\n\nconst BreadcrumbItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentPropsWithoutRef<\"li\">\n>(({ className, ...props }, ref) => (\n  <li\n    ref={ref}\n    className={cn(\"inline-flex items-center gap-1.5\", className)}\n    {...props}\n  />\n))\nBreadcrumbItem.displayName = \"BreadcrumbItem\"\n\nconst BreadcrumbLink = React.forwardRef<\n  HTMLAnchorElement,\n  React.ComponentPropsWithoutRef<\"a\"> & {\n    asChild?: boolean\n  }\n>(({ asChild, className, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"a\"\n\n  return (\n    <Comp\n      ref={ref}\n      className={cn(\"transition-colors hover:text-foreground\", className)}\n      {...props}\n    />\n  )\n})\nBreadcrumbLink.displayName = \"BreadcrumbLink\"\n\nconst BreadcrumbPage = React.forwardRef<\n  HTMLSpanElement,\n  React.ComponentPropsWithoutRef<\"span\">\n>(({ className, ...props }, ref) => (\n  <span\n    ref={ref}\n    role=\"link\"\n    aria-disabled=\"true\"\n    aria-current=\"page\"\n    className={cn(\"font-normal text-foreground\", className)}\n    {...props}\n  />\n))\nBreadcrumbPage.displayName = \"BreadcrumbPage\"\n\nconst BreadcrumbSeparator = ({\n  children,\n  className,\n  ...props\n}: React.ComponentProps<\"li\">) => (\n  <li\n    role=\"presentation\"\n    aria-hidden=\"true\"\n    className={cn(\"[&>svg]:w-3.5 [&>svg]:h-3.5\", className)}\n    {...props}\n  >\n    {children ?? <ChevronRight />}\n  </li>\n)\nBreadcrumbSeparator.displayName = \"BreadcrumbSeparator\"\n\nconst BreadcrumbEllipsis = ({\n  className,\n  ...props\n}: React.ComponentProps<\"span\">) => (\n  <span\n    role=\"presentation\"\n    aria-hidden=\"true\"\n    className={cn(\"flex h-9 w-9 items-center justify-center\", className)}\n    {...props}\n  >\n    <MoreHorizontal className=\"h-4 w-4\" />\n    <span className=\"sr-only\">More</span>\n  </span>\n)\nBreadcrumbEllipsis.displayName = \"BreadcrumbElipssis\"\n\nexport {\n  Breadcrumb,\n  BreadcrumbList,\n  BreadcrumbItem,\n  BreadcrumbLink,\n  BreadcrumbPage,\n  BreadcrumbSeparator,\n  BreadcrumbEllipsis,\n}\n","path":null,"size_bytes":2712,"size_tokens":null},"client/src/components/ui/avatar.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as AvatarPrimitive from \"@radix-ui/react-avatar\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Avatar = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full\",\n      className\n    )}\n    {...props}\n  />\n))\nAvatar.displayName = AvatarPrimitive.Root.displayName\n\nconst AvatarImage = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Image>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Image\n    ref={ref}\n    className={cn(\"aspect-square h-full w-full\", className)}\n    {...props}\n  />\n))\nAvatarImage.displayName = AvatarPrimitive.Image.displayName\n\nconst AvatarFallback = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Fallback>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Fallback\n    ref={ref}\n    className={cn(\n      \"flex h-full w-full items-center justify-center rounded-full bg-muted\",\n      className\n    )}\n    {...props}\n  />\n))\nAvatarFallback.displayName = AvatarPrimitive.Fallback.displayName\n\nexport { Avatar, AvatarImage, AvatarFallback }\n","path":null,"size_bytes":1419,"size_tokens":null},"server/vite.ts":{"content":"import { type Express } from \"express\";\nimport { createServer as createViteServer, createLogger } from \"vite\";\nimport { type Server } from \"http\";\nimport viteConfig from \"../vite.config\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport { nanoid } from \"nanoid\";\n\nconst viteLogger = createLogger();\n\nexport async function setupVite(server: Server, app: Express) {\n  const serverOptions = {\n    middlewareMode: true,\n    hmr: { server, path: \"/vite-hmr\" },\n    allowedHosts: true as const,\n  };\n\n  const vite = await createViteServer({\n    ...viteConfig,\n    configFile: false,\n    customLogger: {\n      ...viteLogger,\n      error: (msg, options) => {\n        viteLogger.error(msg, options);\n        process.exit(1);\n      },\n    },\n    server: serverOptions,\n    appType: \"custom\",\n  });\n\n  app.use(vite.middlewares);\n\n  app.use(\"*\", async (req, res, next) => {\n    const url = req.originalUrl;\n\n    try {\n      const clientTemplate = path.resolve(\n        import.meta.dirname,\n        \"..\",\n        \"client\",\n        \"index.html\",\n      );\n\n      // always reload the index.html file from disk incase it changes\n      let template = await fs.promises.readFile(clientTemplate, \"utf-8\");\n      template = template.replace(\n        `src=\"/src/main.tsx\"`,\n        `src=\"/src/main.tsx?v=${nanoid()}\"`,\n      );\n      const page = await vite.transformIndexHtml(url, template);\n      res.status(200).set({ \"Content-Type\": \"text/html\" }).end(page);\n    } catch (e) {\n      vite.ssrFixStacktrace(e as Error);\n      next(e);\n    }\n  });\n}\n","path":null,"size_bytes":1534,"size_tokens":null},"client/src/components/ui/toast.tsx":{"content":"import * as React from \"react\"\nimport * as ToastPrimitives from \"@radix-ui/react-toast\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ToastProvider = ToastPrimitives.Provider\n\nconst ToastViewport = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Viewport>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Viewport\n    ref={ref}\n    className={cn(\n      \"fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]\",\n      className\n    )}\n    {...props}\n  />\n))\nToastViewport.displayName = ToastPrimitives.Viewport.displayName\n\nconst toastVariants = cva(\n  \"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full\",\n  {\n    variants: {\n      variant: {\n        default: \"border bg-background text-foreground\",\n        destructive:\n          \"destructive group border-destructive bg-destructive text-destructive-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst Toast = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &\n    VariantProps<typeof toastVariants>\n>(({ className, variant, ...props }, ref) => {\n  return (\n    <ToastPrimitives.Root\n      ref={ref}\n      className={cn(toastVariants({ variant }), className)}\n      {...props}\n    />\n  )\n})\nToast.displayName = ToastPrimitives.Root.displayName\n\nconst ToastAction = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Action>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Action\n    ref={ref}\n    className={cn(\n      \"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive\",\n      className\n    )}\n    {...props}\n  />\n))\nToastAction.displayName = ToastPrimitives.Action.displayName\n\nconst ToastClose = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Close>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Close\n    ref={ref}\n    className={cn(\n      \"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600\",\n      className\n    )}\n    toast-close=\"\"\n    {...props}\n  >\n    <X className=\"h-4 w-4\" />\n  </ToastPrimitives.Close>\n))\nToastClose.displayName = ToastPrimitives.Close.displayName\n\nconst ToastTitle = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Title>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Title\n    ref={ref}\n    className={cn(\"text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nToastTitle.displayName = ToastPrimitives.Title.displayName\n\nconst ToastDescription = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Description>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Description\n    ref={ref}\n    className={cn(\"text-sm opacity-90\", className)}\n    {...props}\n  />\n))\nToastDescription.displayName = ToastPrimitives.Description.displayName\n\ntype ToastProps = React.ComponentPropsWithoutRef<typeof Toast>\n\ntype ToastActionElement = React.ReactElement<typeof ToastAction>\n\nexport {\n  type ToastProps,\n  type ToastActionElement,\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastClose,\n  ToastAction,\n}\n","path":null,"size_bytes":4845,"size_tokens":null},"client/src/components/ui/popover.tsx":{"content":"import * as React from \"react\"\nimport * as PopoverPrimitive from \"@radix-ui/react-popover\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Popover = PopoverPrimitive.Root\n\nconst PopoverTrigger = PopoverPrimitive.Trigger\n\nconst PopoverAnchor = PopoverPrimitive.Anchor\n\nconst PopoverContent = React.forwardRef<\n  React.ElementRef<typeof PopoverPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\n  <PopoverPrimitive.Portal>\n    <PopoverPrimitive.Content\n      ref={ref}\n      align={align}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]\",\n        className\n      )}\n      {...props}\n    />\n  </PopoverPrimitive.Portal>\n))\nPopoverContent.displayName = PopoverPrimitive.Content.displayName\n\nexport { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }\n","path":null,"size_bytes":1342,"size_tokens":null},"client/src/components/ui/empty.tsx":{"content":"import { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Empty({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"empty\"\n      className={cn(\n        \"flex min-w-0 flex-1 flex-col items-center justify-center gap-6 text-balance rounded-lg border-dashed p-6 text-center md:p-12\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction EmptyHeader({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"empty-header\"\n      className={cn(\n        \"flex max-w-sm flex-col items-center gap-2 text-center\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nconst emptyMediaVariants = cva(\n  \"mb-2 flex shrink-0 items-center justify-center [&_svg]:pointer-events-none [&_svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-transparent\",\n        icon: \"bg-muted text-foreground flex size-10 shrink-0 items-center justify-center rounded-lg [&_svg:not([class*='size-'])]:size-6\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nfunction EmptyMedia({\n  className,\n  variant = \"default\",\n  ...props\n}: React.ComponentProps<\"div\"> & VariantProps<typeof emptyMediaVariants>) {\n  return (\n    <div\n      data-slot=\"empty-icon\"\n      data-variant={variant}\n      className={cn(emptyMediaVariants({ variant, className }))}\n      {...props}\n    />\n  )\n}\n\nfunction EmptyTitle({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"empty-title\"\n      className={cn(\"text-lg font-medium tracking-tight\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction EmptyDescription({ className, ...props }: React.ComponentProps<\"p\">) {\n  return (\n    <div\n      data-slot=\"empty-description\"\n      className={cn(\n        \"text-muted-foreground [&>a:hover]:text-primary text-sm/relaxed [&>a]:underline [&>a]:underline-offset-4\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction EmptyContent({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"empty-content\"\n      className={cn(\n        \"flex w-full min-w-0 max-w-sm flex-col items-center gap-4 text-balance text-sm\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport {\n  Empty,\n  EmptyHeader,\n  EmptyTitle,\n  EmptyDescription,\n  EmptyContent,\n  EmptyMedia,\n}\n","path":null,"size_bytes":2396,"size_tokens":null},"client/src/components/ui/button-group.tsx":{"content":"import { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Separator } from \"@/components/ui/separator\"\n\nconst buttonGroupVariants = cva(\n  \"flex w-fit items-stretch has-[>[data-slot=button-group]]:gap-2 [&>*]:focus-visible:relative [&>*]:focus-visible:z-10 has-[select[aria-hidden=true]:last-child]:[&>[data-slot=select-trigger]:last-of-type]:rounded-r-md [&>[data-slot=select-trigger]:not([class*='w-'])]:w-fit [&>input]:flex-1\",\n  {\n    variants: {\n      orientation: {\n        horizontal:\n          \"[&>*:not(:first-child)]:rounded-l-none [&>*:not(:first-child)]:border-l-0 [&>*:not(:last-child)]:rounded-r-none\",\n        vertical:\n          \"flex-col [&>*:not(:first-child)]:rounded-t-none [&>*:not(:first-child)]:border-t-0 [&>*:not(:last-child)]:rounded-b-none\",\n      },\n    },\n    defaultVariants: {\n      orientation: \"horizontal\",\n    },\n  }\n)\n\nfunction ButtonGroup({\n  className,\n  orientation,\n  ...props\n}: React.ComponentProps<\"div\"> & VariantProps<typeof buttonGroupVariants>) {\n  return (\n    <div\n      role=\"group\"\n      data-slot=\"button-group\"\n      data-orientation={orientation}\n      className={cn(buttonGroupVariants({ orientation }), className)}\n      {...props}\n    />\n  )\n}\n\nfunction ButtonGroupText({\n  className,\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"div\"> & {\n  asChild?: boolean\n}) {\n  const Comp = asChild ? Slot : \"div\"\n\n  return (\n    <Comp\n      className={cn(\n        \"bg-muted shadow-xs flex items-center gap-2 rounded-md border px-4 text-sm font-medium [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction ButtonGroupSeparator({\n  className,\n  orientation = \"vertical\",\n  ...props\n}: React.ComponentProps<typeof Separator>) {\n  return (\n    <Separator\n      data-slot=\"button-group-separator\"\n      orientation={orientation}\n      className={cn(\n        \"bg-input relative !m-0 self-stretch data-[orientation=vertical]:h-auto\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport {\n  ButtonGroup,\n  ButtonGroupSeparator,\n  ButtonGroupText,\n  buttonGroupVariants,\n}\n","path":null,"size_bytes":2209,"size_tokens":null},"client/src/components/dashboard/BotControl.tsx":{"content":"import { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Label } from \"@/components/ui/label\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { TrendingUp, RefreshCw, Zap, Target, Shield, Info, Power } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport type { BotConfig } from \"@shared/schema\";\n\nconst STRATEGIES: Record<string, { name: string; icon: typeof TrendingUp }> = {\n  momentum: { name: \"Momentum\", icon: TrendingUp },\n  mean_reversion: { name: \"ReversiÃ³n a la Media\", icon: RefreshCw },\n  scalping: { name: \"Scalping\", icon: Zap },\n  grid: { name: \"Grid Trading\", icon: Target },\n};\n\nconst RISK_LEVELS: Record<string, { name: string; color: string }> = {\n  low: { name: \"Bajo\", color: \"text-green-500 bg-green-500/10 border-green-500/30\" },\n  medium: { name: \"Medio\", color: \"text-yellow-500 bg-yellow-500/10 border-yellow-500/30\" },\n  high: { name: \"Alto\", color: \"text-red-500 bg-red-500/10 border-red-500/30\" },\n};\n\nexport function BotControl() {\n  const { data: config } = useQuery<BotConfig>({\n    queryKey: [\"botConfig\"],\n    queryFn: async () => {\n      const res = await fetch(\"/api/config\");\n      if (!res.ok) throw new Error(\"Failed to fetch config\");\n      return res.json();\n    },\n  });\n\n  const isActive = config?.isActive ?? false;\n  const strategyId = config?.strategy || \"momentum\";\n  const riskId = config?.riskLevel || \"medium\";\n  \n  const currentStrategy = STRATEGIES[strategyId] || STRATEGIES.momentum;\n  const currentRisk = RISK_LEVELS[riskId] || RISK_LEVELS.medium;\n  const StrategyIcon = currentStrategy.icon;\n\n  return (\n    <Card className=\"glass-panel border-border/50\">\n      <CardHeader className=\"pb-3 border-b border-border/50 bg-muted/10\">\n        <CardTitle className=\"text-sm font-medium font-mono flex items-center justify-between\">\n          <span>CONTROL DEL SISTEMA</span>\n          <div className=\"flex items-center gap-2\">\n            <div className={cn(\"h-2 w-2 rounded-full\", isActive ? \"bg-green-500 animate-pulse\" : \"bg-red-500\")} />\n            <span className={cn(\"text-xs\", isActive ? \"text-green-500\" : \"text-red-500\")}>\n              {isActive ? \"ACTIVO\" : \"INACTIVO\"}\n            </span>\n          </div>\n        </CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-4 pt-4\">\n        \n        <div className=\"flex items-center justify-between p-3 rounded-lg border border-border/50 bg-background/50\">\n          <div className=\"flex items-center gap-2\">\n            <Power className={cn(\"h-4 w-4\", isActive ? \"text-green-500\" : \"text-red-500\")} />\n            <span className=\"text-sm\">Estado del Bot</span>\n          </div>\n          <Badge \n            variant=\"outline\" \n            className={cn(\"font-mono border\", isActive ? \"text-green-500 bg-green-500/10 border-green-500/30\" : \"text-red-500 bg-red-500/10 border-red-500/30\")}\n          >\n            {isActive ? \"ENCENDIDO\" : \"APAGADO\"}\n          </Badge>\n        </div>\n\n        <div className=\"grid gap-3\">\n          <Label className=\"text-xs font-mono text-muted-foreground\">CONFIGURACIÃ“N ACTIVA</Label>\n          \n          <div className=\"flex items-center justify-between p-3 rounded-lg border border-border/50 bg-background/50\">\n            <div className=\"flex items-center gap-2\">\n              <StrategyIcon className=\"h-4 w-4 text-primary\" />\n              <span className=\"text-sm\">Estrategia</span>\n            </div>\n            <Badge variant=\"outline\" className=\"font-mono\">\n              {currentStrategy.name.toUpperCase()}\n            </Badge>\n          </div>\n\n          <div className=\"flex items-center justify-between p-3 rounded-lg border border-border/50 bg-background/50\">\n            <div className=\"flex items-center gap-2\">\n              <Shield className=\"h-4 w-4 text-primary\" />\n              <span className=\"text-sm\">Nivel de Riesgo</span>\n            </div>\n            <Badge variant=\"outline\" className={cn(\"font-mono border\", currentRisk.color)}>\n              {currentRisk.name.toUpperCase()}\n            </Badge>\n          </div>\n        </div>\n        \n        <div className=\"bg-muted/30 border border-border/50 p-3 rounded-md flex gap-3 items-start\">\n          <Info className=\"h-4 w-4 text-muted-foreground shrink-0 mt-0.5\" />\n          <p className=\"text-[10px] text-muted-foreground leading-tight\">\n            Panel informativo. Para cambiar la configuraciÃ³n o encender/apagar el bot, usa la pestaÃ±a <strong>Estrategias</strong>.\n          </p>\n        </div>\n      </CardContent>\n    </Card>\n  );\n}\n","path":null,"size_bytes":4588,"size_tokens":null},"client/src/components/ui/table.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Table = React.forwardRef<\n  HTMLTableElement,\n  React.HTMLAttributes<HTMLTableElement>\n>(({ className, ...props }, ref) => (\n  <div className=\"relative w-full overflow-auto\">\n    <table\n      ref={ref}\n      className={cn(\"w-full caption-bottom text-sm\", className)}\n      {...props}\n    />\n  </div>\n))\nTable.displayName = \"Table\"\n\nconst TableHeader = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <thead ref={ref} className={cn(\"[&_tr]:border-b\", className)} {...props} />\n))\nTableHeader.displayName = \"TableHeader\"\n\nconst TableBody = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tbody\n    ref={ref}\n    className={cn(\"[&_tr:last-child]:border-0\", className)}\n    {...props}\n  />\n))\nTableBody.displayName = \"TableBody\"\n\nconst TableFooter = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tfoot\n    ref={ref}\n    className={cn(\n      \"border-t bg-muted/50 font-medium [&>tr]:last:border-b-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableFooter.displayName = \"TableFooter\"\n\nconst TableRow = React.forwardRef<\n  HTMLTableRowElement,\n  React.HTMLAttributes<HTMLTableRowElement>\n>(({ className, ...props }, ref) => (\n  <tr\n    ref={ref}\n    className={cn(\n      \"border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted\",\n      className\n    )}\n    {...props}\n  />\n))\nTableRow.displayName = \"TableRow\"\n\nconst TableHead = React.forwardRef<\n  HTMLTableCellElement,\n  React.ThHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <th\n    ref={ref}\n    className={cn(\n      \"h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]\",\n      className\n    )}\n    {...props}\n  />\n))\nTableHead.displayName = \"TableHead\"\n\nconst TableCell = React.forwardRef<\n  HTMLTableCellElement,\n  React.TdHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <td\n    ref={ref}\n    className={cn(\n      \"p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]\",\n      className\n    )}\n    {...props}\n  />\n))\nTableCell.displayName = \"TableCell\"\n\nconst TableCaption = React.forwardRef<\n  HTMLTableCaptionElement,\n  React.HTMLAttributes<HTMLTableCaptionElement>\n>(({ className, ...props }, ref) => (\n  <caption\n    ref={ref}\n    className={cn(\"mt-4 text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nTableCaption.displayName = \"TableCaption\"\n\nexport {\n  Table,\n  TableHeader,\n  TableBody,\n  TableFooter,\n  TableHead,\n  TableRow,\n  TableCell,\n  TableCaption,\n}\n","path":null,"size_bytes":2859,"size_tokens":null},"client/src/components/ui/calendar.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport {\n  ChevronDownIcon,\n  ChevronLeftIcon,\n  ChevronRightIcon,\n} from \"lucide-react\"\nimport { DayButton, DayPicker, getDefaultClassNames } from \"react-day-picker\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button, buttonVariants } from \"@/components/ui/button\"\n\nfunction Calendar({\n  className,\n  classNames,\n  showOutsideDays = true,\n  captionLayout = \"label\",\n  buttonVariant = \"ghost\",\n  formatters,\n  components,\n  ...props\n}: React.ComponentProps<typeof DayPicker> & {\n  buttonVariant?: React.ComponentProps<typeof Button>[\"variant\"]\n}) {\n  const defaultClassNames = getDefaultClassNames()\n\n  return (\n    <DayPicker\n      showOutsideDays={showOutsideDays}\n      className={cn(\n        \"bg-background group/calendar p-3 [--cell-size:2rem] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent\",\n        String.raw`rtl:**:[.rdp-button\\_next>svg]:rotate-180`,\n        String.raw`rtl:**:[.rdp-button\\_previous>svg]:rotate-180`,\n        className\n      )}\n      captionLayout={captionLayout}\n      formatters={{\n        formatMonthDropdown: (date) =>\n          date.toLocaleString(\"default\", { month: \"short\" }),\n        ...formatters,\n      }}\n      classNames={{\n        root: cn(\"w-fit\", defaultClassNames.root),\n        months: cn(\n          \"relative flex flex-col gap-4 md:flex-row\",\n          defaultClassNames.months\n        ),\n        month: cn(\"flex w-full flex-col gap-4\", defaultClassNames.month),\n        nav: cn(\n          \"absolute inset-x-0 top-0 flex w-full items-center justify-between gap-1\",\n          defaultClassNames.nav\n        ),\n        button_previous: cn(\n          buttonVariants({ variant: buttonVariant }),\n          \"h-[--cell-size] w-[--cell-size] select-none p-0 aria-disabled:opacity-50\",\n          defaultClassNames.button_previous\n        ),\n        button_next: cn(\n          buttonVariants({ variant: buttonVariant }),\n          \"h-[--cell-size] w-[--cell-size] select-none p-0 aria-disabled:opacity-50\",\n          defaultClassNames.button_next\n        ),\n        month_caption: cn(\n          \"flex h-[--cell-size] w-full items-center justify-center px-[--cell-size]\",\n          defaultClassNames.month_caption\n        ),\n        dropdowns: cn(\n          \"flex h-[--cell-size] w-full items-center justify-center gap-1.5 text-sm font-medium\",\n          defaultClassNames.dropdowns\n        ),\n        dropdown_root: cn(\n          \"has-focus:border-ring border-input shadow-xs has-focus:ring-ring/50 has-focus:ring-[3px] relative rounded-md border\",\n          defaultClassNames.dropdown_root\n        ),\n        dropdown: cn(\n          \"bg-popover absolute inset-0 opacity-0\",\n          defaultClassNames.dropdown\n        ),\n        caption_label: cn(\n          \"select-none font-medium\",\n          captionLayout === \"label\"\n            ? \"text-sm\"\n            : \"[&>svg]:text-muted-foreground flex h-8 items-center gap-1 rounded-md pl-2 pr-1 text-sm [&>svg]:size-3.5\",\n          defaultClassNames.caption_label\n        ),\n        table: \"w-full border-collapse\",\n        weekdays: cn(\"flex\", defaultClassNames.weekdays),\n        weekday: cn(\n          \"text-muted-foreground flex-1 select-none rounded-md text-[0.8rem] font-normal\",\n          defaultClassNames.weekday\n        ),\n        week: cn(\"mt-2 flex w-full\", defaultClassNames.week),\n        week_number_header: cn(\n          \"w-[--cell-size] select-none\",\n          defaultClassNames.week_number_header\n        ),\n        week_number: cn(\n          \"text-muted-foreground select-none text-[0.8rem]\",\n          defaultClassNames.week_number\n        ),\n        day: cn(\n          \"group/day relative aspect-square h-full w-full select-none p-0 text-center [&:first-child[data-selected=true]_button]:rounded-l-md [&:last-child[data-selected=true]_button]:rounded-r-md\",\n          defaultClassNames.day\n        ),\n        range_start: cn(\n          \"bg-accent rounded-l-md\",\n          defaultClassNames.range_start\n        ),\n        range_middle: cn(\"rounded-none\", defaultClassNames.range_middle),\n        range_end: cn(\"bg-accent rounded-r-md\", defaultClassNames.range_end),\n        today: cn(\n          \"bg-accent text-accent-foreground rounded-md data-[selected=true]:rounded-none\",\n          defaultClassNames.today\n        ),\n        outside: cn(\n          \"text-muted-foreground aria-selected:text-muted-foreground\",\n          defaultClassNames.outside\n        ),\n        disabled: cn(\n          \"text-muted-foreground opacity-50\",\n          defaultClassNames.disabled\n        ),\n        hidden: cn(\"invisible\", defaultClassNames.hidden),\n        ...classNames,\n      }}\n      components={{\n        Root: ({ className, rootRef, ...props }) => {\n          return (\n            <div\n              data-slot=\"calendar\"\n              ref={rootRef}\n              className={cn(className)}\n              {...props}\n            />\n          )\n        },\n        Chevron: ({ className, orientation, ...props }) => {\n          if (orientation === \"left\") {\n            return (\n              <ChevronLeftIcon className={cn(\"size-4\", className)} {...props} />\n            )\n          }\n\n          if (orientation === \"right\") {\n            return (\n              <ChevronRightIcon\n                className={cn(\"size-4\", className)}\n                {...props}\n              />\n            )\n          }\n\n          return (\n            <ChevronDownIcon className={cn(\"size-4\", className)} {...props} />\n          )\n        },\n        DayButton: CalendarDayButton,\n        WeekNumber: ({ children, ...props }) => {\n          return (\n            <td {...props}>\n              <div className=\"flex size-[--cell-size] items-center justify-center text-center\">\n                {children}\n              </div>\n            </td>\n          )\n        },\n        ...components,\n      }}\n      {...props}\n    />\n  )\n}\n\nfunction CalendarDayButton({\n  className,\n  day,\n  modifiers,\n  ...props\n}: React.ComponentProps<typeof DayButton>) {\n  const defaultClassNames = getDefaultClassNames()\n\n  const ref = React.useRef<HTMLButtonElement>(null)\n  React.useEffect(() => {\n    if (modifiers.focused) ref.current?.focus()\n  }, [modifiers.focused])\n\n  return (\n    <Button\n      ref={ref}\n      variant=\"ghost\"\n      size=\"icon\"\n      data-day={day.date.toLocaleDateString()}\n      data-selected-single={\n        modifiers.selected &&\n        !modifiers.range_start &&\n        !modifiers.range_end &&\n        !modifiers.range_middle\n      }\n      data-range-start={modifiers.range_start}\n      data-range-end={modifiers.range_end}\n      data-range-middle={modifiers.range_middle}\n      className={cn(\n        \"data-[selected-single=true]:bg-primary data-[selected-single=true]:text-primary-foreground data-[range-middle=true]:bg-accent data-[range-middle=true]:text-accent-foreground data-[range-start=true]:bg-primary data-[range-start=true]:text-primary-foreground data-[range-end=true]:bg-primary data-[range-end=true]:text-primary-foreground group-data-[focused=true]/day:border-ring group-data-[focused=true]/day:ring-ring/50 flex aspect-square h-auto w-full min-w-[--cell-size] flex-col gap-1 font-normal leading-none data-[range-end=true]:rounded-md data-[range-middle=true]:rounded-none data-[range-start=true]:rounded-md group-data-[focused=true]/day:relative group-data-[focused=true]/day:z-10 group-data-[focused=true]/day:ring-[3px] [&>span]:text-xs [&>span]:opacity-70\",\n        defaultClassNames.day,\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Calendar, CalendarDayButton }\n","path":null,"size_bytes":7569,"size_tokens":null},"shared/schema.ts":{"content":"import { sql } from \"drizzle-orm\";\nimport { pgTable, text, varchar, serial, timestamp, decimal, boolean, integer, jsonb, unique } from \"drizzle-orm/pg-core\";\nimport { createInsertSchema } from \"drizzle-zod\";\nimport { z } from \"zod\";\n\nexport const botConfig = pgTable(\"bot_config\", {\n  id: serial(\"id\").primaryKey(),\n  isActive: boolean(\"is_active\").notNull().default(false),\n  strategy: text(\"strategy\").notNull().default(\"momentum\"),\n  signalTimeframe: text(\"signal_timeframe\").notNull().default(\"cycle\"),\n  riskLevel: text(\"risk_level\").notNull().default(\"medium\"),\n  activePairs: text(\"active_pairs\").array().notNull().default([\"BTC/USD\", \"ETH/USD\", \"SOL/USD\"]),\n  stopLossPercent: decimal(\"stop_loss_percent\", { precision: 5, scale: 2 }).notNull().default(\"5.00\"),\n  takeProfitPercent: decimal(\"take_profit_percent\", { precision: 5, scale: 2 }).notNull().default(\"7.00\"),\n  trailingStopEnabled: boolean(\"trailing_stop_enabled\").notNull().default(false),\n  trailingStopPercent: decimal(\"trailing_stop_percent\", { precision: 5, scale: 2 }).notNull().default(\"2.00\"),\n  nonceErrorAlertsEnabled: boolean(\"nonce_error_alerts_enabled\").notNull().default(true),\n  dailyLossLimitEnabled: boolean(\"daily_loss_limit_enabled\").notNull().default(true),\n  dailyLossLimitPercent: decimal(\"daily_loss_limit_percent\", { precision: 5, scale: 2 }).notNull().default(\"10.00\"),\n  maxPairExposurePct: decimal(\"max_pair_exposure_pct\", { precision: 5, scale: 2 }).notNull().default(\"25.00\"),\n  maxTotalExposurePct: decimal(\"max_total_exposure_pct\", { precision: 5, scale: 2 }).notNull().default(\"60.00\"),\n  exposureBase: text(\"exposure_base\").notNull().default(\"cash\"),\n  riskPerTradePct: decimal(\"risk_per_trade_pct\", { precision: 5, scale: 2 }).notNull().default(\"15.00\"),\n  tradingHoursEnabled: boolean(\"trading_hours_enabled\").notNull().default(true),\n  tradingHoursStart: decimal(\"trading_hours_start\", { precision: 2, scale: 0 }).notNull().default(\"8\"),\n  tradingHoursEnd: decimal(\"trading_hours_end\", { precision: 2, scale: 0 }).notNull().default(\"22\"),\n  positionMode: text(\"position_mode\").notNull().default(\"SINGLE\"),\n  // SMART_GUARD configuration\n  sgMinEntryUsd: decimal(\"sg_min_entry_usd\", { precision: 10, scale: 2 }).notNull().default(\"100.00\"),\n  sgAllowUnderMin: boolean(\"sg_allow_under_min\").notNull().default(true),\n  sgBeAtPct: decimal(\"sg_be_at_pct\", { precision: 5, scale: 2 }).notNull().default(\"1.50\"),\n  sgFeeCushionPct: decimal(\"sg_fee_cushion_pct\", { precision: 5, scale: 2 }).notNull().default(\"0.45\"),\n  sgFeeCushionAuto: boolean(\"sg_fee_cushion_auto\").notNull().default(true),\n  sgTrailStartPct: decimal(\"sg_trail_start_pct\", { precision: 5, scale: 2 }).notNull().default(\"2.00\"),\n  sgTrailDistancePct: decimal(\"sg_trail_distance_pct\", { precision: 5, scale: 2 }).notNull().default(\"1.50\"),\n  sgTrailStepPct: decimal(\"sg_trail_step_pct\", { precision: 5, scale: 2 }).notNull().default(\"0.25\"),\n  sgTpFixedEnabled: boolean(\"sg_tp_fixed_enabled\").notNull().default(false),\n  sgTpFixedPct: decimal(\"sg_tp_fixed_pct\", { precision: 5, scale: 2 }).notNull().default(\"10.00\"),\n  sgScaleOutEnabled: boolean(\"sg_scale_out_enabled\").notNull().default(false),\n  sgScaleOutPct: decimal(\"sg_scale_out_pct\", { precision: 5, scale: 2 }).notNull().default(\"35.00\"),\n  sgMinPartUsd: decimal(\"sg_min_part_usd\", { precision: 10, scale: 2 }).notNull().default(\"50.00\"),\n  sgScaleOutThreshold: decimal(\"sg_scale_out_threshold\", { precision: 5, scale: 2 }).notNull().default(\"80.00\"),\n  sgMaxOpenLotsPerPair: integer(\"sg_max_open_lots_per_pair\").notNull().default(1),\n  // SMART_GUARD pair overrides (JSON: { \"BTC/USD\": { trailDistancePct: 1.0 }, ... })\n  sgPairOverrides: jsonb(\"sg_pair_overrides\"),\n  // DRY_RUN mode: audit/verify without sending real orders to exchange\n  dryRunMode: boolean(\"dry_run_mode\").notNull().default(false),\n  updatedAt: timestamp(\"updated_at\").notNull().defaultNow(),\n});\n\nexport const apiConfig = pgTable(\"api_config\", {\n  id: serial(\"id\").primaryKey(),\n  krakenApiKey: text(\"kraken_api_key\"),\n  krakenApiSecret: text(\"kraken_api_secret\"),\n  krakenConnected: boolean(\"kraken_connected\").notNull().default(false),\n  telegramToken: text(\"telegram_token\"),\n  telegramChatId: text(\"telegram_chat_id\"),\n  telegramConnected: boolean(\"telegram_connected\").notNull().default(false),\n  updatedAt: timestamp(\"updated_at\").notNull().defaultNow(),\n});\n\nexport const trades = pgTable(\"trades\", {\n  id: serial(\"id\").primaryKey(),\n  tradeId: text(\"trade_id\").notNull().unique(),\n  pair: text(\"pair\").notNull(),\n  type: text(\"type\").notNull(),\n  price: decimal(\"price\", { precision: 18, scale: 8 }).notNull(),\n  amount: decimal(\"amount\", { precision: 18, scale: 8 }).notNull(),\n  status: text(\"status\").notNull().default(\"pending\"),\n  krakenOrderId: text(\"kraken_order_id\").unique(), // UNIQUE para evitar duplicados en sync\n  entryPrice: decimal(\"entry_price\", { precision: 18, scale: 8 }),\n  realizedPnlUsd: decimal(\"realized_pnl_usd\", { precision: 18, scale: 8 }),\n  realizedPnlPct: decimal(\"realized_pnl_pct\", { precision: 10, scale: 4 }),\n  executedAt: timestamp(\"executed_at\"),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n});\n\nexport const notifications = pgTable(\"notifications\", {\n  id: serial(\"id\").primaryKey(),\n  type: text(\"type\").notNull(),\n  message: text(\"message\").notNull(),\n  telegramSent: boolean(\"telegram_sent\").notNull().default(false),\n  sentAt: timestamp(\"sent_at\"),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n});\n\nexport const marketData = pgTable(\"market_data\", {\n  id: serial(\"id\").primaryKey(),\n  pair: text(\"pair\").notNull(),\n  price: decimal(\"price\", { precision: 18, scale: 8 }).notNull(),\n  volume24h: decimal(\"volume_24h\", { precision: 18, scale: 2 }),\n  change24h: decimal(\"change_24h\", { precision: 10, scale: 2 }),\n  timestamp: timestamp(\"timestamp\").notNull().defaultNow(),\n});\n\nexport const telegramChats = pgTable(\"telegram_chats\", {\n  id: serial(\"id\").primaryKey(),\n  name: text(\"name\").notNull(),\n  chatId: text(\"chat_id\").notNull(),\n  alertTrades: boolean(\"alert_trades\").notNull().default(true),\n  alertErrors: boolean(\"alert_errors\").notNull().default(true),\n  alertSystem: boolean(\"alert_system\").notNull().default(true),\n  alertBalance: boolean(\"alert_balance\").notNull().default(false),\n  alertHeartbeat: boolean(\"alert_heartbeat\").notNull().default(true),\n  isActive: boolean(\"is_active\").notNull().default(true),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n});\n\nexport const botEvents = pgTable(\"bot_events\", {\n  id: serial(\"id\").primaryKey(),\n  timestamp: timestamp(\"timestamp\").notNull().defaultNow(),\n  level: text(\"level\").notNull(),\n  type: text(\"type\").notNull(),\n  message: text(\"message\").notNull(),\n  meta: text(\"meta\"),\n});\n\nexport const openPositions = pgTable(\"open_positions\", {\n  id: serial(\"id\").primaryKey(),\n  lotId: text(\"lot_id\").notNull().unique(), // Unique identifier for each lot (multi-lot support)\n  pair: text(\"pair\").notNull(), // Removed unique constraint for multi-lot support\n  entryPrice: decimal(\"entry_price\", { precision: 18, scale: 8 }).notNull(),\n  amount: decimal(\"amount\", { precision: 18, scale: 8 }).notNull(),\n  qtyRemaining: decimal(\"qty_remaining\", { precision: 18, scale: 8 }), // Cantidad pendiente de vender (null = amount)\n  qtyFilled: decimal(\"qty_filled\", { precision: 18, scale: 8 }).default(\"0\"), // Cantidad ya vendida\n  highestPrice: decimal(\"highest_price\", { precision: 18, scale: 8 }).notNull(),\n  tradeId: text(\"trade_id\"),\n  krakenOrderId: text(\"kraken_order_id\"),\n  entryStrategyId: text(\"entry_strategy_id\").notNull().default(\"momentum_cycle\"),\n  entrySignalTf: text(\"entry_signal_tf\").notNull().default(\"cycle\"),\n  signalConfidence: decimal(\"signal_confidence\", { precision: 5, scale: 2 }),\n  signalReason: text(\"signal_reason\"),\n  entryMode: text(\"entry_mode\"),\n  configSnapshotJson: jsonb(\"config_snapshot_json\"),\n  // SMART_GUARD dynamic state\n  sgBreakEvenActivated: boolean(\"sg_break_even_activated\").default(false),\n  sgCurrentStopPrice: decimal(\"sg_current_stop_price\", { precision: 18, scale: 8 }),\n  sgTrailingActivated: boolean(\"sg_trailing_activated\").default(false),\n  sgScaleOutDone: boolean(\"sg_scale_out_done\").default(false),\n  openedAt: timestamp(\"opened_at\").notNull().defaultNow(),\n  updatedAt: timestamp(\"updated_at\").notNull().defaultNow(),\n});\n\n// Trade fills from Kraken (granular level for partial fills)\nexport const tradeFills = pgTable(\"trade_fills\", {\n  id: serial(\"id\").primaryKey(),\n  txid: text(\"txid\").notNull().unique(), // Kraken fill txid (UNIQUE para evitar duplicados)\n  orderId: text(\"order_id\").notNull(), // Kraken ordertxid (puede tener mÃºltiples fills)\n  pair: text(\"pair\").notNull(),\n  type: text(\"type\").notNull(), // buy/sell\n  price: decimal(\"price\", { precision: 18, scale: 8 }).notNull(),\n  amount: decimal(\"amount\", { precision: 18, scale: 8 }).notNull(),\n  cost: decimal(\"cost\", { precision: 18, scale: 8 }).notNull(),\n  fee: decimal(\"fee\", { precision: 18, scale: 8 }).notNull(),\n  matched: boolean(\"matched\").notNull().default(false), // Flag para evitar re-procesar\n  executedAt: timestamp(\"executed_at\").notNull(),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n});\n\n// Lot matches for FIFO matching (audit trail)\nexport const lotMatches = pgTable(\"lot_matches\", {\n  id: serial(\"id\").primaryKey(),\n  sellFillTxid: text(\"sell_fill_txid\").notNull(), // Fill txid del SELL\n  lotId: text(\"lot_id\").notNull(), // ID del lot (open_position)\n  matchedQty: decimal(\"matched_qty\", { precision: 18, scale: 8 }).notNull(),\n  buyPrice: decimal(\"buy_price\", { precision: 18, scale: 8 }).notNull(),\n  sellPrice: decimal(\"sell_price\", { precision: 18, scale: 8 }).notNull(),\n  buyFeeAllocated: decimal(\"buy_fee_allocated\", { precision: 18, scale: 8 }).notNull(),\n  sellFeeAllocated: decimal(\"sell_fee_allocated\", { precision: 18, scale: 8 }).notNull(),\n  pnlNet: decimal(\"pnl_net\", { precision: 18, scale: 8 }).notNull(),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n}, (table) => ({\n  sellLotUnique: unique().on(table.sellFillTxid, table.lotId), // UNIQUE(sellFillTxid, lotId) para idempotencia\n}));\n\nexport const aiTradeSamples = pgTable(\"ai_trade_samples\", {\n  id: serial(\"id\").primaryKey(),\n  tradeId: text(\"trade_id\").unique().notNull(),\n  pair: text(\"pair\").notNull(),\n  side: text(\"side\").notNull(),\n  entryTs: timestamp(\"entry_ts\").notNull(),\n  exitTs: timestamp(\"exit_ts\"),\n  entryPrice: decimal(\"entry_price\", { precision: 18, scale: 8 }).notNull(),\n  exitPrice: decimal(\"exit_price\", { precision: 18, scale: 8 }),\n  feesTotal: decimal(\"fees_total\", { precision: 18, scale: 8 }),\n  pnlGross: decimal(\"pnl_gross\", { precision: 18, scale: 8 }),\n  pnlNet: decimal(\"pnl_net\", { precision: 18, scale: 8 }),\n  labelWin: integer(\"label_win\"),\n  featuresJson: jsonb(\"features_json\").notNull(),\n  isComplete: boolean(\"is_complete\").default(false),\n  createdAt: timestamp(\"created_at\").defaultNow(),\n});\n\nexport const aiShadowDecisions = pgTable(\"ai_shadow_decisions\", {\n  id: serial(\"id\").primaryKey(),\n  tradeId: text(\"trade_id\").notNull(),\n  ts: timestamp(\"ts\").defaultNow(),\n  score: decimal(\"score\", { precision: 5, scale: 4 }).notNull(),\n  threshold: decimal(\"threshold\", { precision: 5, scale: 4 }).notNull(),\n  wouldBlock: boolean(\"would_block\").notNull(),\n  finalPnlNet: decimal(\"final_pnl_net\", { precision: 18, scale: 8 }),\n});\n\nexport const trainingTrades = pgTable(\"training_trades\", {\n  id: serial(\"id\").primaryKey(),\n  pair: text(\"pair\").notNull(),\n  strategyId: text(\"strategy_id\"),\n  buyTxid: text(\"buy_txid\").notNull().unique(), // UNIQUE para evitar duplicados en backfill\n  sellTxid: text(\"sell_txid\"),\n  sellTxidsJson: jsonb(\"sell_txids_json\"),\n  entryPrice: decimal(\"entry_price\", { precision: 18, scale: 8 }).notNull(),\n  exitPrice: decimal(\"exit_price\", { precision: 18, scale: 8 }),\n  entryAmount: decimal(\"entry_amount\", { precision: 18, scale: 8 }).notNull(),\n  exitAmount: decimal(\"exit_amount\", { precision: 18, scale: 8 }),\n  qtyRemaining: decimal(\"qty_remaining\", { precision: 18, scale: 8 }),\n  entryFee: decimal(\"entry_fee\", { precision: 18, scale: 8 }).notNull().default(\"0\"),\n  exitFee: decimal(\"exit_fee\", { precision: 18, scale: 8 }),\n  costUsd: decimal(\"cost_usd\", { precision: 18, scale: 8 }).notNull(),\n  revenueUsd: decimal(\"revenue_usd\", { precision: 18, scale: 8 }),\n  pnlGross: decimal(\"pnl_gross\", { precision: 18, scale: 8 }),\n  pnlNet: decimal(\"pnl_net\", { precision: 18, scale: 8 }),\n  pnlPct: decimal(\"pnl_pct\", { precision: 10, scale: 4 }),\n  holdTimeMinutes: integer(\"hold_time_minutes\"),\n  labelWin: integer(\"label_win\"),\n  featuresJson: jsonb(\"features_json\"),\n  discardReason: text(\"discard_reason\"),\n  isClosed: boolean(\"is_closed\").notNull().default(false),\n  isLabeled: boolean(\"is_labeled\").notNull().default(false),\n  entryTs: timestamp(\"entry_ts\").notNull(),\n  exitTs: timestamp(\"exit_ts\"),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n});\n\nexport const aiConfig = pgTable(\"ai_config\", {\n  id: serial(\"id\").primaryKey(),\n  filterEnabled: boolean(\"filter_enabled\").default(false),\n  shadowEnabled: boolean(\"shadow_enabled\").default(false),\n  modelPath: text(\"model_path\"),\n  modelVersion: text(\"model_version\"),\n  lastTrainTs: timestamp(\"last_train_ts\"),\n  lastBackfillTs: timestamp(\"last_backfill_ts\"),\n  lastBackfillError: text(\"last_backfill_error\"),\n  lastBackfillDiscardReasonsJson: jsonb(\"last_backfill_discard_reasons_json\"),\n  lastTrainError: text(\"last_train_error\"),\n  nSamples: integer(\"n_samples\").default(0),\n  threshold: decimal(\"threshold\", { precision: 5, scale: 4 }).default(\"0.60\"),\n  metricsJson: jsonb(\"metrics_json\"),\n  updatedAt: timestamp(\"updated_at\").defaultNow(),\n});\n\nexport const insertBotConfigSchema = createInsertSchema(botConfig).omit({ id: true, updatedAt: true });\nexport const insertTradeSchema = createInsertSchema(trades).omit({ id: true, createdAt: true });\nexport const insertNotificationSchema = createInsertSchema(notifications).omit({ id: true, createdAt: true });\nexport const insertMarketDataSchema = createInsertSchema(marketData).omit({ id: true, timestamp: true });\nexport const insertApiConfigSchema = createInsertSchema(apiConfig).omit({ id: true, updatedAt: true });\nexport const insertTelegramChatSchema = createInsertSchema(telegramChats).omit({ id: true, createdAt: true });\nexport const insertBotEventSchema = createInsertSchema(botEvents).omit({ id: true, timestamp: true });\nexport const insertOpenPositionSchema = createInsertSchema(openPositions).omit({ id: true, openedAt: true, updatedAt: true });\nexport const insertAiTradeSampleSchema = createInsertSchema(aiTradeSamples).omit({ id: true, createdAt: true });\nexport const insertAiShadowDecisionSchema = createInsertSchema(aiShadowDecisions).omit({ id: true, ts: true });\nexport const insertAiConfigSchema = createInsertSchema(aiConfig).omit({ id: true, updatedAt: true });\nexport const insertTrainingTradeSchema = createInsertSchema(trainingTrades).omit({ id: true, createdAt: true });\nexport const insertTradeFillSchema = createInsertSchema(tradeFills).omit({ id: true, createdAt: true });\nexport const insertLotMatchSchema = createInsertSchema(lotMatches).omit({ id: true, createdAt: true });\n\nexport type BotConfig = typeof botConfig.$inferSelect;\nexport type Trade = typeof trades.$inferSelect;\nexport type Notification = typeof notifications.$inferSelect;\nexport type MarketData = typeof marketData.$inferSelect;\nexport type ApiConfig = typeof apiConfig.$inferSelect;\nexport type TelegramChat = typeof telegramChats.$inferSelect;\nexport type BotEvent = typeof botEvents.$inferSelect;\nexport type OpenPosition = typeof openPositions.$inferSelect;\nexport type TradeFill = typeof tradeFills.$inferSelect;\nexport type LotMatch = typeof lotMatches.$inferSelect;\nexport type AiTradeSample = typeof aiTradeSamples.$inferSelect;\nexport type AiShadowDecision = typeof aiShadowDecisions.$inferSelect;\nexport type AiConfig = typeof aiConfig.$inferSelect;\nexport type TrainingTrade = typeof trainingTrades.$inferSelect;\n\nexport type InsertBotConfig = z.infer<typeof insertBotConfigSchema>;\nexport type InsertTrade = z.infer<typeof insertTradeSchema>;\nexport type InsertNotification = z.infer<typeof insertNotificationSchema>;\nexport type InsertMarketData = z.infer<typeof insertMarketDataSchema>;\nexport type InsertApiConfig = z.infer<typeof insertApiConfigSchema>;\nexport type InsertTelegramChat = z.infer<typeof insertTelegramChatSchema>;\nexport type InsertBotEvent = z.infer<typeof insertBotEventSchema>;\nexport type InsertOpenPosition = z.infer<typeof insertOpenPositionSchema>;\nexport type InsertTradeFill = z.infer<typeof insertTradeFillSchema>;\nexport type InsertLotMatch = z.infer<typeof insertLotMatchSchema>;\nexport type InsertAiTradeSample = z.infer<typeof insertAiTradeSampleSchema>;\nexport type InsertAiShadowDecision = z.infer<typeof insertAiShadowDecisionSchema>;\nexport type InsertAiConfig = z.infer<typeof insertAiConfigSchema>;\nexport type InsertTrainingTrade = z.infer<typeof insertTrainingTradeSchema>;\n","path":null,"size_bytes":17039,"size_tokens":null},"client/src/components/ui/separator.tsx":{"content":"import * as React from \"react\"\nimport * as SeparatorPrimitive from \"@radix-ui/react-separator\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Separator = React.forwardRef<\n  React.ElementRef<typeof SeparatorPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>\n>(\n  (\n    { className, orientation = \"horizontal\", decorative = true, ...props },\n    ref\n  ) => (\n    <SeparatorPrimitive.Root\n      ref={ref}\n      decorative={decorative}\n      orientation={orientation}\n      className={cn(\n        \"shrink-0 bg-border\",\n        orientation === \"horizontal\" ? \"h-[1px] w-full\" : \"h-full w-[1px]\",\n        className\n      )}\n      {...props}\n    />\n  )\n)\nSeparator.displayName = SeparatorPrimitive.Root.displayName\n\nexport { Separator }\n","path":null,"size_bytes":756,"size_tokens":null},"server/static.ts":{"content":"import express, { type Express } from \"express\";\nimport fs from \"fs\";\nimport path from \"path\";\n\nexport function serveStatic(app: Express) {\n  const distPath = path.resolve(__dirname, \"public\");\n  if (!fs.existsSync(distPath)) {\n    throw new Error(\n      `Could not find the build directory: ${distPath}, make sure to build the client first`,\n    );\n  }\n\n  app.use(express.static(distPath));\n\n  // fall through to index.html if the file doesn't exist\n  app.use(\"*\", (_req, res) => {\n    res.sendFile(path.resolve(distPath, \"index.html\"));\n  });\n}\n","path":null,"size_bytes":547,"size_tokens":null},"client/src/components/ui/slider.tsx":{"content":"import * as React from \"react\"\nimport * as SliderPrimitive from \"@radix-ui/react-slider\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Slider = React.forwardRef<\n  React.ElementRef<typeof SliderPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <SliderPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative flex w-full touch-none select-none items-center\",\n      className\n    )}\n    {...props}\n  >\n    <SliderPrimitive.Track className=\"relative h-1.5 w-full grow overflow-hidden rounded-full bg-primary/20\">\n      <SliderPrimitive.Range className=\"absolute h-full bg-primary\" />\n    </SliderPrimitive.Track>\n    <SliderPrimitive.Thumb className=\"block h-4 w-4 rounded-full border border-primary/50 bg-background shadow transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50\" />\n  </SliderPrimitive.Root>\n))\nSlider.displayName = SliderPrimitive.Root.displayName\n\nexport { Slider }\n","path":null,"size_bytes":1037,"size_tokens":null},"client/src/components/ui/input.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Input = React.forwardRef<HTMLInputElement, React.ComponentProps<\"input\">>(\n  ({ className, type, ...props }, ref) => {\n    return (\n      <input\n        type={type}\n        className={cn(\n          \"flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nInput.displayName = \"Input\"\n\nexport { Input }\n","path":null,"size_bytes":768,"size_tokens":null},"client/src/components/ui/tabs.tsx":{"content":"import * as React from \"react\"\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Tabs = TabsPrimitive.Root\n\nconst TabsList = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.List\n    ref={ref}\n    className={cn(\n      \"inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsList.displayName = TabsPrimitive.List.displayName\n\nconst TabsTrigger = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsTrigger.displayName = TabsPrimitive.Trigger.displayName\n\nconst TabsContent = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.Content\n    ref={ref}\n    className={cn(\n      \"mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsContent.displayName = TabsPrimitive.Content.displayName\n\nexport { Tabs, TabsList, TabsTrigger, TabsContent }\n","path":null,"size_bytes":1877,"size_tokens":null},"vite-plugin-meta-images.ts":{"content":"import type { Plugin } from 'vite';\nimport fs from 'fs';\nimport path from 'path';\n\n/**\n * Vite plugin that updates og:image and twitter:image meta tags\n * to point to the app's opengraph image with the correct Replit domain.\n */\nexport function metaImagesPlugin(): Plugin {\n  return {\n    name: 'vite-plugin-meta-images',\n    transformIndexHtml(html) {\n      const baseUrl = getDeploymentUrl();\n      if (!baseUrl) {\n        log('[meta-images] no Replit deployment domain found, skipping meta tag updates');\n        return html;\n      }\n\n      // Check if opengraph image exists in public directory\n      const publicDir = path.resolve(process.cwd(), 'client', 'public');\n      const opengraphPngPath = path.join(publicDir, 'opengraph.png');\n      const opengraphJpgPath = path.join(publicDir, 'opengraph.jpg');\n      const opengraphJpegPath = path.join(publicDir, 'opengraph.jpeg');\n\n      let imageExt: string | null = null;\n      if (fs.existsSync(opengraphPngPath)) {\n        imageExt = 'png';\n      } else if (fs.existsSync(opengraphJpgPath)) {\n        imageExt = 'jpg';\n      } else if (fs.existsSync(opengraphJpegPath)) {\n        imageExt = 'jpeg';\n      }\n\n      if (!imageExt) {\n        log('[meta-images] OpenGraph image not found, skipping meta tag updates');\n        return html;\n      }\n\n      const imageUrl = `${baseUrl}/opengraph.${imageExt}`;\n\n      log('[meta-images] updating meta image tags to:', imageUrl);\n\n      html = html.replace(\n        /<meta\\s+property=\"og:image\"\\s+content=\"[^\"]*\"\\s*\\/>/g,\n        `<meta property=\"og:image\" content=\"${imageUrl}\" />`\n      );\n\n      html = html.replace(\n        /<meta\\s+name=\"twitter:image\"\\s+content=\"[^\"]*\"\\s*\\/>/g,\n        `<meta name=\"twitter:image\" content=\"${imageUrl}\" />`\n      );\n\n      return html;\n    },\n  };\n}\n\nfunction getDeploymentUrl(): string | null {\n  if (process.env.REPLIT_INTERNAL_APP_DOMAIN) {\n    const url = `https://${process.env.REPLIT_INTERNAL_APP_DOMAIN}`;\n    log('[meta-images] using internal app domain:', url);\n    return url;\n  }\n\n  if (process.env.REPLIT_DEV_DOMAIN) {\n    const url = `https://${process.env.REPLIT_DEV_DOMAIN}`;\n    log('[meta-images] using dev domain:', url);\n    return url;\n  }\n\n  return null;\n}\n\nfunction log(...args: any[]): void {\n  if (process.env.NODE_ENV === 'production') {\n    console.log(...args);\n  }\n}\n","path":null,"size_bytes":2333,"size_tokens":null},"client/src/hooks/use-toast.ts":{"content":"import * as React from \"react\"\n\nimport type {\n  ToastActionElement,\n  ToastProps,\n} from \"@/components/ui/toast\"\n\nconst TOAST_LIMIT = 1\nconst TOAST_REMOVE_DELAY = 1000000\n\ntype ToasterToast = ToastProps & {\n  id: string\n  title?: React.ReactNode\n  description?: React.ReactNode\n  action?: ToastActionElement\n}\n\nconst actionTypes = {\n  ADD_TOAST: \"ADD_TOAST\",\n  UPDATE_TOAST: \"UPDATE_TOAST\",\n  DISMISS_TOAST: \"DISMISS_TOAST\",\n  REMOVE_TOAST: \"REMOVE_TOAST\",\n} as const\n\nlet count = 0\n\nfunction genId() {\n  count = (count + 1) % Number.MAX_SAFE_INTEGER\n  return count.toString()\n}\n\ntype ActionType = typeof actionTypes\n\ntype Action =\n  | {\n      type: ActionType[\"ADD_TOAST\"]\n      toast: ToasterToast\n    }\n  | {\n      type: ActionType[\"UPDATE_TOAST\"]\n      toast: Partial<ToasterToast>\n    }\n  | {\n      type: ActionType[\"DISMISS_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n  | {\n      type: ActionType[\"REMOVE_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n\ninterface State {\n  toasts: ToasterToast[]\n}\n\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\n\nconst addToRemoveQueue = (toastId: string) => {\n  if (toastTimeouts.has(toastId)) {\n    return\n  }\n\n  const timeout = setTimeout(() => {\n    toastTimeouts.delete(toastId)\n    dispatch({\n      type: \"REMOVE_TOAST\",\n      toastId: toastId,\n    })\n  }, TOAST_REMOVE_DELAY)\n\n  toastTimeouts.set(toastId, timeout)\n}\n\nexport const reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case \"ADD_TOAST\":\n      return {\n        ...state,\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\n      }\n\n    case \"UPDATE_TOAST\":\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\n        ),\n      }\n\n    case \"DISMISS_TOAST\": {\n      const { toastId } = action\n\n      // ! Side effects ! - This could be extracted into a dismissToast() action,\n      // but I'll keep it here for simplicity\n      if (toastId) {\n        addToRemoveQueue(toastId)\n      } else {\n        state.toasts.forEach((toast) => {\n          addToRemoveQueue(toast.id)\n        })\n      }\n\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === toastId || toastId === undefined\n            ? {\n                ...t,\n                open: false,\n              }\n            : t\n        ),\n      }\n    }\n    case \"REMOVE_TOAST\":\n      if (action.toastId === undefined) {\n        return {\n          ...state,\n          toasts: [],\n        }\n      }\n      return {\n        ...state,\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\n      }\n  }\n}\n\nconst listeners: Array<(state: State) => void> = []\n\nlet memoryState: State = { toasts: [] }\n\nfunction dispatch(action: Action) {\n  memoryState = reducer(memoryState, action)\n  listeners.forEach((listener) => {\n    listener(memoryState)\n  })\n}\n\ntype Toast = Omit<ToasterToast, \"id\">\n\nfunction toast({ ...props }: Toast) {\n  const id = genId()\n\n  const update = (props: ToasterToast) =>\n    dispatch({\n      type: \"UPDATE_TOAST\",\n      toast: { ...props, id },\n    })\n  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\n\n  dispatch({\n    type: \"ADD_TOAST\",\n    toast: {\n      ...props,\n      id,\n      open: true,\n      onOpenChange: (open) => {\n        if (!open) dismiss()\n      },\n    },\n  })\n\n  return {\n    id: id,\n    dismiss,\n    update,\n  }\n}\n\nfunction useToast() {\n  const [state, setState] = React.useState<State>(memoryState)\n\n  React.useEffect(() => {\n    listeners.push(setState)\n    return () => {\n      const index = listeners.indexOf(setState)\n      if (index > -1) {\n        listeners.splice(index, 1)\n      }\n    }\n  }, [state])\n\n  return {\n    ...state,\n    toast,\n    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\n  }\n}\n\nexport { useToast, toast }\n","path":null,"size_bytes":3895,"size_tokens":null},"client/src/components/ui/command.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport { type DialogProps } from \"@radix-ui/react-dialog\"\nimport { Command as CommandPrimitive } from \"cmdk\"\nimport { Search } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Dialog, DialogContent } from \"@/components/ui/dialog\"\n\nconst Command = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive\n    ref={ref}\n    className={cn(\n      \"flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nCommand.displayName = CommandPrimitive.displayName\n\nconst CommandDialog = ({ children, ...props }: DialogProps) => {\n  return (\n    <Dialog {...props}>\n      <DialogContent className=\"overflow-hidden p-0\">\n        <Command className=\"[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5\">\n          {children}\n        </Command>\n      </DialogContent>\n    </Dialog>\n  )\n}\n\nconst CommandInput = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Input>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>\n>(({ className, ...props }, ref) => (\n  <div className=\"flex items-center border-b px-3\" cmdk-input-wrapper=\"\">\n    <Search className=\"mr-2 h-4 w-4 shrink-0 opacity-50\" />\n    <CommandPrimitive.Input\n      ref={ref}\n      className={cn(\n        \"flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  </div>\n))\n\nCommandInput.displayName = CommandPrimitive.Input.displayName\n\nconst CommandList = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.List\n    ref={ref}\n    className={cn(\"max-h-[300px] overflow-y-auto overflow-x-hidden\", className)}\n    {...props}\n  />\n))\n\nCommandList.displayName = CommandPrimitive.List.displayName\n\nconst CommandEmpty = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Empty>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>\n>((props, ref) => (\n  <CommandPrimitive.Empty\n    ref={ref}\n    className=\"py-6 text-center text-sm\"\n    {...props}\n  />\n))\n\nCommandEmpty.displayName = CommandPrimitive.Empty.displayName\n\nconst CommandGroup = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Group>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Group\n    ref={ref}\n    className={cn(\n      \"overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandGroup.displayName = CommandPrimitive.Group.displayName\n\nconst CommandSeparator = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 h-px bg-border\", className)}\n    {...props}\n  />\n))\nCommandSeparator.displayName = CommandPrimitive.Separator.displayName\n\nconst CommandItem = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandItem.displayName = CommandPrimitive.Item.displayName\n\nconst CommandShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nCommandShortcut.displayName = \"CommandShortcut\"\n\nexport {\n  Command,\n  CommandDialog,\n  CommandInput,\n  CommandList,\n  CommandEmpty,\n  CommandGroup,\n  CommandItem,\n  CommandShortcut,\n  CommandSeparator,\n}\n","path":null,"size_bytes":4887,"size_tokens":null},"client/src/components/ui/scroll-area.tsx":{"content":"import * as React from \"react\"\nimport * as ScrollAreaPrimitive from \"@radix-ui/react-scroll-area\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ScrollArea = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>\n>(({ className, children, ...props }, ref) => (\n  <ScrollAreaPrimitive.Root\n    ref={ref}\n    className={cn(\"relative overflow-hidden\", className)}\n    {...props}\n  >\n    <ScrollAreaPrimitive.Viewport className=\"h-full w-full rounded-[inherit]\">\n      {children}\n    </ScrollAreaPrimitive.Viewport>\n    <ScrollBar />\n    <ScrollAreaPrimitive.Corner />\n  </ScrollAreaPrimitive.Root>\n))\nScrollArea.displayName = ScrollAreaPrimitive.Root.displayName\n\nconst ScrollBar = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>\n>(({ className, orientation = \"vertical\", ...props }, ref) => (\n  <ScrollAreaPrimitive.ScrollAreaScrollbar\n    ref={ref}\n    orientation={orientation}\n    className={cn(\n      \"flex touch-none select-none transition-colors\",\n      orientation === \"vertical\" &&\n        \"h-full w-2.5 border-l border-l-transparent p-[1px]\",\n      orientation === \"horizontal\" &&\n        \"h-2.5 flex-col border-t border-t-transparent p-[1px]\",\n      className\n    )}\n    {...props}\n  >\n    <ScrollAreaPrimitive.ScrollAreaThumb className=\"relative flex-1 rounded-full bg-border\" />\n  </ScrollAreaPrimitive.ScrollAreaScrollbar>\n))\nScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName\n\nexport { ScrollArea, ScrollBar }\n","path":null,"size_bytes":1642,"size_tokens":null},"client/src/components/ui/checkbox.tsx":{"content":"import * as React from \"react\"\nimport * as CheckboxPrimitive from \"@radix-ui/react-checkbox\"\nimport { Check } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Checkbox = React.forwardRef<\n  React.ElementRef<typeof CheckboxPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <CheckboxPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"grid place-content-center peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\",\n      className\n    )}\n    {...props}\n  >\n    <CheckboxPrimitive.Indicator\n      className={cn(\"grid place-content-center text-current\")}\n    >\n      <Check className=\"h-4 w-4\" />\n    </CheckboxPrimitive.Indicator>\n  </CheckboxPrimitive.Root>\n))\nCheckbox.displayName = CheckboxPrimitive.Root.displayName\n\nexport { Checkbox }\n","path":null,"size_bytes":1031,"size_tokens":null},"client/src/components/ui/dialog.tsx":{"content":"import * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Dialog = DialogPrimitive.Root\n\nconst DialogTrigger = DialogPrimitive.Trigger\n\nconst DialogPortal = DialogPrimitive.Portal\n\nconst DialogClose = DialogPrimitive.Close\n\nconst DialogOverlay = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Overlay\n    ref={ref}\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogOverlay.displayName = DialogPrimitive.Overlay.displayName\n\nconst DialogContent = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DialogPortal>\n    <DialogOverlay />\n    <DialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <DialogPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </DialogPrimitive.Close>\n    </DialogPrimitive.Content>\n  </DialogPortal>\n))\nDialogContent.displayName = DialogPrimitive.Content.displayName\n\nconst DialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-1.5 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogHeader.displayName = \"DialogHeader\"\n\nconst DialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogFooter.displayName = \"DialogFooter\"\n\nconst DialogTitle = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogTitle.displayName = DialogPrimitive.Title.displayName\n\nconst DialogDescription = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDialogDescription.displayName = DialogPrimitive.Description.displayName\n\nexport {\n  Dialog,\n  DialogPortal,\n  DialogOverlay,\n  DialogTrigger,\n  DialogClose,\n  DialogContent,\n  DialogHeader,\n  DialogFooter,\n  DialogTitle,\n  DialogDescription,\n}\n","path":null,"size_bytes":3835,"size_tokens":null},"client/src/components/ui/toggle.tsx":{"content":"import * as React from \"react\"\nimport * as TogglePrimitive from \"@radix-ui/react-toggle\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst toggleVariants = cva(\n  \"inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-transparent\",\n        outline:\n          \"border border-input bg-transparent shadow-sm hover:bg-accent hover:text-accent-foreground\",\n      },\n      size: {\n        default: \"h-9 px-2 min-w-9\",\n        sm: \"h-8 px-1.5 min-w-8\",\n        lg: \"h-10 px-2.5 min-w-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nconst Toggle = React.forwardRef<\n  React.ElementRef<typeof TogglePrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &\n    VariantProps<typeof toggleVariants>\n>(({ className, variant, size, ...props }, ref) => (\n  <TogglePrimitive.Root\n    ref={ref}\n    className={cn(toggleVariants({ variant, size, className }))}\n    {...props}\n  />\n))\n\nToggle.displayName = TogglePrimitive.Root.displayName\n\nexport { Toggle, toggleVariants }\n","path":null,"size_bytes":1486,"size_tokens":null},"client/src/components/ui/toaster.tsx":{"content":"import { useToast } from \"@/hooks/use-toast\"\nimport {\n  Toast,\n  ToastClose,\n  ToastDescription,\n  ToastProvider,\n  ToastTitle,\n  ToastViewport,\n} from \"@/components/ui/toast\"\n\nexport function Toaster() {\n  const { toasts } = useToast()\n\n  return (\n    <ToastProvider>\n      {toasts.map(function ({ id, title, description, action, ...props }) {\n        return (\n          <Toast key={id} {...props}>\n            <div className=\"grid gap-1\">\n              {title && <ToastTitle>{title}</ToastTitle>}\n              {description && (\n                <ToastDescription>{description}</ToastDescription>\n              )}\n            </div>\n            {action}\n            <ToastClose />\n          </Toast>\n        )\n      })}\n      <ToastViewport />\n    </ToastProvider>\n  )\n}\n","path":null,"size_bytes":772,"size_tokens":null},"client/src/pages/Dashboard.tsx":{"content":"import { useQuery } from \"@tanstack/react-query\";\nimport { Nav } from \"@/components/dashboard/Nav\";\nimport { Ticker } from \"@/components/dashboard/Ticker\";\nimport { AssetCard } from \"@/components/dashboard/AssetCard\";\nimport { TradeLog } from \"@/components/dashboard/TradeLog\";\nimport { ChartWidget } from \"@/components/dashboard/ChartWidget\";\nimport { BotControl } from \"@/components/dashboard/BotControl\";\nimport { EventsPanel } from \"@/components/dashboard/EventsPanel\";\nimport { EnvironmentBadge } from \"@/components/dashboard/EnvironmentBadge\";\nimport { AlertCircle } from \"lucide-react\";\nimport { Link } from \"wouter\";\nimport generatedImage from '@assets/generated_images/dark_digital_hex_grid_background.png';\n\ninterface DashboardData {\n  krakenConnected: boolean;\n  telegramConnected: boolean;\n  botActive: boolean;\n  strategy: string;\n  activePairs: string[];\n  balances: Record<string, string>;\n  prices: Record<string, { price: string; change: string }>;\n  recentTrades: any[];\n}\n\nexport default function Dashboard() {\n  const { data, isLoading, error } = useQuery<DashboardData>({\n    queryKey: [\"dashboard\"],\n    queryFn: async () => {\n      const res = await fetch(\"/api/dashboard\");\n      if (!res.ok) throw new Error(\"Failed to fetch dashboard\");\n      return res.json();\n    },\n    refetchInterval: 30000,\n  });\n\n  const formatBalance = (symbol: string) => {\n    if (!data?.balances) return { balance: \"0\", value: \"$0.00\", change: 0 };\n    \n    const symbolMap: Record<string, string> = {\n      \"BTC\": \"XXBT\", \"ETH\": \"XETH\", \"SOL\": \"SOL\", \"XRP\": \"XXRP\", \"TON\": \"TON\", \"USD\": \"ZUSD\"\n    };\n    const pairMap: Record<string, string> = {\n      \"BTC\": \"XXBTZUSD\", \"ETH\": \"XETHZUSD\", \"SOL\": \"SOLUSD\", \"XRP\": \"XXRPZUSD\", \"TON\": \"TONUSD\"\n    };\n    \n    const krakenSymbol = symbolMap[symbol] || \"ZUSD\";\n    const balance = parseFloat(data.balances[krakenSymbol] || \"0\");\n    \n    const pricePair = pairMap[symbol];\n    const priceData = pricePair ? data.prices[pricePair] : null;\n    const price = parseFloat(priceData?.price || \"0\");\n    const change = parseFloat(priceData?.change || \"0\");\n    \n    const value = symbol === \"USD\" ? balance : balance * price;\n    \n    return {\n      balance: balance.toFixed(symbol === \"USD\" ? 2 : 4),\n      value: `$${value.toLocaleString(\"en-US\", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,\n      change: symbol === \"USD\" ? 0 : change,\n    };\n  };\n\n  const getTotalBalance = () => {\n    if (!data?.balances || !data?.prices) return \"$0.00\";\n    \n    let total = parseFloat(data.balances[\"ZUSD\"] || \"0\");\n    \n    const assets = [\n      { symbol: \"XXBT\", pair: \"XXBTZUSD\" },\n      { symbol: \"XETH\", pair: \"XETHZUSD\" },\n      { symbol: \"SOL\", pair: \"SOLUSD\" },\n      { symbol: \"XXRP\", pair: \"XXRPZUSD\" },\n      { symbol: \"TON\", pair: \"TONUSD\" },\n    ];\n    \n    for (const asset of assets) {\n      const balance = parseFloat(data.balances[asset.symbol] || \"0\");\n      const price = parseFloat(data.prices[asset.pair]?.price || \"0\");\n      total += balance * price;\n    }\n    \n    return `$${total.toLocaleString(\"en-US\", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;\n  };\n\n  const usdData = formatBalance(\"USD\");\n  \n  const cryptoAssets = [\n    { symbol: \"BTC\", name: \"Bitcoin\", ...formatBalance(\"BTC\") },\n    { symbol: \"ETH\", name: \"Ethereum\", ...formatBalance(\"ETH\") },\n    { symbol: \"SOL\", name: \"Solana\", ...formatBalance(\"SOL\") },\n    { symbol: \"XRP\", name: \"Ripple\", ...formatBalance(\"XRP\") },\n    { symbol: \"TON\", name: \"Toncoin\", ...formatBalance(\"TON\") },\n  ].sort((a, b) => {\n    const valueA = parseFloat(a.value.replace(/[$,]/g, \"\")) || 0;\n    const valueB = parseFloat(b.value.replace(/[$,]/g, \"\")) || 0;\n    return valueB - valueA;\n  });\n\n  return (\n    <div className=\"min-h-screen bg-background flex flex-col relative overflow-hidden\">\n      <div \n        className=\"fixed inset-0 z-0 opacity-20 pointer-events-none\" \n        style={{ \n          backgroundImage: `url(${generatedImage})`, \n          backgroundSize: 'cover',\n          backgroundPosition: 'center',\n          mixBlendMode: 'overlay'\n        }} \n      />\n      \n      <div className=\"relative z-10 flex flex-col min-h-screen\">\n        <Nav />\n        <Ticker />\n        \n        <div className=\"mx-4 md:mx-6 mt-4\">\n          <EnvironmentBadge />\n        </div>\n        \n        {!data?.krakenConnected && !isLoading && (\n          <div className=\"mx-4 md:mx-6 mt-4 p-3 md:p-4 bg-yellow-500/10 border border-yellow-500/30 rounded-lg flex flex-col sm:flex-row items-start sm:items-center gap-2 sm:gap-3\">\n            <AlertCircle className=\"h-5 w-5 text-yellow-500 shrink-0\" />\n            <div className=\"flex-1\">\n              <p className=\"text-sm font-medium text-yellow-500\">Kraken no conectado</p>\n              <p className=\"text-xs text-muted-foreground\">Configura tus claves API en Ajustes para ver datos reales.</p>\n            </div>\n            <Link href=\"/settings\" className=\"text-sm text-primary hover:underline whitespace-nowrap\" data-testid=\"link-goto-settings\">\n              Ir a Ajustes\n            </Link>\n          </div>\n        )}\n        \n        <main className=\"flex-1 p-4 md:p-6 grid grid-cols-1 lg:grid-cols-12 gap-4 md:gap-6 max-w-[1600px] mx-auto w-full\">\n          \n          <div className=\"col-span-1 lg:col-span-12 grid grid-cols-2 min-[500px]:grid-cols-3 lg:grid-cols-6 gap-3 md:gap-4\">\n            <AssetCard \n              symbol=\"USD\" \n              name=\"Balance Total\" \n              balance={usdData.balance} \n              value={data?.krakenConnected ? getTotalBalance() : \"--\"} \n              change={0} \n            />\n            {cryptoAssets.map((asset) => (\n              <AssetCard \n                key={asset.symbol}\n                symbol={asset.symbol} \n                name={asset.name} \n                balance={data?.krakenConnected ? asset.balance : \"--\"} \n                value={data?.krakenConnected ? asset.value : \"--\"} \n                change={asset.change} \n              />\n            ))}\n          </div>\n\n          <div className=\"col-span-1 lg:col-span-9 h-[280px] sm:h-[350px] md:h-[400px] lg:h-[500px]\">\n            <ChartWidget />\n          </div>\n          <div className=\"col-span-1 lg:col-span-3 space-y-3 md:space-y-4 lg:space-y-6\">\n            <BotControl />\n            <div className=\"glass-panel p-3 md:p-4 rounded-lg border border-border/50\">\n               <h3 className=\"text-xs font-mono text-muted-foreground mb-3\">PARES ACTIVOS</h3>\n               <div className=\"flex flex-wrap gap-2\">\n                 {(data?.activePairs || [\"BTC/USD\", \"ETH/USD\", \"SOL/USD\"]).map(pair => (\n                   <span key={pair} className=\"px-2 py-1 bg-primary/10 text-primary border border-primary/20 rounded text-xs font-mono\">\n                     {pair}\n                   </span>\n                 ))}\n               </div>\n            </div>\n          </div>\n\n          <div className=\"col-span-1 lg:col-span-6\">\n            <TradeLog />\n          </div>\n          \n          <div className=\"col-span-1 lg:col-span-6\">\n            <EventsPanel />\n          </div>\n\n        </main>\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":7140,"size_tokens":null},"postcss.config.js":{"content":"export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n","path":null,"size_bytes":80,"size_tokens":null},"server/routes.ts":{"content":"import type { Express } from \"express\";\nimport { createServer, type Server } from \"http\";\nimport { storage } from \"./storage\";\nimport { krakenService } from \"./services/kraken\";\nimport { telegramService } from \"./services/telegram\";\nimport { TradingEngine } from \"./services/tradingEngine\";\nimport { botLogger } from \"./services/botLogger\";\nimport { aiService } from \"./services/aiService\";\nimport { eventsWs } from \"./services/eventsWebSocket\";\nimport { terminalWsServer } from \"./services/terminalWebSocket\";\nimport { environment } from \"./services/environment\";\nimport { z } from \"zod\";\n\nlet tradingEngine: TradingEngine | null = null;\n\nexport function initializeWebSockets(httpServer: Server): void {\n  eventsWs.initialize(httpServer);\n  terminalWsServer.initialize(httpServer);\n  \n  httpServer.on(\"upgrade\", (req, socket, head) => {\n    const pathname = new URL(req.url || \"\", `http://${req.headers.host}`).pathname;\n    \n    if (pathname === \"/ws/events\") {\n      eventsWs.handleUpgrade(req, socket, head);\n    } else if (pathname === \"/ws/logs\") {\n      terminalWsServer.handleUpgrade(req, socket, head);\n    } else {\n      socket.destroy();\n    }\n  });\n}\n\nexport async function registerRoutes(\n  httpServer: Server,\n  app: Express\n): Promise<Server> {\n  \n  // Health check endpoint - MUST be registered before any other routes\n  // Returns JSON for monitoring/load balancers (not index.html)\n  // Returns 503 on errors so monitors can detect failures\n  app.get(\"/api/health\", async (req, res) => {\n    try {\n      const schemaStatus = await storage.checkSchemaHealth();\n      if (!schemaStatus.healthy) {\n        // Schema issues - return 503 so monitors detect the problem\n        return res.status(503).json({\n          status: \"unhealthy\",\n          timestamp: new Date().toISOString(),\n          schema: schemaStatus,\n          uptime: process.uptime(),\n          message: \"Schema migration required. Missing columns: \" + schemaStatus.missingColumns.join(\", \"),\n        });\n      }\n      res.json({\n        status: \"ok\",\n        timestamp: new Date().toISOString(),\n        schema: schemaStatus,\n        uptime: process.uptime(),\n      });\n    } catch (error) {\n      // Return 503 on errors so monitors can detect failures\n      res.status(503).json({\n        status: \"error\",\n        timestamp: new Date().toISOString(),\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      });\n    }\n  });\n\n  // Load saved API credentials on startup\n  try {\n    const apiConfig = await storage.getApiConfig();\n    if (apiConfig) {\n      if (apiConfig.krakenApiKey && apiConfig.krakenApiSecret && apiConfig.krakenConnected) {\n        krakenService.initialize({\n          apiKey: apiConfig.krakenApiKey,\n          apiSecret: apiConfig.krakenApiSecret,\n        });\n        console.log(\"[startup] Kraken API credentials loaded from database\");\n      }\n      if (apiConfig.telegramToken && apiConfig.telegramChatId && apiConfig.telegramConnected) {\n        telegramService.initialize({\n          token: apiConfig.telegramToken,\n          chatId: apiConfig.telegramChatId,\n        });\n        console.log(\"[startup] Telegram credentials loaded from database\");\n      }\n    }\n    \n    // Initialize trading engine\n    tradingEngine = new TradingEngine(krakenService, telegramService);\n    \n    // Set engine controller for Telegram commands\n    telegramService.setEngineController({\n      start: async () => { await tradingEngine?.start(); },\n      stop: async () => { await tradingEngine?.stop(); },\n      isActive: () => tradingEngine?.isActive() ?? false,\n      getBalance: async () => krakenService.isInitialized() ? await krakenService.getBalance() as Record<string, string> : {},\n      getOpenPositions: () => tradingEngine?.getOpenPositions() ?? new Map(),\n    });\n    \n    // Start heartbeat for Telegram notifications\n    telegramService.startHeartbeat();\n    \n    // Start daily report scheduler (14:00 Europe/Madrid)\n    telegramService.startDailyReport();\n    \n    // Auto-start if bot was active\n    const botConfig = await storage.getBotConfig();\n    if (botConfig?.isActive && krakenService.isInitialized()) {\n      console.log(\"[startup] Starting trading engine...\");\n      tradingEngine.start();\n    }\n  } catch (error) {\n    console.error(\"[startup] Error loading API credentials:\", error);\n  }\n\n  app.get(\"/api/config\", async (req, res) => {\n    try {\n      const config = await storage.getBotConfig();\n      res.json(config);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to get config\" });\n    }\n  });\n\n  app.post(\"/api/config\", async (req, res) => {\n    try {\n      const body = { ...req.body };\n      \n      // Validar y clampar porcentajes a rango 0-100\n      const pctFields = [\"riskPerTradePct\", \"maxPairExposurePct\", \"maxTotalExposurePct\"];\n      for (const field of pctFields) {\n        if (body[field] !== undefined) {\n          const val = parseFloat(body[field]);\n          if (isNaN(val)) {\n            return res.status(400).json({ error: `${field} debe ser un nÃºmero vÃ¡lido` });\n          }\n          if (val < 0 || val > 100) {\n            return res.status(400).json({ error: `${field} debe estar entre 0 y 100 (valor recibido: ${val})` });\n          }\n          body[field] = val.toFixed(2);\n        }\n      }\n      \n      const updated = await storage.updateBotConfig(body);\n      \n      if (req.body.isActive !== undefined && tradingEngine) {\n        if (req.body.isActive) {\n          await tradingEngine.start();\n        } else {\n          await tradingEngine.stop();\n        }\n      }\n      \n      res.json(updated);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to update config\" });\n    }\n  });\n\n  app.get(\"/api/config/api\", async (req, res) => {\n    try {\n      const config = await storage.getApiConfig();\n      res.json({\n        krakenConnected: config?.krakenConnected || false,\n        telegramConnected: config?.telegramConnected || false,\n        hasKrakenKeys: !!(config?.krakenApiKey && config?.krakenApiSecret),\n        hasTelegramKeys: !!(config?.telegramToken && config?.telegramChatId),\n      });\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to get API config\" });\n    }\n  });\n\n  app.get(\"/api/trading/status\", async (req, res) => {\n    try {\n      res.json({\n        engineRunning: tradingEngine?.isActive() || false,\n        krakenConnected: krakenService.isInitialized(),\n        telegramConnected: telegramService.isInitialized(),\n      });\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to get trading status\" });\n    }\n  });\n\n  // === DIAGNÃ“STICO DEL SCAN ===\n  app.get(\"/api/scan/diagnostic\", async (req, res) => {\n    try {\n      if (!tradingEngine) {\n        return res.status(503).json({ error: \"Motor de trading no inicializado\" });\n      }\n      const diagnostic = await tradingEngine.getScanDiagnostic();\n      res.json(diagnostic);\n    } catch (error: any) {\n      console.error(\"[scan/diagnostic] Error:\", error.message);\n      res.status(500).json({ error: \"Error obteniendo diagnÃ³stico del scan\" });\n    }\n  });\n\n  app.post(\"/api/config/kraken\", async (req, res) => {\n    try {\n      const { apiKey, apiSecret } = req.body;\n      \n      if (!apiKey || !apiSecret) {\n        return res.status(400).json({ error: \"API key and secret required\" });\n      }\n\n      krakenService.initialize({ apiKey, apiSecret });\n      \n      const balance = await krakenService.getBalance();\n      \n      await storage.updateApiConfig({\n        krakenApiKey: apiKey,\n        krakenApiSecret: apiSecret,\n        krakenConnected: true,\n      });\n      \n      res.json({ success: true, message: \"Kraken connected successfully\", balance });\n    } catch (error) {\n      await storage.updateApiConfig({ krakenConnected: false });\n      res.status(500).json({ error: \"Failed to connect to Kraken\" });\n    }\n  });\n\n  app.post(\"/api/config/telegram\", async (req, res) => {\n    try {\n      const { token, chatId } = req.body;\n      \n      if (!token || !chatId) {\n        return res.status(400).json({ error: \"Token and chat ID required\" });\n      }\n\n      telegramService.initialize({ token, chatId });\n      \n      const sent = await telegramService.sendMessage(\"âœ… Telegram conectado correctamente!\");\n      \n      if (!sent) {\n        return res.status(500).json({ error: \"Failed to send test message\" });\n      }\n      \n      await storage.updateApiConfig({\n        telegramToken: token,\n        telegramChatId: chatId,\n        telegramConnected: true,\n      });\n      \n      res.json({ success: true, message: \"Telegram connected successfully\" });\n    } catch (error) {\n      await storage.updateApiConfig({ telegramConnected: false });\n      res.status(500).json({ error: \"Failed to connect to Telegram\" });\n    }\n  });\n\n  // === SMART_GUARD Per-Pair Overrides ===\n  const SG_OVERRIDE_SCHEMA = z.object({\n    sgMinEntryUsd: z.number().min(0).max(100000).optional(),\n    sgAllowUnderMin: z.boolean().optional(),\n    sgBeAtPct: z.number().min(0).max(100).optional(),\n    sgFeeCushionPct: z.number().min(0).max(10).optional(),\n    sgFeeCushionAuto: z.boolean().optional(),\n    sgTrailStartPct: z.number().min(0).max(100).optional(),\n    sgTrailDistancePct: z.number().min(0).max(50).optional(),\n    sgTrailStepPct: z.number().min(0).max(10).optional(),\n    sgTpFixedEnabled: z.boolean().optional(),\n    sgTpFixedPct: z.number().min(0).max(500).optional(),\n    sgScaleOutEnabled: z.boolean().optional(),\n    sgScaleOutPct: z.number().min(0).max(100).optional(),\n    sgMinPartUsd: z.number().min(0).max(10000).optional(),\n    sgScaleOutThreshold: z.number().min(0).max(100).optional(),\n  });\n\n  const TRADEABLE_PAIRS = [\"BTC/USD\", \"ETH/USD\", \"SOL/USD\", \"XRP/USD\", \"TON/USD\"];\n\n  app.get(\"/api/config/sg-overrides\", async (req, res) => {\n    try {\n      const config = await storage.getBotConfig();\n      const overrides = (config?.sgPairOverrides as Record<string, unknown>) || {};\n      res.json({\n        pairs: TRADEABLE_PAIRS,\n        overrides,\n        global: {\n          sgMinEntryUsd: config?.sgMinEntryUsd,\n          sgAllowUnderMin: config?.sgAllowUnderMin,\n          sgBeAtPct: config?.sgBeAtPct,\n          sgFeeCushionPct: config?.sgFeeCushionPct,\n          sgFeeCushionAuto: config?.sgFeeCushionAuto,\n          sgTrailStartPct: config?.sgTrailStartPct,\n          sgTrailDistancePct: config?.sgTrailDistancePct,\n          sgTrailStepPct: config?.sgTrailStepPct,\n          sgTpFixedEnabled: config?.sgTpFixedEnabled,\n          sgTpFixedPct: config?.sgTpFixedPct,\n          sgScaleOutEnabled: config?.sgScaleOutEnabled,\n          sgScaleOutPct: config?.sgScaleOutPct,\n          sgMinPartUsd: config?.sgMinPartUsd,\n          sgScaleOutThreshold: config?.sgScaleOutThreshold,\n        },\n      });\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to get SG overrides\" });\n    }\n  });\n\n  app.put(\"/api/config/sg-overrides/:pair\", async (req, res) => {\n    try {\n      // Normalize pair: accept both BTC-USD and BTC/USD in URL\n      const pairRaw = decodeURIComponent(req.params.pair).replace(/-/g, \"/\");\n      if (!TRADEABLE_PAIRS.includes(pairRaw)) {\n        return res.status(400).json({ error: `Par invÃ¡lido: ${pairRaw}` });\n      }\n\n      // Coerce string values to numbers where expected\n      const body = { ...req.body };\n      for (const key of Object.keys(body)) {\n        if (typeof body[key] === \"string\" && ![\"sgAllowUnderMin\", \"sgFeeCushionAuto\", \"sgTpFixedEnabled\", \"sgScaleOutEnabled\"].includes(key)) {\n          const num = parseFloat(body[key]);\n          if (!isNaN(num)) body[key] = num;\n        }\n      }\n\n      const parsed = SG_OVERRIDE_SCHEMA.safeParse(body);\n      if (!parsed.success) {\n        return res.status(400).json({ error: \"Datos invÃ¡lidos\", details: parsed.error.flatten() });\n      }\n\n      const config = await storage.getBotConfig();\n      const currentOverrides = (config?.sgPairOverrides as Record<string, unknown>) || {};\n      const existingPair = (currentOverrides[pairRaw] as Record<string, unknown>) || {};\n      \n      // Merge with existing override for this pair\n      const newPairOverride = { ...existingPair, ...parsed.data };\n      const newOverrides = { ...currentOverrides, [pairRaw]: newPairOverride };\n\n      await storage.updateBotConfig({ sgPairOverrides: newOverrides });\n\n      // Log the change\n      const envInfo = environment.getInfo();\n      await botLogger.info(\"CONFIG_OVERRIDE_UPDATED\", `Override actualizado para ${pairRaw}`, {\n        pair: pairRaw,\n        changedKeys: Object.keys(parsed.data),\n        env: envInfo.env,\n        instanceId: envInfo.instanceId,\n      });\n\n      res.json({ success: true, pair: pairRaw, override: newPairOverride });\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to update SG override\" });\n    }\n  });\n\n  app.delete(\"/api/config/sg-overrides/:pair\", async (req, res) => {\n    try {\n      // Normalize pair: accept both BTC-USD and BTC/USD in URL\n      const pairRaw = decodeURIComponent(req.params.pair).replace(/-/g, \"/\");\n      if (!TRADEABLE_PAIRS.includes(pairRaw)) {\n        return res.status(400).json({ error: `Par invÃ¡lido: ${pairRaw}` });\n      }\n\n      const config = await storage.getBotConfig();\n      const currentOverrides = (config?.sgPairOverrides as Record<string, unknown>) || {};\n      \n      if (!(pairRaw in currentOverrides)) {\n        return res.status(404).json({ error: `No hay override para ${pairRaw}` });\n      }\n\n      const { [pairRaw]: removed, ...newOverrides } = currentOverrides;\n      await storage.updateBotConfig({ sgPairOverrides: newOverrides });\n\n      // Log the change\n      const envInfo = environment.getInfo();\n      await botLogger.info(\"CONFIG_OVERRIDE_UPDATED\", `Override eliminado para ${pairRaw}`, {\n        pair: pairRaw,\n        changedKeys: [\"DELETED\"],\n        env: envInfo.env,\n        instanceId: envInfo.instanceId,\n      });\n\n      res.json({ success: true, pair: pairRaw, message: \"Override eliminado\" });\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to delete SG override\" });\n    }\n  });\n\n  app.post(\"/api/telegram/send\", async (req, res) => {\n    try {\n      const { message } = req.body;\n      \n      if (!message) {\n        return res.status(400).json({ error: \"Mensaje requerido\" });\n      }\n\n      if (!telegramService.isInitialized()) {\n        return res.status(400).json({ error: \"Telegram no estÃ¡ configurado\" });\n      }\n\n      const sent = await telegramService.sendMessage(message);\n      \n      if (!sent) {\n        return res.status(500).json({ error: \"Error enviando mensaje\" });\n      }\n      \n      res.json({ success: true, message: \"Mensaje enviado\" });\n    } catch (error) {\n      res.status(500).json({ error: \"Error enviando mensaje a Telegram\" });\n    }\n  });\n\n  app.get(\"/api/telegram/chats\", async (req, res) => {\n    try {\n      const chats = await storage.getTelegramChats();\n      res.json(chats);\n    } catch (error) {\n      res.status(500).json({ error: \"Error obteniendo chats\" });\n    }\n  });\n\n  app.post(\"/api/telegram/chats\", async (req, res) => {\n    try {\n      const { name, chatId, alertTrades, alertErrors, alertSystem, alertBalance } = req.body;\n      \n      if (!name || !chatId) {\n        return res.status(400).json({ error: \"Nombre y Chat ID son requeridos\" });\n      }\n\n      if (!telegramService.isInitialized()) {\n        return res.status(400).json({ error: \"Telegram no estÃ¡ configurado. Configura primero el token principal.\" });\n      }\n\n      const existingChats = await storage.getTelegramChats();\n      const duplicate = existingChats.find(c => c.chatId === chatId);\n      if (duplicate) {\n        return res.status(400).json({ error: \"Este Chat ID ya estÃ¡ configurado.\" });\n      }\n\n      const testSent = await telegramService.sendToChat(chatId, \"âœ… Chat configurado correctamente en KrakenBot!\");\n      if (!testSent) {\n        return res.status(400).json({ error: \"No se pudo enviar mensaje al chat. Verifica el Chat ID.\" });\n      }\n\n      const chat = await storage.createTelegramChat({\n        name,\n        chatId,\n        alertTrades: alertTrades ?? true,\n        alertErrors: alertErrors ?? true,\n        alertSystem: alertSystem ?? true,\n        alertBalance: alertBalance ?? false,\n        isActive: true,\n      });\n      \n      res.json(chat);\n    } catch (error) {\n      res.status(500).json({ error: \"Error creando chat\" });\n    }\n  });\n\n  app.put(\"/api/telegram/chats/:id\", async (req, res) => {\n    try {\n      const id = parseInt(req.params.id);\n      const { name, chatId, alertTrades, alertErrors, alertSystem, alertBalance, isActive } = req.body;\n      \n      const chat = await storage.updateTelegramChat(id, {\n        name,\n        chatId,\n        alertTrades,\n        alertErrors,\n        alertSystem,\n        alertBalance,\n        isActive,\n      });\n      \n      res.json(chat);\n    } catch (error) {\n      res.status(500).json({ error: \"Error actualizando chat\" });\n    }\n  });\n\n  app.delete(\"/api/telegram/chats/:id\", async (req, res) => {\n    try {\n      const id = parseInt(req.params.id);\n      await storage.deleteTelegramChat(id);\n      res.json({ success: true });\n    } catch (error) {\n      res.status(500).json({ error: \"Error eliminando chat\" });\n    }\n  });\n\n  app.get(\"/api/dashboard\", async (req, res) => {\n    try {\n      const apiConfig = await storage.getApiConfig();\n      const botConfig = await storage.getBotConfig();\n      const trades = await storage.getTrades(10);\n      \n      let balances: Record<string, string> = {};\n      let prices: Record<string, { price: string; change: string }> = {};\n      \n      if (krakenService.isInitialized()) {\n        try {\n          balances = await krakenService.getBalance() as Record<string, string>;\n          \n          const pairs = [\"XXBTZUSD\", \"XETHZUSD\", \"SOLUSD\", \"XXRPZUSD\", \"TONUSD\"];\n          for (const pair of pairs) {\n            try {\n              const ticker = await krakenService.getTicker(pair);\n              const tickerData: any = Object.values(ticker)[0];\n              if (tickerData) {\n                const currentPrice = parseFloat(tickerData.c?.[0] || \"0\");\n                const openPrice = parseFloat(tickerData.o || \"0\");\n                const change = openPrice > 0 ? ((currentPrice - openPrice) / openPrice * 100).toFixed(2) : \"0\";\n                prices[pair] = { price: tickerData.c?.[0] || \"0\", change };\n              }\n            } catch (e) {}\n          }\n        } catch (e) {}\n      }\n      \n      res.json({\n        krakenConnected: apiConfig?.krakenConnected || false,\n        telegramConnected: apiConfig?.telegramConnected || false,\n        botActive: botConfig?.isActive || false,\n        strategy: botConfig?.strategy || \"momentum\",\n        activePairs: botConfig?.activePairs || [\"BTC/USD\", \"ETH/USD\", \"SOL/USD\"],\n        balances,\n        prices,\n        recentTrades: trades,\n      });\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to get dashboard data\" });\n    }\n  });\n\n  app.get(\"/api/trades\", async (req, res) => {\n    try {\n      const limit = parseInt(req.query.limit as string) || 50;\n      const trades = await storage.getTrades(limit);\n      res.json(trades);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to get trades\" });\n    }\n  });\n\n  app.get(\"/api/open-positions\", async (req, res) => {\n    try {\n      const positions = await storage.getOpenPositions();\n      \n      const positionsWithPnl = await Promise.all(positions.map(async (pos) => {\n        let currentPrice = 0;\n        let unrealizedPnlUsd = 0;\n        let unrealizedPnlPct = 0;\n        \n        if (krakenService.isInitialized()) {\n          try {\n            const krakenPair = krakenService.formatPair(pos.pair);\n            const ticker = await krakenService.getTicker(krakenPair);\n            const tickerData: any = Object.values(ticker)[0];\n            if (tickerData?.c?.[0]) {\n              currentPrice = parseFloat(tickerData.c[0]);\n              const entryPrice = parseFloat(pos.entryPrice);\n              const amount = parseFloat(pos.amount);\n              unrealizedPnlUsd = (currentPrice - entryPrice) * amount;\n              unrealizedPnlPct = ((currentPrice - entryPrice) / entryPrice) * 100;\n            }\n          } catch (e) {}\n        }\n        \n        const amount = parseFloat(pos.amount);\n        const entryPrice = parseFloat(pos.entryPrice);\n        const entryValueUsd = entryPrice * amount;\n        const currentValueUsd = currentPrice * amount;\n        \n        return {\n          ...pos,\n          currentPrice: currentPrice.toString(),\n          unrealizedPnlUsd: unrealizedPnlUsd.toFixed(2),\n          unrealizedPnlPct: unrealizedPnlPct.toFixed(2),\n          entryValueUsd: entryValueUsd.toFixed(2),\n          currentValueUsd: currentValueUsd.toFixed(2),\n        };\n      }));\n      \n      res.json(positionsWithPnl);\n    } catch (error) {\n      console.error(\"[api/open-positions] Error:\", error);\n      res.status(500).json({ error: \"Failed to get open positions\" });\n    }\n  });\n\n  // === CIERRE MANUAL DE POSICIÃ“N ===\n  app.post(\"/api/positions/:pair/close\", async (req, res) => {\n    try {\n      const pair = req.params.pair.replace(\"-\", \"/\"); // Convert BTC-USD back to BTC/USD\n      const { reason, lotId } = req.body; // Optional lotId for multi-lot support\n      \n      const correlationId = `MANUAL-CLOSE-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;\n      \n      // Verificar que la posiciÃ³n existe\n      const positions = await storage.getOpenPositions();\n      let position;\n      if (lotId) {\n        // Specific lot requested\n        position = positions.find(p => p.lotId === lotId);\n      } else {\n        // Close first position for the pair\n        position = positions.find(p => p.pair === pair);\n      }\n      \n      if (!position) {\n        await botLogger.warn(\"MANUAL_CLOSE_FAILED\", `Intento de cierre manual fallido - posiciÃ³n no encontrada`, {\n          pair,\n          lotId: lotId || \"not_specified\",\n          correlationId,\n          reason: reason || \"Usuario solicitÃ³ cierre manual\",\n        });\n        \n        return res.status(404).json({\n          success: false,\n          error: \"POSITION_NOT_FOUND\",\n          message: `No se encontrÃ³ posiciÃ³n abierta para ${pair}`,\n        });\n      }\n      \n      // Obtener precio actual (con fallback para DRY_RUN)\n      let currentPrice: number;\n      const botConfig = await storage.getBotConfig();\n      const isDryRun = botConfig?.dryRunMode || environment.isReplit;\n      \n      if (krakenService.isInitialized()) {\n        try {\n          const krakenPair = krakenService.formatPair(pair);\n          const ticker = await krakenService.getTicker(krakenPair);\n          const tickerData: any = Object.values(ticker)[0];\n          \n          if (tickerData?.c?.[0]) {\n            currentPrice = parseFloat(tickerData.c[0]);\n          } else {\n            throw new Error(\"No ticker data\");\n          }\n        } catch (e) {\n          if (!isDryRun) {\n            return res.status(500).json({\n              success: false,\n              error: \"PRICE_UNAVAILABLE\",\n              message: \"No se pudo obtener el precio actual\",\n            });\n          }\n          // En DRY_RUN, usar precio de entrada como fallback\n          currentPrice = parseFloat(position.entryPrice);\n        }\n      } else {\n        if (!isDryRun) {\n          return res.status(503).json({\n            success: false,\n            error: \"KRAKEN_NOT_INITIALIZED\",\n            message: \"Kraken API no estÃ¡ conectada\",\n          });\n        }\n        // En DRY_RUN, usar precio de entrada como fallback (simulaciÃ³n)\n        currentPrice = parseFloat(position.entryPrice);\n      }\n      const amount = parseFloat(position.amount);\n      const entryPrice = parseFloat(position.entryPrice);\n      const pnlUsd = (currentPrice - entryPrice) * amount;\n      const pnlPct = ((currentPrice - entryPrice) / entryPrice) * 100;\n      \n      const positionLotId = position.lotId;\n      \n      // Log el intento de cierre manual\n      await botLogger.info(\"MANUAL_CLOSE_INITIATED\", `Cierre manual iniciado por usuario`, {\n        correlationId,\n        pair,\n        lotId: positionLotId,\n        amount,\n        entryPrice,\n        currentPrice,\n        estimatedPnlUsd: pnlUsd.toFixed(2),\n        estimatedPnlPct: pnlPct.toFixed(2),\n        reason: reason || \"Usuario solicitÃ³ cierre manual\",\n      });\n      \n      // Ejecutar la venta a travÃ©s del trading engine\n      if (!tradingEngine) {\n        return res.status(503).json({\n          success: false,\n          error: \"ENGINE_NOT_RUNNING\",\n          message: \"Motor de trading no estÃ¡ activo\",\n        });\n      }\n      \n      const closeResult = await tradingEngine.forceClosePosition(pair, currentPrice, correlationId, reason || \"Cierre manual por usuario\", positionLotId);\n      \n      if (closeResult.success) {\n        await botLogger.info(\"MANUAL_CLOSE_SUCCESS\", `PosiciÃ³n cerrada manualmente`, {\n          correlationId,\n          pair,\n          lotId: closeResult.lotId || positionLotId,\n          amount,\n          exitPrice: currentPrice,\n          realizedPnlUsd: closeResult.pnlUsd?.toFixed(2),\n          realizedPnlPct: closeResult.pnlPct?.toFixed(2),\n          krakenOrderId: closeResult.orderId,\n          dryRun: closeResult.dryRun,\n        });\n        \n        res.json({\n          success: true,\n          correlationId,\n          pair,\n          lotId: closeResult.lotId || positionLotId,\n          amount,\n          exitPrice: currentPrice,\n          realizedPnlUsd: closeResult.pnlUsd?.toFixed(2),\n          realizedPnlPct: closeResult.pnlPct?.toFixed(2),\n          orderId: closeResult.orderId,\n          message: closeResult.dryRun \n            ? `[DRY_RUN] Cierre simulado de ${pair}`\n            : `PosiciÃ³n ${pair} cerrada exitosamente`,\n        });\n      } else {\n        // Caso DUST: devolver 200 con flag isDust para que UI ofrezca \"Eliminar huÃ©rfana\"\n        if (closeResult.isDust) {\n          await botLogger.warn(\"MANUAL_CLOSE_DUST\", `PosiciÃ³n DUST detectada - no se puede cerrar`, {\n            correlationId,\n            pair,\n            lotId: positionLotId,\n            error: closeResult.error,\n          });\n          \n          return res.json({\n            success: false,\n            correlationId,\n            error: \"DUST_POSITION\",\n            isDust: true,\n            lotId: positionLotId,\n            message: closeResult.error || \"Balance real menor al mÃ­nimo de Kraken\",\n          });\n        }\n        \n        await botLogger.error(\"MANUAL_CLOSE_FAILED\", `Error al cerrar posiciÃ³n manualmente`, {\n          correlationId,\n          pair,\n          lotId: positionLotId,\n          error: closeResult.error,\n        });\n        \n        res.status(500).json({\n          success: false,\n          correlationId,\n          error: \"CLOSE_FAILED\",\n          message: closeResult.error || \"Error al cerrar la posiciÃ³n\",\n        });\n      }\n      \n    } catch (error: any) {\n      const pair = req.params.pair?.replace(\"-\", \"/\") || \"UNKNOWN\";\n      const { lotId } = req.body || {};\n      const botConfigErr = await storage.getBotConfig();\n      const isDryRunErr = botConfigErr?.dryRunMode || environment.isReplit;\n      \n      console.error(\"[api/positions/close] FULL ERROR:\", {\n        message: error.message,\n        stack: error.stack,\n        pair,\n        lotId: lotId || \"not_specified\",\n        isDryRun: isDryRunErr,\n        timestamp: new Date().toISOString(),\n      });\n      \n      await botLogger.error(\"MANUAL_CLOSE_EXCEPTION\", `ExcepciÃ³n no controlada en cierre manual`, {\n        pair,\n        lotId: lotId || \"not_specified\",\n        isDryRun: isDryRunErr,\n        errorMessage: error.message,\n        errorStack: error.stack,\n      });\n      \n      res.status(500).json({\n        success: false,\n        error: \"INTERNAL_ERROR\",\n        message: `Error al procesar cierre: ${error.message}`,\n        stack: process.env.NODE_ENV === \"development\" ? error.stack : undefined,\n      });\n    }\n  });\n\n  // === ELIMINAR POSICIÃ“N HUÃ‰RFANA (DUST) ===\n  // Solo elimina el registro interno de DB/memoria, NO envÃ­a orden a Kraken\n  app.delete(\"/api/positions/:lotId/orphan\", async (req, res) => {\n    try {\n      const lotId = req.params.lotId;\n      const { reason } = req.body || {};\n      \n      // Verificar que la posiciÃ³n existe en DB\n      const dbPosition = await storage.getOpenPositionByLotId(lotId);\n      if (!dbPosition) {\n        return res.status(404).json({\n          success: false,\n          error: \"POSITION_NOT_FOUND\",\n          message: `No se encontrÃ³ posiciÃ³n con lotId: ${lotId}`,\n        });\n      }\n      \n      const pair = dbPosition.pair;\n      \n      // Eliminar de DB\n      await storage.deleteOpenPositionByLotId(lotId);\n      \n      // Eliminar de memoria del trading engine\n      if (tradingEngine) {\n        const positions = tradingEngine.getOpenPositions();\n        positions.delete(lotId);\n      }\n      \n      await botLogger.info(\"ORPHAN_POSITION_DELETED\", `PosiciÃ³n huÃ©rfana eliminada manualmente`, {\n        pair,\n        lotId,\n        amount: dbPosition.amount,\n        entryPrice: dbPosition.entryPrice,\n        reason: reason || \"orphan_dust_cleanup\",\n        env: environment.isReplit ? \"REPLIT\" : \"NAS\",\n      });\n      \n      // Notificar por Telegram\n      if (telegramService?.isInitialized()) {\n        await telegramService.sendMessage(`\nğŸ—‘ï¸ *PosiciÃ³n HuÃ©rfana Eliminada*\n\n*Par:* ${pair}\n*Lot:* \\`${lotId.substring(0, 8)}...\\`\n*Cantidad:* ${dbPosition.amount}\n\n_Eliminada manualmente desde dashboard (sin orden a Kraken)_\n        `.trim());\n      }\n      \n      res.json({\n        success: true,\n        lotId,\n        pair,\n        deleted: true,\n        message: `PosiciÃ³n huÃ©rfana eliminada de BD`,\n      });\n      \n    } catch (error: any) {\n      console.error(\"[api/positions/orphan] Error:\", error.message);\n      res.status(500).json({\n        success: false,\n        error: \"INTERNAL_ERROR\",\n        message: error.message,\n      });\n    }\n  });\n\n  // === RECONCILIAR POSICIONES CON KRAKEN ===\n  // Compara balances reales con posiciones en BD y elimina huÃ©rfanas\n  app.post(\"/api/positions/reconcile\", async (req, res) => {\n    try {\n      if (!krakenService) {\n        return res.status(503).json({ \n          success: false, \n          error: \"Kraken service not initialized\" \n        });\n      }\n\n      // Obtener todas las posiciones abiertas de BD\n      const openPositions = await storage.getOpenPositions();\n      if (openPositions.length === 0) {\n        return res.json({\n          success: true,\n          message: \"No hay posiciones abiertas en BD\",\n          reconciled: 0,\n          orphans: [],\n        });\n      }\n\n      // Obtener balances reales de Kraken\n      const balances = await krakenService.getBalance() as Record<string, string>;\n      \n      // MÃ­nimos de orden por par (hardcoded ya que getAssetPairs es para todos los pares)\n      const orderMinMap: Record<string, number> = {\n        \"BTC/USD\": 0.0001,\n        \"ETH/USD\": 0.004,\n        \"SOL/USD\": 0.2,\n        \"XRP/USD\": 10,\n        \"TON/USD\": 10,\n      };\n      \n      // Obtener mÃ­nimos de orden por par\n      const orphanPositions: Array<{ lotId: string; pair: string; amount: string; reason: string }> = [];\n      const validPositions: Array<{ lotId: string; pair: string; amount: string }> = [];\n      \n      for (const pos of openPositions) {\n        const assetMap: Record<string, string> = {\n          \"BTC/USD\": \"XXBT\",\n          \"ETH/USD\": \"XETH\",\n          \"SOL/USD\": \"SOL\",\n          \"XRP/USD\": \"XXRP\",\n          \"TON/USD\": \"TON\",\n        };\n        const assetKey = assetMap[pos.pair];\n        if (!assetKey) {\n          // Par desconocido, marcar como huÃ©rfana\n          orphanPositions.push({\n            lotId: pos.lotId,\n            pair: pos.pair,\n            amount: pos.amount,\n            reason: \"Par no reconocido\",\n          });\n          continue;\n        }\n\n        const realBalance = parseFloat(balances[assetKey] || \"0\");\n        const positionAmount = parseFloat(pos.amount);\n        \n        // Obtener mÃ­nimo de orden para este par\n        const orderMin = orderMinMap[pos.pair] || 0.0001;\n        \n        // Si el balance real es menor al mÃ­nimo de orden, es huÃ©rfana\n        if (realBalance < orderMin) {\n          orphanPositions.push({\n            lotId: pos.lotId,\n            pair: pos.pair,\n            amount: pos.amount,\n            reason: `Balance real (${realBalance.toFixed(8)}) < mÃ­nimo (${orderMin})`,\n          });\n        } else {\n          validPositions.push({\n            lotId: pos.lotId,\n            pair: pos.pair,\n            amount: pos.amount,\n          });\n        }\n      }\n\n      // Auto-limpiar huÃ©rfanas si se solicita\n      const autoClean = req.body?.autoClean === true;\n      let cleaned = 0;\n      \n      if (autoClean && orphanPositions.length > 0) {\n        for (const orphan of orphanPositions) {\n          try {\n            await storage.deleteOpenPositionByLotId(orphan.lotId);\n            if (tradingEngine) {\n              tradingEngine.getOpenPositions().delete(orphan.lotId);\n            }\n            cleaned++;\n          } catch (err) {\n            console.error(`Error limpiando huÃ©rfana ${orphan.lotId}:`, err);\n          }\n        }\n        \n        await botLogger.info(\"ORPHAN_POSITION_DELETED\", `ReconciliaciÃ³n completada`, {\n          total: openPositions.length,\n          orphans: orphanPositions.length,\n          cleaned,\n          valid: validPositions.length,\n        });\n        \n        if (telegramService?.isInitialized()) {\n          await telegramService.sendMessage(`\nğŸ”„ *ReconciliaciÃ³n Completada*\n\n*Total posiciones:* ${openPositions.length}\n*HuÃ©rfanas eliminadas:* ${cleaned}\n*VÃ¡lidas:* ${validPositions.length}\n          `.trim());\n        }\n      }\n\n      res.json({\n        success: true,\n        total: openPositions.length,\n        orphans: orphanPositions,\n        valid: validPositions,\n        cleaned,\n        message: autoClean \n          ? `ReconciliaciÃ³n completada: ${cleaned} huÃ©rfanas eliminadas`\n          : `Encontradas ${orphanPositions.length} posiciones huÃ©rfanas`,\n      });\n      \n    } catch (error: any) {\n      console.error(\"[api/positions/reconcile] Error:\", error.message);\n      res.status(500).json({\n        success: false,\n        error: \"INTERNAL_ERROR\",\n        message: error.message,\n      });\n    }\n  });\n\n  app.get(\"/api/trades/closed\", async (req, res) => {\n    try {\n      const limit = parseInt(req.query.limit as string) || 10;\n      const offset = parseInt(req.query.offset as string) || 0;\n      const pair = req.query.pair as string | undefined;\n      const result = (req.query.result as 'winner' | 'loser' | 'all') || 'all';\n      const type = (req.query.type as 'all' | 'buy' | 'sell') || 'all';\n      \n      const { trades, total } = await storage.getClosedTrades({ limit, offset, pair, result, type });\n      \n      res.json({\n        trades: trades.map(t => {\n          const price = parseFloat(t.price);\n          const amount = parseFloat(t.amount);\n          const totalUsd = price * amount;\n          const entryValueUsd = t.entryPrice ? parseFloat(t.entryPrice) * amount : null;\n          \n          return {\n            ...t,\n            totalUsd: totalUsd.toFixed(2),\n            entryValueUsd: entryValueUsd?.toFixed(2) || null,\n            realizedPnlUsd: t.realizedPnlUsd ? parseFloat(t.realizedPnlUsd).toFixed(2) : null,\n            realizedPnlPct: t.realizedPnlPct ? parseFloat(t.realizedPnlPct).toFixed(2) : null,\n          };\n        }),\n        total,\n        limit,\n        offset,\n      });\n    } catch (error) {\n      console.error(\"[api/trades/closed] Error:\", error);\n      res.status(500).json({ error: \"Failed to get closed trades\" });\n    }\n  });\n\n  app.get(\"/api/performance\", async (req, res) => {\n    try {\n      const trades = await storage.getTrades(500);\n      \n      const STARTING_EQUITY = 1000;\n      \n      const sortedTrades = [...trades].sort((a, b) => {\n        const dateA = a.executedAt ? new Date(a.executedAt).getTime() : new Date(a.createdAt).getTime();\n        const dateB = b.executedAt ? new Date(b.executedAt).getTime() : new Date(b.createdAt).getTime();\n        return dateA - dateB;\n      });\n\n      const pairPrices: Record<string, { lastBuyPrice: number; lastBuyAmount: number }> = {};\n      let currentEquity = STARTING_EQUITY;\n      let totalPnl = 0;\n      let wins = 0;\n      let losses = 0;\n      let maxEquity = STARTING_EQUITY;\n      let maxDrawdown = 0;\n\n      const firstTradeTime = sortedTrades.length > 0 \n        ? new Date(sortedTrades[0].executedAt || sortedTrades[0].createdAt).toISOString()\n        : new Date().toISOString();\n      \n      const curve: { time: string; equity: number; pnl?: number }[] = [\n        { time: firstTradeTime, equity: STARTING_EQUITY }\n      ];\n\n      for (const trade of sortedTrades) {\n        const pair = trade.pair;\n        const price = parseFloat(trade.price);\n        const amount = parseFloat(trade.amount);\n        const time = trade.executedAt ? new Date(trade.executedAt).toISOString() : new Date(trade.createdAt).toISOString();\n\n        if (trade.type === \"buy\") {\n          pairPrices[pair] = { lastBuyPrice: price, lastBuyAmount: amount };\n        } else if (trade.type === \"sell\") {\n          const lastBuy = pairPrices[pair];\n          if (lastBuy && lastBuy.lastBuyPrice > 0) {\n            const pnl = (price - lastBuy.lastBuyPrice) * Math.min(amount, lastBuy.lastBuyAmount);\n            totalPnl += pnl;\n            currentEquity += pnl;\n\n            if (pnl > 0) wins++;\n            else if (pnl < 0) losses++;\n\n            curve.push({ time, equity: currentEquity, pnl });\n\n            if (currentEquity > maxEquity) maxEquity = currentEquity;\n            const drawdown = ((maxEquity - currentEquity) / maxEquity) * 100;\n            if (drawdown > maxDrawdown) maxDrawdown = drawdown;\n\n            delete pairPrices[pair];\n          }\n        }\n      }\n\n      const totalTrades = wins + losses;\n      const winRatePct = totalTrades > 0 ? (wins / totalTrades) * 100 : 0;\n      const totalPnlPct = (totalPnl / STARTING_EQUITY) * 100;\n\n      res.json({\n        curve,\n        summary: {\n          startingEquity: STARTING_EQUITY,\n          endingEquity: currentEquity,\n          totalPnlUsd: totalPnl,\n          totalPnlPct,\n          maxDrawdownPct: maxDrawdown,\n          winRatePct,\n          totalTrades,\n          wins,\n          losses\n        }\n      });\n    } catch (error) {\n      console.error(\"Error calculating performance:\", error);\n      res.status(500).json({ error: \"Failed to calculate performance\" });\n    }\n  });\n\n  app.get(\"/api/market/:pair\", async (req, res) => {\n    try {\n      const { pair } = req.params;\n      const ticker = await krakenService.getTicker(pair);\n      \n      const tickerData: any = Object.values(ticker)[0] || {};\n      const data = await storage.saveMarketData({\n        pair,\n        price: tickerData.c?.[0] || \"0\",\n        volume24h: tickerData.v?.[1] || \"0\",\n        change24h: \"0\",\n      });\n      \n      res.json(data);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to get market data\" });\n    }\n  });\n\n  app.get(\"/api/balance\", async (req, res) => {\n    try {\n      if (!krakenService.isInitialized()) {\n        return res.status(400).json({ error: \"Kraken not configured\" });\n      }\n      \n      const balance = await krakenService.getBalance();\n      res.json(balance);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to get balance\" });\n    }\n  });\n\n  app.post(\"/api/trade\", async (req, res) => {\n    try {\n      if (!krakenService.isInitialized()) {\n        return res.status(400).json({ error: \"Kraken not configured\" });\n      }\n\n      const { pair, type, ordertype, volume, price } = req.body;\n      \n      const tradeId = `T-${Date.now()}`;\n      \n      const trade = await storage.createTrade({\n        tradeId,\n        pair,\n        type,\n        price: price || \"0\",\n        amount: volume,\n        status: \"pending\",\n      });\n\n      const order = await krakenService.placeOrder({\n        pair,\n        type,\n        ordertype,\n        volume,\n        price,\n      });\n\n      await storage.updateTradeStatus(tradeId, \"filled\", (order as any).txid?.[0]);\n      \n      await telegramService.sendTradeNotification({\n        type,\n        pair,\n        price: price || \"market\",\n        amount: volume,\n        status: \"filled\",\n      });\n\n      res.json({ success: true, trade, order });\n    } catch (error: any) {\n      res.status(500).json({ error: error.message || \"Failed to place trade\" });\n    }\n  });\n\n  app.get(\"/api/notifications\", async (req, res) => {\n    try {\n      const notifications = await storage.getUnsentNotifications();\n      res.json(notifications);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to get notifications\" });\n    }\n  });\n\n  app.post(\"/api/trades/sync\", async (req, res) => {\n    try {\n      if (!krakenService.isInitialized()) {\n        return res.status(400).json({ error: \"Kraken not configured\" });\n      }\n\n      // Obtener todo el historial de trades con paginaciÃ³n\n      const tradesHistory = await krakenService.getTradesHistory({ fetchAll: true });\n      const krakenTrades = tradesHistory.trades || {};\n      \n      let synced = 0;\n      let skipped = 0;\n      const errors: string[] = [];\n      \n      // Agrupar trades por par para cÃ¡lculo de P&L\n      const tradesByPair: Record<string, { buys: any[]; sells: any[] }> = {};\n      \n      for (const [txid, trade] of Object.entries(krakenTrades)) {\n        const t = trade as any;\n        const pair = krakenService.formatPairReverse(t.pair);\n        \n        if (!tradesByPair[pair]) {\n          tradesByPair[pair] = { buys: [], sells: [] };\n        }\n        \n        const tradeData = {\n          txid,\n          pair,\n          type: t.type,\n          price: parseFloat(t.price),\n          amount: parseFloat(t.vol),\n          cost: parseFloat(t.cost),\n          fee: parseFloat(t.fee),\n          time: new Date(t.time * 1000),\n        };\n        \n        if (t.type === 'buy') {\n          tradesByPair[pair].buys.push(tradeData);\n        } else {\n          tradesByPair[pair].sells.push(tradeData);\n        }\n        \n        try {\n          // === FIX DUPLICADOS v2: Triple verificaciÃ³n ===\n          const ordertxid = t.ordertxid;\n          const executedAt = new Date(t.time * 1000);\n          \n          // === B2: UPSERT por kraken_order_id ===\n          // 1. Verificar por ORDER ID (lo que guardÃ³ el bot)\n          const orderIdToCheck = ordertxid || txid;\n          const existingTrade = await storage.getTradeByKrakenOrderId(orderIdToCheck);\n          \n          if (existingTrade) {\n            // B2: UPDATE - construir patch sin sobreescribir P&L existente\n            const patch: any = {\n              price: t.price,\n              amount: t.vol,\n              status: \"filled\",\n              executedAt,\n            };\n            \n            // B3: Log discrepancias P&L si ambos valores existen y difieren > 1%\n            // (no machacar el existente)\n            if (existingTrade.realizedPnlUsd != null && existingTrade.entryPrice != null) {\n              // Ya tiene P&L calculado, no actualizar campos P&L\n            }\n            \n            await storage.updateTradeByKrakenOrderId(orderIdToCheck, patch);\n            skipped++;\n            continue;\n          }\n          \n          // 2. Verificar por FILL ID (sync previo usÃ³ txid como krakenOrderId)\n          if (!existingTrade) {\n            const existingByFillId = await storage.getTradeByKrakenOrderId(txid);\n            if (existingByFillId) {\n              // B2: UPDATE por txid - misma lÃ³gica de patch\n              const patchByFill: any = {\n                price: t.price,\n                amount: t.vol,\n                status: \"filled\",\n                executedAt,\n              };\n              \n              // No machacar P&L existente\n              if (existingByFillId.realizedPnlUsd == null && existingByFillId.entryPrice == null) {\n                // OK para actualizar P&L si viene de sync\n              }\n              \n              await storage.updateTradeByKrakenOrderId(txid, patchByFill);\n              skipped++;\n              continue;\n            }\n          }\n          \n          // 3. Verificar por caracterÃ­sticas (pair + amount + type + timestamp < 60s)\n          const existingByTraits = await storage.findDuplicateTrade(pair, t.vol, t.type, executedAt);\n          if (existingByTraits) {\n            skipped++;\n            continue;\n          }\n          \n          // No existe duplicado, INSERT\n          const result = await storage.upsertTradeByKrakenId({\n            tradeId: `KRAKEN-${txid}`,\n            pair,\n            type: t.type,\n            price: t.price,\n            amount: t.vol,\n            status: \"filled\",\n            krakenOrderId: txid,\n            executedAt,\n          });\n          \n          if (result.inserted) {\n            synced++;\n          } else {\n            skipped++;\n          }\n        } catch (e: any) {\n          errors.push(`${txid}: ${e.message}`);\n        }\n      }\n      \n      // Calcular P&L para SELLs emparejÃ¡ndolos con BUYs (FIFO)\n      let pnlCalculated = 0;\n      for (const [pair, trades] of Object.entries(tradesByPair)) {\n        // Ordenar por tiempo\n        trades.buys.sort((a, b) => a.time.getTime() - b.time.getTime());\n        trades.sells.sort((a, b) => a.time.getTime() - b.time.getTime());\n        \n        let buyIndex = 0;\n        let buyRemaining = trades.buys[0]?.amount || 0;\n        \n        for (const sell of trades.sells) {\n          let sellRemaining = sell.amount;\n          let totalCost = 0;\n          let totalAmount = 0;\n          let totalBuyFees = 0; // Accumulated buy-side fees for matched portion\n          \n          // Emparejar con BUYs (FIFO)\n          while (sellRemaining > 0 && buyIndex < trades.buys.length) {\n            const buy = trades.buys[buyIndex];\n            const matchAmount = Math.min(buyRemaining, sellRemaining);\n            \n            // Pro-rate buy fee based on matched portion\n            const buyFeeForMatch = (matchAmount / buy.amount) * buy.fee;\n            \n            totalCost += matchAmount * buy.price;\n            totalAmount += matchAmount;\n            totalBuyFees += buyFeeForMatch;\n            \n            sellRemaining -= matchAmount;\n            buyRemaining -= matchAmount;\n            \n            if (buyRemaining <= 0.00000001) {\n              buyIndex++;\n              buyRemaining = trades.buys[buyIndex]?.amount || 0;\n            }\n          }\n          \n          // Only calculate P&L for matched portion\n          if (totalAmount > 0) {\n            const avgEntryPrice = totalCost / totalAmount;\n            // Use totalAmount (matched) not sell.amount for revenue calculation\n            const revenue = totalAmount * sell.price;\n            const cost = totalCost;\n            // Include both buy and sell fees in net P&L\n            const totalFees = totalBuyFees + sell.fee;\n            const pnlGross = revenue - cost;\n            const pnlNet = pnlGross - totalFees;\n            const pnlPct = cost > 0 ? (pnlGross / cost) * 100 : 0;\n            \n            // Actualizar el trade SELL con P&L\n            const existingSell = await storage.getTradeByKrakenOrderId(sell.txid);\n            if (existingSell && (!existingSell.realizedPnlUsd || existingSell.realizedPnlUsd === null)) {\n              await storage.updateTradePnl(\n                existingSell.id,\n                avgEntryPrice.toFixed(8),\n                pnlNet.toFixed(8),  // Use net P&L (after all fees)\n                pnlPct.toFixed(4)\n              );\n              pnlCalculated++;\n            }\n          }\n        }\n      }\n\n      // Nota: El cierre automÃ¡tico de posiciones abiertas requiere tracking de volumen\n      // acumulado (parciales) y se manejarÃ¡ via endpoints separados o manualmente.\n      // El sync solo registra trades y calcula P&L.\n\n      res.json({ \n        success: true, \n        synced, \n        skipped,\n        pnlCalculated,\n        total: Object.keys(krakenTrades).length,\n        errors: errors.length > 0 ? errors.slice(0, 10) : undefined,\n      });\n    } catch (error: any) {\n      res.status(500).json({ error: error.message || \"Failed to sync trades\" });\n    }\n  });\n\n  // Endpoint para limpiar duplicados existentes\n  app.post(\"/api/trades/cleanup-duplicates\", async (req, res) => {\n    try {\n      const duplicates = await storage.getDuplicateTradesByKrakenId();\n      \n      if (duplicates.length === 0) {\n        return res.json({ success: true, message: \"No hay duplicados\", deleted: 0 });\n      }\n      \n      const deleted = await storage.deleteDuplicateTrades();\n      \n      res.json({ \n        success: true, \n        duplicatesFound: duplicates.length,\n        deleted,\n        details: duplicates.slice(0, 20),\n      });\n    } catch (error: any) {\n      res.status(500).json({ error: error.message || \"Failed to cleanup duplicates\" });\n    }\n  });\n\n  // Endpoint para ver duplicados sin eliminar\n  app.get(\"/api/trades/duplicates\", async (req, res) => {\n    try {\n      const duplicates = await storage.getDuplicateTradesByKrakenId();\n      res.json({ \n        count: duplicates.length,\n        duplicates: duplicates.slice(0, 50),\n      });\n    } catch (error: any) {\n      res.status(500).json({ error: error.message || \"Failed to get duplicates\" });\n    }\n  });\n\n  // FIFO Matcher endpoints\n  app.post(\"/api/fifo/init-lots\", async (req, res) => {\n    try {\n      const { fifoMatcher } = await import(\"./services/fifoMatcher\");\n      const initialized = await fifoMatcher.initializeLots();\n      res.json({ success: true, lotsInitialized: initialized });\n    } catch (error: any) {\n      res.status(500).json({ error: error.message || \"Failed to initialize lots\" });\n    }\n  });\n\n  app.post(\"/api/fifo/process-sells\", async (req, res) => {\n    try {\n      const { fifoMatcher } = await import(\"./services/fifoMatcher\");\n      const result = await fifoMatcher.processAllUnmatchedSells();\n      res.json({ success: true, ...result });\n    } catch (error: any) {\n      res.status(500).json({ error: error.message || \"Failed to process sells\" });\n    }\n  });\n\n  app.post(\"/api/fifo/ingest-fill\", async (req, res) => {\n    try {\n      const { txid, orderId, pair, type, price, amount, cost, fee, executedAt } = req.body;\n      \n      if (!txid || !pair || !type || !price || !amount) {\n        return res.status(400).json({ error: \"Missing required fields: txid, pair, type, price, amount\" });\n      }\n\n      const fillResult = await storage.upsertTradeFill({\n        txid,\n        orderId: orderId || txid,\n        pair,\n        type: type.toLowerCase(),\n        price: price.toString(),\n        amount: amount.toString(),\n        cost: (cost || parseFloat(price) * parseFloat(amount)).toString(),\n        fee: (fee || 0).toString(),\n        matched: false,\n        executedAt: new Date(executedAt || Date.now()),\n      });\n\n      if (!fillResult.inserted) {\n        return res.json({ success: true, message: \"Fill already exists\", fill: fillResult.fill });\n      }\n\n      if (type.toUpperCase() === \"SELL\") {\n        const { fifoMatcher } = await import(\"./services/fifoMatcher\");\n        const matchResult = await fifoMatcher.processSellFill(fillResult.fill!);\n        return res.json({ success: true, fill: fillResult.fill, matchResult });\n      }\n\n      res.json({ success: true, fill: fillResult.fill });\n    } catch (error: any) {\n      res.status(500).json({ error: error.message || \"Failed to ingest fill\" });\n    }\n  });\n\n  app.get(\"/api/fifo/open-lots\", async (req, res) => {\n    try {\n      const lots = await storage.getOpenPositionsWithQtyRemaining();\n      res.json({\n        count: lots.length,\n        lots: lots.map(l => ({\n          lotId: l.lotId,\n          pair: l.pair,\n          entryPrice: l.entryPrice,\n          amount: l.amount,\n          qtyRemaining: l.qtyRemaining || l.amount,\n          qtyFilled: l.qtyFilled || \"0\",\n          openedAt: l.openedAt,\n        })),\n      });\n    } catch (error: any) {\n      res.status(500).json({ error: error.message || \"Failed to get open lots\" });\n    }\n  });\n\n  app.get(\"/api/kraken/trades\", async (req, res) => {\n    try {\n      if (!krakenService.isInitialized()) {\n        const localTrades = await storage.getTrades(50);\n        return res.json(localTrades.map(t => ({\n          id: t.tradeId,\n          krakenOrderId: t.krakenOrderId,\n          pair: t.pair,\n          type: t.type,\n          price: t.price,\n          amount: t.amount,\n          time: t.executedAt?.toISOString() || t.createdAt.toISOString(),\n          status: t.status,\n        })));\n      }\n\n      const tradesHistory = await krakenService.getTradesHistory();\n      const trades = tradesHistory.trades || {};\n      \n      const formattedTrades = Object.entries(trades).map(([txid, trade]) => {\n        const t = trade as any;\n        return {\n          id: txid.substring(0, 10),\n          krakenOrderId: txid,\n          pair: krakenService.formatPairReverse(t.pair),\n          type: t.type,\n          price: t.price,\n          amount: t.vol,\n          cost: t.cost,\n          fee: t.fee,\n          time: new Date(t.time * 1000).toISOString(),\n          status: \"filled\",\n        };\n      }).sort((a, b) => new Date(b.time).getTime() - new Date(a.time).getTime());\n\n      res.json(formattedTrades);\n    } catch (error: any) {\n      console.error(\"[api/kraken/trades] Error:\", error.message);\n      const localTrades = await storage.getTrades(50);\n      res.json(localTrades.map(t => ({\n        id: t.tradeId,\n        krakenOrderId: t.krakenOrderId,\n        pair: t.pair,\n        type: t.type,\n        price: t.price,\n        amount: t.amount,\n        time: t.executedAt?.toISOString() || t.createdAt.toISOString(),\n        status: t.status,\n      })));\n    }\n  });\n\n  app.get(\"/api/events\", async (req, res) => {\n    try {\n      const limit = Math.min(parseInt(req.query.limit as string) || 50, 200);\n      const level = req.query.level as string;\n      \n      const events = await botLogger.getDbEvents(limit);\n      \n      const filtered = level \n        ? events.filter(e => e.level === level.toUpperCase())\n        : events;\n      \n      res.json(filtered.map(e => {\n        const meta = e.meta ? JSON.parse(e.meta) : null;\n        return {\n          id: e.id,\n          timestamp: e.timestamp,\n          level: e.level,\n          type: e.type,\n          message: e.message,\n          meta,\n          env: meta?.env || null,\n          instanceId: meta?.instanceId || null,\n        };\n      }));\n    } catch (error: any) {\n      console.error(\"[api/events] Error:\", error.message);\n      res.status(500).json({ error: \"Failed to fetch events\" });\n    }\n  });\n\n  app.get(\"/api/ai/status\", async (req, res) => {\n    try {\n      const status = await aiService.getStatus();\n      res.json(status);\n    } catch (error: any) {\n      console.error(\"[api/ai/status] Error:\", error.message);\n      res.status(500).json({ errorCode: \"STATUS_ERROR\", message: \"Error al obtener el estado de la IA\" });\n    }\n  });\n\n  app.get(\"/api/ai/diagnostic\", async (req, res) => {\n    try {\n      const diagnostic = await aiService.getDiagnostic();\n      const config = await storage.getBotConfig();\n      const dryRun = environment.isReplit || (config?.dryRunMode ?? false);\n      res.json({\n        ...diagnostic,\n        env: environment.envTag,\n        instanceId: environment.instanceId,\n        dryRun,\n      });\n    } catch (error: any) {\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  app.get(\"/api/environment\", async (req, res) => {\n    try {\n      const config = await storage.getBotConfig();\n      const dryRun = environment.isReplit || (config?.dryRunMode ?? false);\n      \n      // Obtener git commit hash\n      let gitCommit = \"unknown\";\n      try {\n        const { execSync } = await import(\"child_process\");\n        gitCommit = execSync(\"git rev-parse --short HEAD\", { encoding: \"utf-8\" }).trim();\n      } catch {\n        // Git no disponible, usar archivo de versiÃ³n si existe\n        try {\n          const fs = await import(\"fs\");\n          if (fs.existsSync(\"VERSION\")) {\n            gitCommit = fs.readFileSync(\"VERSION\", \"utf-8\").trim();\n          }\n        } catch {}\n      }\n      \n      res.json({\n        env: environment.envTag,\n        instanceId: environment.instanceId,\n        isReplit: environment.isReplit,\n        isNAS: environment.isNAS,\n        dryRun,\n        gitCommit,\n      });\n    } catch (error: any) {\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  app.post(\"/api/ai/backfill\", async (req, res) => {\n    try {\n      const result = await aiService.runBackfill();\n      res.json(result);\n    } catch (error: any) {\n      res.status(500).json({ success: false, error: error.message });\n    }\n  });\n\n  // Endpoint para limpiar duplicados en training_trades\n  app.post(\"/api/ai/cleanup-duplicates\", async (req, res) => {\n    try {\n      const duplicates = await storage.getDuplicateTrainingTradesByBuyTxid();\n      \n      if (duplicates.length === 0) {\n        return res.json({ success: true, message: \"No hay duplicados en training_trades\", deleted: 0 });\n      }\n      \n      const deleted = await storage.deleteDuplicateTrainingTrades();\n      \n      res.json({ \n        success: true, \n        duplicatesFound: duplicates.length,\n        deleted,\n        details: duplicates.slice(0, 20),\n      });\n    } catch (error: any) {\n      res.status(500).json({ error: error.message || \"Failed to cleanup training trades duplicates\" });\n    }\n  });\n\n  // Endpoint para ver duplicados en training_trades sin eliminar\n  app.get(\"/api/ai/duplicates\", async (req, res) => {\n    try {\n      const duplicates = await storage.getDuplicateTrainingTradesByBuyTxid();\n      res.json({ \n        count: duplicates.length,\n        duplicates: duplicates.slice(0, 50),\n      });\n    } catch (error: any) {\n      res.status(500).json({ error: error.message || \"Failed to get training trades duplicates\" });\n    }\n  });\n\n  app.get(\"/api/ai/samples\", async (req, res) => {\n    try {\n      const complete = req.query.complete === \"true\" ? true : req.query.complete === \"false\" ? false : undefined;\n      const limit = parseInt(req.query.limit as string) || 100;\n      const samples = await storage.getAiSamples({ complete, limit });\n      const count = await storage.getAiSamplesCount(complete);\n      res.json({ samples, total: count });\n    } catch (error: any) {\n      console.error(\"[api/ai/samples] Error:\", error.message);\n      res.status(500).json({ errorCode: \"SAMPLES_ERROR\", message: \"Error al obtener las muestras de IA\" });\n    }\n  });\n\n  app.post(\"/api/ai/retrain\", async (req, res) => {\n    try {\n      const result = await aiService.runTraining();\n      if (!result.success && result.errorCode === \"INSUFFICIENT_DATA\") {\n        res.status(409).json({\n          errorCode: result.errorCode,\n          message: result.message,\n          required: result.required,\n          current: result.current\n        });\n      } else if (!result.success) {\n        res.status(500).json({\n          errorCode: result.errorCode || \"TRAINING_ERROR\",\n          message: result.message\n        });\n      } else {\n        res.json({ success: true, message: result.message, metrics: result.metrics });\n      }\n    } catch (error: any) {\n      console.error(\"[api/ai/retrain] Error:\", error.message);\n      res.status(500).json({ errorCode: \"TRAINING_ERROR\", message: \"Error interno al reentrenar el modelo\" });\n    }\n  });\n\n  app.post(\"/api/ai/train\", async (req, res) => {\n    try {\n      const result = await aiService.runTraining();\n      if (!result.success && result.errorCode === \"INSUFFICIENT_DATA\") {\n        res.status(409).json({\n          errorCode: result.errorCode,\n          message: result.message,\n          required: result.required,\n          current: result.current\n        });\n      } else if (!result.success) {\n        res.status(500).json({\n          errorCode: result.errorCode || \"TRAINING_ERROR\",\n          message: result.message\n        });\n      } else {\n        res.json({ success: true, message: result.message, metrics: result.metrics });\n      }\n    } catch (error: any) {\n      console.error(\"[api/ai/train] Error:\", error.message);\n      res.status(500).json({ errorCode: \"TRAINING_ERROR\", message: `Error interno al entrenar el modelo: ${error.message}` });\n    }\n  });\n\n  app.get(\"/api/ai/shadow/report\", async (req, res) => {\n    try {\n      const report = await storage.getAiShadowReport();\n      res.json(report);\n    } catch (error: any) {\n      console.error(\"[api/ai/shadow/report] Error:\", error.message);\n      res.status(500).json({ errorCode: \"SHADOW_REPORT_ERROR\", message: \"Error al obtener el informe de shadow\" });\n    }\n  });\n\n  app.post(\"/api/ai/toggle\", async (req, res) => {\n    try {\n      const { filterEnabled, shadowEnabled, threshold } = req.body;\n      \n      if (filterEnabled !== undefined) {\n        await aiService.toggleFilter(filterEnabled);\n      }\n      if (shadowEnabled !== undefined) {\n        await aiService.toggleShadow(shadowEnabled);\n      }\n      if (threshold !== undefined) {\n        await aiService.setThreshold(parseFloat(threshold));\n      }\n      \n      const status = await aiService.getStatus();\n      res.json({ success: true, status });\n    } catch (error: any) {\n      console.error(\"[api/ai/toggle] Error:\", error.message);\n      res.status(500).json({ errorCode: \"TOGGLE_ERROR\", message: \"Error al cambiar la configuraciÃ³n de IA\" });\n    }\n  });\n\n  // ============================================================\n  // TEST ENDPOINT: Simular seÃ±al BUY para validar SMART_GUARD\n  // Solo disponible en REPLIT/DEV o cuando dryRun=true\n  // ============================================================\n  app.post(\"/api/test/signal\", async (req, res) => {\n    try {\n      const envInfo = environment.getInfo();\n      const botConfig = await storage.getBotConfig();\n      const dryRun = botConfig?.dryRunMode ?? true;\n      \n      // SEGURIDAD: Solo permitir en REPLIT/DEV o dryRun=true\n      if (envInfo.isNAS && !dryRun) {\n        return res.status(403).json({\n          error: \"FORBIDDEN\",\n          message: \"Este endpoint solo estÃ¡ disponible en entorno de desarrollo (REPLIT/DEV) o con dryRun activado\",\n          env: envInfo.env,\n          dryRun,\n        });\n      }\n      \n      // Validar body\n      const testSignalSchema = z.object({\n        pair: z.string().min(1),\n        signal: z.enum([\"BUY\"]),\n        price: z.number().positive().optional(),\n        forceOrderUsd: z.number().positive().optional(),\n        forceHasPosition: z.boolean().optional(),\n        forceOpenLots: z.number().int().min(0).optional(),\n      });\n      \n      const parsed = testSignalSchema.safeParse(req.body);\n      if (!parsed.success) {\n        return res.status(400).json({\n          error: \"VALIDATION_ERROR\",\n          message: \"ParÃ¡metros invÃ¡lidos\",\n          details: parsed.error.issues,\n        });\n      }\n      \n      const { pair, signal, price, forceOrderUsd, forceHasPosition, forceOpenLots } = parsed.data;\n      const correlationId = `TEST-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;\n      \n      // Obtener datos del mercado si no se proporciona precio\n      let currentPrice = price;\n      if (!currentPrice) {\n        try {\n          const ticker = await krakenService.getTicker(pair);\n          currentPrice = parseFloat(ticker?.c?.[0] || \"0\");\n        } catch {\n          currentPrice = 100; // Fallback para test\n        }\n      }\n      \n      // Obtener configuraciÃ³n SMART_GUARD\n      const positionMode = botConfig?.positionMode || \"SINGLE\";\n      const sgMinEntryUsd = parseFloat(botConfig?.sgMinEntryUsd?.toString() || \"100\");\n      const sgAllowUnderMin = botConfig?.sgAllowUnderMin ?? true;\n      const sgMaxOpenLotsPerPair = 1; // Por defecto 1, se implementarÃ¡ en paso 3\n      const SG_ABSOLUTE_MIN_USD = 20;\n      \n      // Obtener balance USD\n      let usdBalance = 0;\n      try {\n        const balances = await krakenService.getBalance() as Record<string, string>;\n        usdBalance = parseFloat(balances?.ZUSD || balances?.USD || \"0\");\n      } catch {\n        usdBalance = 100; // Fallback para test\n      }\n      \n      // Simular orderUsdFinal\n      const orderUsdFinal = forceOrderUsd ?? Math.min(usdBalance * 0.95, sgMinEntryUsd);\n      \n      // Simular si hay posiciÃ³n abierta\n      const hasPosition = forceHasPosition ?? (tradingEngine?.getOpenPositions().has(pair) ?? false);\n      const openLots = forceOpenLots ?? (hasPosition ? 1 : 0);\n      \n      // Construir meta base\n      const baseMeta = {\n        correlationId,\n        pair,\n        signal,\n        env: envInfo.env,\n        instanceId: envInfo.instanceId,\n        testMode: true,\n        positionMode,\n        usdDisponible: usdBalance,\n        orderUsdProposed: sgMinEntryUsd,\n        orderUsdFinal,\n        sgMinEntryUsd,\n        sgAllowUnderMin,\n        sgMaxOpenLotsPerPair,\n        absoluteMinOrderUsd: SG_ABSOLUTE_MIN_USD,\n        hasPosition,\n        openLots,\n        currentPrice,\n      };\n      \n      let result: { decision: string; reason: string; message: string };\n      \n      // === VALIDACIÃ“N 1: PosiciÃ³n abierta en SMART_GUARD/SINGLE ===\n      if ((positionMode === \"SINGLE\" || positionMode === \"SMART_GUARD\") && hasPosition && openLots >= sgMaxOpenLotsPerPair) {\n        const reason = positionMode === \"SMART_GUARD\" \n          ? (openLots >= sgMaxOpenLotsPerPair ? \"SMART_GUARD_MAX_LOTS_REACHED\" : \"SMART_GUARD_POSITION_EXISTS\")\n          : \"SINGLE_MODE_POSITION_EXISTS\";\n        \n        await botLogger.info(\"TRADE_SKIPPED\", `[TEST] SeÃ±al BUY bloqueada - ${reason}`, {\n          ...baseMeta,\n          reason,\n          existingLots: openLots,\n        });\n        \n        result = {\n          decision: \"TRADE_SKIPPED\",\n          reason,\n          message: reason === \"SMART_GUARD_MAX_LOTS_REACHED\"\n            ? `MÃ¡ximo de lotes abiertos alcanzado (${openLots}/${sgMaxOpenLotsPerPair})`\n            : \"Ya hay posiciÃ³n abierta en este par\",\n        };\n      }\n      // === VALIDACIÃ“N 2: MÃ­nimo absoluto exchange (MIN_ORDER_ABSOLUTE) - Prioridad mÃ¡s alta ===\n      else if (orderUsdFinal < SG_ABSOLUTE_MIN_USD) {\n        const reason = \"MIN_ORDER_ABSOLUTE\";\n        \n        await botLogger.info(\"TRADE_SKIPPED\", `[TEST] SeÃ±al BUY bloqueada - mÃ­nimo absoluto exchange`, {\n          ...baseMeta,\n          reason,\n        });\n        \n        result = {\n          decision: \"TRADE_SKIPPED\",\n          reason,\n          message: `MÃ­nimo absoluto exchange no alcanzado: $${orderUsdFinal.toFixed(2)} < $${SG_ABSOLUTE_MIN_USD}`,\n        };\n      }\n      // === VALIDACIÃ“N 3: MÃ­nimo por orden (MIN_ORDER_USD) ===\n      else if (positionMode === \"SMART_GUARD\" && !sgAllowUnderMin && orderUsdFinal < sgMinEntryUsd) {\n        const reason = \"MIN_ORDER_USD\";\n        \n        await botLogger.info(\"TRADE_SKIPPED\", `[TEST] SeÃ±al BUY bloqueada - mÃ­nimo por orden no alcanzado`, {\n          ...baseMeta,\n          reason,\n        });\n        \n        result = {\n          decision: \"TRADE_SKIPPED\",\n          reason,\n          message: `MÃ­nimo por orden no alcanzado: $${orderUsdFinal.toFixed(2)} < $${sgMinEntryUsd.toFixed(2)} (allowUnderMin=OFF)`,\n        };\n      }\n      // === CASO POSITIVO: Trade permitido (simulado) ===\n      else {\n        const reason = \"TEST_TRADE_ALLOWED\";\n        \n        await botLogger.info(\"TEST_TRADE_SIMULATED\", `[TEST] SeÃ±al BUY pasarÃ­a todas las validaciones`, {\n          ...baseMeta,\n          reason,\n        });\n        \n        result = {\n          decision: \"TEST_TRADE_SIMULATED\",\n          reason,\n          message: `Trade de $${orderUsdFinal.toFixed(2)} pasarÃ­a todas las validaciones en ${positionMode}`,\n        };\n      }\n      \n      res.json({\n        success: true,\n        correlationId,\n        ...result,\n        meta: baseMeta,\n      });\n      \n    } catch (error: any) {\n      console.error(\"[api/test/signal] Error:\", error.message);\n      res.status(500).json({\n        error: \"TEST_SIGNAL_ERROR\",\n        message: `Error al procesar seÃ±al de prueba: ${error.message}`,\n      });\n    }\n  });\n\n  // ============================================================\n  // TEST ENDPOINT: Simular eventos SMART_GUARD para testing\n  // Solo disponible en REPLIT/DEV o cuando dryRun=true\n  // ============================================================\n  app.post(\"/api/test/sg-event\", async (req, res) => {\n    try {\n      const envInfo = environment.getInfo();\n      const botConfig = await storage.getBotConfig();\n      const dryRun = botConfig?.dryRunMode ?? true;\n      \n      // SEGURIDAD: Solo permitir en REPLIT/DEV o dryRun=true\n      if (envInfo.isNAS && !dryRun) {\n        return res.status(403).json({\n          error: \"FORBIDDEN\",\n          message: \"Este endpoint solo estÃ¡ disponible en entorno de desarrollo (REPLIT/DEV) o con dryRun activado\",\n        });\n      }\n      \n      const testEventSchema = z.object({\n        event: z.enum([\"SG_BREAK_EVEN_ACTIVATED\", \"SG_TRAILING_ACTIVATED\", \"SG_TRAILING_STOP_UPDATED\", \"SG_SCALE_OUT_EXECUTED\"]),\n        pair: z.string().default(\"BTC/USD\"),\n        lotId: z.string().optional(),\n        entryPrice: z.number().positive().default(100000),\n        currentPrice: z.number().positive().optional(),\n        profitPct: z.number().default(2.5),\n        stopPrice: z.number().positive().optional(),\n        scaleOutQty: z.number().positive().optional(),\n        scaleOutUsd: z.number().positive().optional(),\n      });\n      \n      const parsed = testEventSchema.safeParse(req.body);\n      if (!parsed.success) {\n        return res.status(400).json({ error: \"VALIDATION_ERROR\", details: parsed.error.issues });\n      }\n      \n      const { event, pair, entryPrice, profitPct } = parsed.data;\n      const lotId = parsed.data.lotId || `TEST-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`;\n      const currentPrice = parsed.data.currentPrice || entryPrice * (1 + profitPct / 100);\n      const stopPrice = parsed.data.stopPrice || currentPrice * 0.98;\n      \n      const baseMeta = {\n        pair,\n        lotId,\n        entryPrice,\n        currentPrice,\n        profitPct: profitPct.toFixed(2) + \"%\",\n        env: envInfo.env,\n        instanceId: envInfo.instanceId,\n        testMode: true,\n      };\n      \n      let message = \"\";\n      let telegramMsg = \"\";\n      const prefix = environment.getMessagePrefix(true); // Test events are always DRY_RUN\n      \n      switch (event) {\n        case \"SG_BREAK_EVEN_ACTIVATED\":\n          message = `SMART_GUARD Break-Even activado en ${pair}`;\n          telegramMsg = `${prefix}âš–ï¸ *Break-Even Activado*\\n` +\n            `Par: ${pair}\\n` +\n            `Lote: \\`${lotId}\\`\\n` +\n            `Entrada: $${entryPrice.toFixed(2)}\\n` +\n            `Precio actual: $${currentPrice.toFixed(2)}\\n` +\n            `Profit: +${profitPct.toFixed(2)}%\\n` +\n            `Stop movido a: $${stopPrice.toFixed(2)}`;\n          await botLogger.info(event, message, { ...baseMeta, stopPrice });\n          await telegramService.sendAlertToMultipleChats(telegramMsg, \"status\");\n          break;\n          \n        case \"SG_TRAILING_ACTIVATED\":\n          message = `SMART_GUARD Trailing Stop activado en ${pair}`;\n          telegramMsg = `${prefix}ğŸ¯ *Trailing Stop Activado*\\n` +\n            `Par: ${pair}\\n` +\n            `Lote: \\`${lotId}\\`\\n` +\n            `Entrada: $${entryPrice.toFixed(2)}\\n` +\n            `Precio actual: $${currentPrice.toFixed(2)}\\n` +\n            `Profit: +${profitPct.toFixed(2)}%\\n` +\n            `Stop dinÃ¡mico: $${stopPrice.toFixed(2)}`;\n          await botLogger.info(event, message, { ...baseMeta, stopPrice });\n          await telegramService.sendAlertToMultipleChats(telegramMsg, \"status\");\n          break;\n          \n        case \"SG_TRAILING_STOP_UPDATED\":\n          const oldStop = stopPrice * 0.99;\n          message = `SMART_GUARD Trailing Stop actualizado en ${pair}`;\n          telegramMsg = `${prefix}ğŸ“ˆ *Trailing Stop Actualizado*\\n` +\n            `Par: ${pair}\\n` +\n            `Lote: \\`${lotId}\\`\\n` +\n            `Stop: $${oldStop.toFixed(2)} â†’ $${stopPrice.toFixed(2)}\\n` +\n            `Profit actual: +${profitPct.toFixed(2)}%`;\n          await botLogger.info(event, message, { ...baseMeta, stopPrice, oldStop });\n          await telegramService.sendAlertToMultipleChats(telegramMsg, \"status\");\n          break;\n          \n        case \"SG_SCALE_OUT_EXECUTED\":\n          const scaleOutQty = parsed.data.scaleOutQty || 0.001;\n          const scaleOutUsd = parsed.data.scaleOutUsd || scaleOutQty * currentPrice;\n          message = `SMART_GUARD Scale-Out ejecutado en ${pair}`;\n          telegramMsg = `${prefix}ğŸ“Š *Scale-Out Ejecutado*\\n` +\n            `Par: ${pair}\\n` +\n            `Lote: \\`${lotId}\\`\\n` +\n            `Vendido: ${scaleOutQty} ($${scaleOutUsd.toFixed(2)})\\n` +\n            `Profit: +${profitPct.toFixed(2)}%`;\n          await botLogger.info(event, message, { ...baseMeta, scaleOutQty, scaleOutUsd });\n          await telegramService.sendAlertToMultipleChats(telegramMsg, \"status\");\n          break;\n      }\n      \n      res.json({\n        success: true,\n        event,\n        message,\n        meta: baseMeta,\n        telegramSent: true,\n      });\n      \n    } catch (error: any) {\n      console.error(\"[api/test/sg-event] Error:\", error.message);\n      res.status(500).json({ error: \"TEST_SG_EVENT_ERROR\", message: error.message });\n    }\n  });\n\n  // ============================================================\n  // TEST ENDPOINT: Probar multi-lot (crear posiciones de prueba)\n  // ============================================================\n  app.post(\"/api/test/create-position\", async (req, res) => {\n    try {\n      const envInfo = environment.getInfo();\n      const botConfig = await storage.getBotConfig();\n      const dryRun = botConfig?.dryRunMode ?? true;\n      \n      if (envInfo.isNAS && !dryRun) {\n        return res.status(403).json({ error: \"FORBIDDEN\" });\n      }\n      \n      const schema = z.object({\n        pair: z.string().default(\"BTC/USD\"),\n        amount: z.number().positive().default(0.001),\n        entryPrice: z.number().positive().default(100000),\n      });\n      \n      const parsed = schema.safeParse(req.body);\n      if (!parsed.success) {\n        return res.status(400).json({ error: \"VALIDATION_ERROR\", details: parsed.error.issues });\n      }\n      \n      const { pair, amount, entryPrice } = parsed.data;\n      const lotId = `TEST-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`;\n      \n      // Add to trading engine's open positions\n      if (tradingEngine) {\n        const position = {\n          pair,\n          amount,\n          entryPrice,\n          timestamp: new Date().toISOString(),\n          lotId,\n          strategy: \"test\",\n          signalConfidence: 0.8,\n          // SMART_GUARD flags\n          sgBreakEvenActivated: false,\n          sgTrailingActivated: false,\n          sgCurrentStopPrice: null,\n          sgScaleOutDone: false,\n          configSnapshotJson: botConfig ? JSON.stringify({\n            sgMinEntryUsd: botConfig.sgMinEntryUsd,\n            sgBeAtPct: botConfig.sgBeAtPct,\n            sgTrailStartPct: botConfig.sgTrailStartPct,\n            sgTrailDistancePct: botConfig.sgTrailDistancePct,\n          }) : null,\n        };\n        \n        tradingEngine.getOpenPositions().set(lotId, position);\n        \n        // Count lots for this pair\n        const allPositions = tradingEngine.getOpenPositions();\n        let pairLots = 0;\n        Array.from(allPositions.values()).forEach((pos: any) => {\n          if (pos.pair === pair) pairLots++;\n        });\n        \n        await botLogger.info(\"TEST_POSITION_CREATED\", `PosiciÃ³n de prueba creada: ${pair} x${amount}`, {\n          pair, lotId, amount, entryPrice, pairLots, env: envInfo.env,\n        });\n        \n        res.json({\n          success: true,\n          lotId,\n          position,\n          pairLotsCount: pairLots,\n        });\n      } else {\n        res.status(500).json({ error: \"ENGINE_NOT_READY\" });\n      }\n      \n    } catch (error: any) {\n      res.status(500).json({ error: \"CREATE_POSITION_ERROR\", message: error.message });\n    }\n  });\n\n  // ============================================================\n  // TEST ENDPOINT: Eliminar posiciÃ³n de prueba\n  // ============================================================\n  app.delete(\"/api/test/position/:lotId\", async (req, res) => {\n    try {\n      const envInfo = environment.getInfo();\n      const botConfig = await storage.getBotConfig();\n      const dryRun = botConfig?.dryRunMode ?? true;\n      \n      if (envInfo.isNAS && !dryRun) {\n        return res.status(403).json({ error: \"FORBIDDEN\" });\n      }\n      \n      const { lotId } = req.params;\n      \n      if (tradingEngine) {\n        const deleted = tradingEngine.getOpenPositions().delete(lotId);\n        res.json({ success: true, deleted, lotId });\n      } else {\n        res.status(500).json({ error: \"ENGINE_NOT_READY\" });\n      }\n      \n    } catch (error: any) {\n      res.status(500).json({ error: \"DELETE_POSITION_ERROR\", message: error.message });\n    }\n  });\n\n  // ============================================================\n  // TEST ENDPOINT: Simular sizing SMART_GUARD v2\n  // Para validar la lÃ³gica: 469â†’200, 250â†’200, 150â†’150, 25â†’25, 19â†’block\n  // ============================================================\n  app.post(\"/api/test/sg-sizing\", async (req, res) => {\n    try {\n      const envInfo = environment.getInfo();\n      const botConfig = await storage.getBotConfig();\n      const dryRun = botConfig?.dryRunMode ?? true;\n      \n      if (envInfo.isNAS && !dryRun) {\n        return res.status(403).json({ error: \"FORBIDDEN\" });\n      }\n      \n      const schema = z.object({\n        availableUsd: z.number().min(0),\n        sgMinEntryUsd: z.number().positive().default(200),\n        minOrderExchangeUsd: z.number().positive().default(10), // mÃ­nimo del exchange en USD\n        feeCushionPct: z.number().min(0).default(0),\n      });\n      \n      const parsed = schema.safeParse(req.body);\n      if (!parsed.success) {\n        return res.status(400).json({ error: \"VALIDATION_ERROR\", details: parsed.error.issues });\n      }\n      \n      const { availableUsd, sgMinEntryUsd, minOrderExchangeUsd, feeCushionPct } = parsed.data;\n      \n      // Constantes\n      const SG_ABSOLUTE_MIN_USD = 20;\n      \n      // SMART_GUARD v2: sin buffer de slippage para sizing exacto\n      const usdDisponible = availableUsd;\n      \n      // floorUsd = max(minOrderExchangeUsd, MIN_ORDER_ABSOLUTE_USD)\n      const floorUsd = Math.max(SG_ABSOLUTE_MIN_USD, minOrderExchangeUsd);\n      \n      // Fee cushion\n      const cushionAmount = availableUsd * (feeCushionPct / 100);\n      const availableAfterCushion = usdDisponible - cushionAmount;\n      \n      // === SMART_GUARD v2 SIZING LOGIC ===\n      let orderUsd: number;\n      let reasonCode: string;\n      let blocked = false;\n      \n      if (availableAfterCushion >= sgMinEntryUsd) {\n        // Caso A: Saldo suficiente â†’ usar sgMinEntryUsd EXACTO\n        orderUsd = sgMinEntryUsd;\n        reasonCode = \"SMART_GUARD_ENTRY_USING_CONFIG_MIN\";\n        \n      } else if (availableAfterCushion >= floorUsd) {\n        // Caso B: Fallback automÃ¡tico â†’ usar saldo disponible\n        orderUsd = availableAfterCushion;\n        reasonCode = \"SMART_GUARD_ENTRY_FALLBACK_TO_AVAILABLE\";\n        \n      } else if (usdDisponible >= floorUsd && availableAfterCushion < floorUsd) {\n        // Caso C: Fee cushion lo baja de floorUsd â†’ BLOCKED\n        orderUsd = availableAfterCushion;\n        reasonCode = \"SMART_GUARD_BLOCKED_AFTER_FEE_CUSHION\";\n        blocked = true;\n        \n      } else {\n        // Caso D: Saldo < floorUsd â†’ BLOCKED\n        orderUsd = usdDisponible;\n        reasonCode = \"SMART_GUARD_BLOCKED_BELOW_EXCHANGE_MIN\";\n        blocked = true;\n      }\n      \n      res.json({\n        success: true,\n        blocked,\n        reasonCode,\n        orderUsd: parseFloat(orderUsd.toFixed(2)),\n        details: {\n          input: {\n            availableUsd,\n            sgMinEntryUsd,\n            minOrderExchangeUsd,\n            feeCushionPct,\n          },\n          calculated: {\n            usdDisponible: parseFloat(usdDisponible.toFixed(2)),\n            floorUsd,\n            cushionAmount: parseFloat(cushionAmount.toFixed(2)),\n            availableAfterCushion: parseFloat(availableAfterCushion.toFixed(2)),\n          },\n          thresholds: {\n            SG_ABSOLUTE_MIN_USD,\n            minOrderExchangeUsd,\n            floorUsd,\n          },\n        },\n      });\n      \n    } catch (error: any) {\n      res.status(500).json({ error: \"SG_SIZING_TEST_ERROR\", message: error.message });\n    }\n  });\n\n  return httpServer;\n}\n","path":null,"size_bytes":80957,"size_tokens":null},"server/storage.ts":{"content":"import { \n  type BotConfig, \n  type Trade, \n  type Notification, \n  type MarketData,\n  type ApiConfig,\n  type TelegramChat,\n  type OpenPosition,\n  type AiTradeSample,\n  type AiShadowDecision,\n  type AiConfig,\n  type TrainingTrade,\n  type InsertBotConfig,\n  type InsertTrade,\n  type InsertNotification,\n  type InsertMarketData,\n  type InsertApiConfig,\n  type InsertTelegramChat,\n  type InsertOpenPosition,\n  type InsertAiTradeSample,\n  type InsertAiShadowDecision,\n  type InsertAiConfig,\n  type InsertTrainingTrade,\n  type TradeFill,\n  type LotMatch,\n  type InsertTradeFill,\n  type InsertLotMatch,\n  botConfig as botConfigTable,\n  trades as tradesTable,\n  notifications as notificationsTable,\n  marketData as marketDataTable,\n  apiConfig as apiConfigTable,\n  telegramChats as telegramChatsTable,\n  openPositions as openPositionsTable,\n  tradeFills as tradeFillsTable,\n  lotMatches as lotMatchesTable,\n  aiTradeSamples as aiTradeSamplesTable,\n  aiShadowDecisions as aiShadowDecisionsTable,\n  aiConfig as aiConfigTable,\n  trainingTrades as trainingTradesTable\n} from \"@shared/schema\";\nimport { db } from \"./db\";\nimport { eq, desc, and, gt, lt, sql, isNull } from \"drizzle-orm\";\n\nexport interface IStorage {\n  getBotConfig(): Promise<BotConfig | undefined>;\n  updateBotConfig(config: Partial<InsertBotConfig>): Promise<BotConfig>;\n  \n  getApiConfig(): Promise<ApiConfig | undefined>;\n  updateApiConfig(config: Partial<InsertApiConfig>): Promise<ApiConfig>;\n  \n  createTrade(trade: InsertTrade): Promise<Trade>;\n  getTrades(limit?: number): Promise<Trade[]>;\n  getClosedTrades(options: { limit?: number; offset?: number; pair?: string; result?: 'winner' | 'loser' | 'all'; type?: 'all' | 'buy' | 'sell' }): Promise<{ trades: Trade[]; total: number }>;\n  updateTradeStatus(tradeId: string, status: string, krakenOrderId?: string): Promise<void>;\n  getTradeByKrakenOrderId(krakenOrderId: string): Promise<Trade | undefined>;\n  updateTradeByKrakenOrderId(krakenOrderId: string, patch: Partial<InsertTrade>): Promise<Trade | undefined>;\n  getTradeByLotId(lotId: string): Promise<Trade | undefined>;\n  getSellMatchingBuy(pair: string, buyLotId: string): Promise<Trade | undefined>;\n  upsertTradeByKrakenId(trade: InsertTrade): Promise<{ inserted: boolean; trade?: Trade }>;\n  getDuplicateTradesByKrakenId(): Promise<{ krakenOrderId: string; count: number; ids: number[] }[]>;\n  deleteDuplicateTrades(): Promise<number>;\n  updateTradePnl(id: number, entryPrice: string, realizedPnlUsd: string, realizedPnlPct: string): Promise<void>;\n  getUnmatchedBuys(pair: string): Promise<Trade[]>;\n  \n  createNotification(notification: InsertNotification): Promise<Notification>;\n  getUnsentNotifications(): Promise<Notification[]>;\n  markNotificationSent(id: number): Promise<void>;\n  \n  saveMarketData(data: InsertMarketData): Promise<MarketData>;\n  getLatestMarketData(pair: string): Promise<MarketData | undefined>;\n  \n  getTelegramChats(): Promise<TelegramChat[]>;\n  getActiveTelegramChats(): Promise<TelegramChat[]>;\n  getTelegramChatByChatId(chatId: string): Promise<TelegramChat | undefined>;\n  createTelegramChat(chat: InsertTelegramChat): Promise<TelegramChat>;\n  updateTelegramChat(id: number, chat: Partial<InsertTelegramChat>): Promise<TelegramChat>;\n  deleteTelegramChat(id: number): Promise<void>;\n  \n  getOpenPositions(): Promise<OpenPosition[]>;\n  getOpenPosition(pair: string): Promise<OpenPosition | undefined>;\n  getOpenPositionByLotId(lotId: string): Promise<OpenPosition | undefined>;\n  getOpenPositionsByPair(pair: string): Promise<OpenPosition[]>;\n  saveOpenPosition(position: InsertOpenPosition): Promise<OpenPosition>;\n  saveOpenPositionByLotId(position: InsertOpenPosition): Promise<OpenPosition>;\n  updateOpenPosition(pair: string, updates: Partial<InsertOpenPosition>): Promise<OpenPosition | undefined>;\n  updateOpenPositionByLotId(lotId: string, updates: Partial<InsertOpenPosition>): Promise<OpenPosition | undefined>;\n  updateOpenPositionLotId(id: number, lotId: string): Promise<void>;\n  deleteOpenPosition(pair: string): Promise<void>;\n  deleteOpenPositionByLotId(lotId: string): Promise<void>;\n  getOpenPositionsWithQtyRemaining(): Promise<OpenPosition[]>;\n  updateOpenPositionQty(lotId: string, qtyRemaining: string, qtyFilled: string): Promise<void>;\n  initializeQtyRemainingForAll(): Promise<number>;\n  \n  // Trade fills\n  upsertTradeFill(fill: InsertTradeFill): Promise<{ inserted: boolean; fill?: TradeFill }>;\n  getTradeFillByTxid(txid: string): Promise<TradeFill | undefined>;\n  getUnmatchedSellFills(pair: string): Promise<TradeFill[]>;\n  markFillAsMatched(txid: string): Promise<void>;\n  \n  // Lot matches (FIFO matcher audit trail)\n  createLotMatch(match: InsertLotMatch): Promise<LotMatch>;\n  getLotMatchesByLotId(lotId: string): Promise<LotMatch[]>;\n  getLotMatchBySellFillAndLot(sellFillTxid: string, lotId: string): Promise<LotMatch | undefined>;\n  \n  saveAiSample(sample: InsertAiTradeSample): Promise<AiTradeSample>;\n  updateAiSample(sampleId: number, updates: Partial<InsertAiTradeSample>): Promise<AiTradeSample | undefined>;\n  getAiSamples(options?: { complete?: boolean; limit?: number }): Promise<AiTradeSample[]>;\n  getAiSamplesCount(complete?: boolean): Promise<number>;\n  \n  saveAiShadowDecision(decision: InsertAiShadowDecision): Promise<AiShadowDecision>;\n  updateAiShadowFinalPnl(tradeId: string, pnl: string): Promise<void>;\n  getAiShadowReport(): Promise<{ total: number; blocked: number; blockedLosers: number; passedLosers: number }>;\n  \n  getAiConfig(): Promise<AiConfig | undefined>;\n  updateAiConfig(config: Partial<InsertAiConfig>): Promise<AiConfig>;\n  \n  saveTrainingTrade(trade: InsertTrainingTrade): Promise<TrainingTrade>;\n  updateTrainingTrade(id: number, updates: Partial<InsertTrainingTrade>): Promise<TrainingTrade | undefined>;\n  getTrainingTradeByBuyTxid(buyTxid: string): Promise<TrainingTrade | undefined>;\n  getTrainingTrades(options?: { closed?: boolean; labeled?: boolean; limit?: number }): Promise<TrainingTrade[]>;\n  getDuplicateTrainingTradesByBuyTxid(): Promise<{ buyTxid: string; count: number; ids: number[] }[]>;\n  deleteDuplicateTrainingTrades(): Promise<number>;\n  getTrainingTradesCount(options?: { closed?: boolean; labeled?: boolean; hasOpenLots?: boolean }): Promise<number>;\n  getDiscardReasonsDataset(): Promise<Record<string, number>>;\n  getAllTradesForBackfill(): Promise<Trade[]>;\n  runTrainingTradesBackfill(): Promise<{ created: number; closed: number; labeled: number; discardReasons: Record<string, number> }>;\n  \n  // Schema health check and auto-migration\n  checkSchemaHealth(): Promise<{ healthy: boolean; missingColumns: string[]; migrationRan: boolean }>;\n  runSchemaMigration(): Promise<{ success: boolean; columnsAdded: string[]; error?: string }>;\n}\n\nexport class DatabaseStorage implements IStorage {\n  private schemaMigrationAttempted = false;\n  \n  async getBotConfig(): Promise<BotConfig | undefined> {\n    try {\n      const configs = await db.select().from(botConfigTable).limit(1);\n      if (configs.length === 0) {\n        const [newConfig] = await db.insert(botConfigTable).values({}).returning();\n        return newConfig;\n      }\n      return configs[0];\n    } catch (error) {\n      // If schema is outdated, try auto-migration ONCE then retry\n      if (!this.schemaMigrationAttempted && error instanceof Error && error.message.includes('does not exist')) {\n        console.log('[storage] Schema issue detected, attempting auto-migration...');\n        this.schemaMigrationAttempted = true;\n        const migrationResult = await this.runSchemaMigration();\n        if (migrationResult.success) {\n          console.log('[storage] Auto-migration successful, retrying getBotConfig...');\n          return this.getBotConfig();\n        }\n        // Migration failed - propagate error\n        console.error('[storage] Auto-migration failed:', migrationResult.error);\n      }\n      // No fallback - surface the error so operators know to fix schema\n      throw error;\n    }\n  }\n\n  async updateBotConfig(config: Partial<InsertBotConfig>): Promise<BotConfig> {\n    const existing = await this.getBotConfig();\n    if (!existing) {\n      const [newConfig] = await db.insert(botConfigTable).values(config as InsertBotConfig).returning();\n      return newConfig;\n    }\n    const [updated] = await db.update(botConfigTable)\n      .set({ ...config, updatedAt: new Date() })\n      .where(eq(botConfigTable.id, existing.id))\n      .returning();\n    return updated;\n  }\n\n  async getApiConfig(): Promise<ApiConfig | undefined> {\n    const configs = await db.select().from(apiConfigTable).limit(1);\n    if (configs.length === 0) {\n      const [newConfig] = await db.insert(apiConfigTable).values({}).returning();\n      return newConfig;\n    }\n    return configs[0];\n  }\n\n  async updateApiConfig(config: Partial<InsertApiConfig>): Promise<ApiConfig> {\n    const existing = await this.getApiConfig();\n    if (!existing) {\n      const [newConfig] = await db.insert(apiConfigTable).values(config as InsertApiConfig).returning();\n      return newConfig;\n    }\n    const [updated] = await db.update(apiConfigTable)\n      .set({ ...config, updatedAt: new Date() })\n      .where(eq(apiConfigTable.id, existing.id))\n      .returning();\n    return updated;\n  }\n\n  async createTrade(trade: InsertTrade): Promise<Trade> {\n    const [newTrade] = await db.insert(tradesTable).values(trade).returning();\n    return newTrade;\n  }\n\n  // Upsert trade - inserta solo si no existe (por krakenOrderId)\n  async upsertTradeByKrakenId(trade: InsertTrade): Promise<{ inserted: boolean; trade?: Trade }> {\n    if (!trade.krakenOrderId) {\n      const [newTrade] = await db.insert(tradesTable).values(trade).returning();\n      return { inserted: true, trade: newTrade };\n    }\n    \n    // Verificar si existe\n    const existing = await this.getTradeByKrakenOrderId(trade.krakenOrderId);\n    if (existing) {\n      return { inserted: false, trade: existing };\n    }\n    \n    try {\n      const [newTrade] = await db.insert(tradesTable).values(trade).returning();\n      return { inserted: true, trade: newTrade };\n    } catch (e: any) {\n      // Handle unique constraint violation gracefully\n      if (e.code === '23505') {\n        return { inserted: false };\n      }\n      throw e;\n    }\n  }\n\n  // Obtener duplicados por krakenOrderId para limpieza\n  async getDuplicateTradesByKrakenId(): Promise<{ krakenOrderId: string; count: number; ids: number[] }[]> {\n    const result = await db.execute(sql`\n      SELECT kraken_order_id, COUNT(*) as count, ARRAY_AGG(id ORDER BY id) as ids\n      FROM trades\n      WHERE kraken_order_id IS NOT NULL\n      GROUP BY kraken_order_id\n      HAVING COUNT(*) > 1\n    `);\n    return (result.rows as any[]).map(row => ({\n      krakenOrderId: row.kraken_order_id,\n      count: parseInt(row.count),\n      ids: row.ids,\n    }));\n  }\n\n  // Eliminar duplicados manteniendo el mÃ¡s antiguo (menor id)\n  async deleteDuplicateTrades(): Promise<number> {\n    const duplicates = await this.getDuplicateTradesByKrakenId();\n    let deleted = 0;\n    \n    for (const dup of duplicates) {\n      // Mantener el primer id (mÃ¡s antiguo), eliminar el resto\n      const idsToDelete = dup.ids.slice(1);\n      for (const id of idsToDelete) {\n        await db.delete(tradesTable).where(eq(tradesTable.id, id));\n        deleted++;\n      }\n    }\n    \n    return deleted;\n  }\n\n  // Actualizar P&L de un trade\n  async updateTradePnl(id: number, entryPrice: string, realizedPnlUsd: string, realizedPnlPct: string): Promise<void> {\n    await db.update(tradesTable)\n      .set({ entryPrice, realizedPnlUsd, realizedPnlPct })\n      .where(eq(tradesTable.id, id));\n  }\n\n  // Obtener trades BUY sin emparejar para un par (para calcular P&L)\n  async getUnmatchedBuys(pair: string): Promise<Trade[]> {\n    return await db.select().from(tradesTable)\n      .where(and(\n        eq(tradesTable.pair, pair),\n        eq(tradesTable.type, 'buy'),\n        eq(tradesTable.status, 'filled')\n      ))\n      .orderBy(tradesTable.executedAt);\n  }\n\n  async getTrades(limit: number = 50): Promise<Trade[]> {\n    return await db.select().from(tradesTable).orderBy(desc(tradesTable.createdAt)).limit(limit);\n  }\n\n  async getClosedTrades(options: { limit?: number; offset?: number; pair?: string; result?: 'winner' | 'loser' | 'all'; type?: 'all' | 'buy' | 'sell' }): Promise<{ trades: Trade[]; total: number }> {\n    const { limit = 10, offset = 0, pair, result = 'all', type = 'all' } = options;\n    \n    const conditions: any[] = [];\n    \n    if (type !== 'all') {\n      conditions.push(eq(tradesTable.type, type));\n    }\n    \n    if (pair) {\n      conditions.push(eq(tradesTable.pair, pair));\n    }\n    \n    if (result === 'winner') {\n      conditions.push(gt(tradesTable.realizedPnlUsd, '0'));\n    } else if (result === 'loser') {\n      conditions.push(lt(tradesTable.realizedPnlUsd, '0'));\n    }\n    \n    const whereClause = conditions.length > 0 ? (conditions.length === 1 ? conditions[0] : and(...conditions)) : undefined;\n    \n    const tradesQuery = db.select().from(tradesTable)\n      .orderBy(desc(tradesTable.executedAt))\n      .limit(limit)\n      .offset(offset);\n    \n    const countQuery = db.select({ count: sql<number>`count(*)` }).from(tradesTable);\n    \n    const trades = whereClause ? await tradesQuery.where(whereClause) : await tradesQuery;\n    const countResult = whereClause ? await countQuery.where(whereClause) : await countQuery;\n    \n    return { trades, total: Number(countResult[0]?.count || 0) };\n  }\n\n  async updateTradeStatus(tradeId: string, status: string, krakenOrderId?: string): Promise<void> {\n    await db.update(tradesTable)\n      .set({ status, krakenOrderId, executedAt: new Date() })\n      .where(eq(tradesTable.tradeId, tradeId));\n  }\n\n  async getTradeByKrakenOrderId(krakenOrderId: string): Promise<Trade | undefined> {\n    const trades = await db.select().from(tradesTable)\n      .where(eq(tradesTable.krakenOrderId, krakenOrderId))\n      .limit(1);\n    return trades[0];\n  }\n\n  // B1: Update trade by krakenOrderId with partial patch\n  async updateTradeByKrakenOrderId(krakenOrderId: string, patch: Partial<InsertTrade>): Promise<Trade | undefined> {\n    if (!krakenOrderId) return undefined;\n    \n    const [updated] = await db.update(tradesTable)\n      .set(patch)\n      .where(eq(tradesTable.krakenOrderId, krakenOrderId))\n      .returning();\n    return updated;\n  }\n\n  // Check for duplicate trade by characteristics (pair + amount + type + timestamp within 60 seconds)\n  async findDuplicateTrade(pair: string, amount: string, type: string, executedAt: Date): Promise<Trade | undefined> {\n    const trades = await db.select().from(tradesTable)\n      .where(and(\n        eq(tradesTable.pair, pair),\n        eq(tradesTable.amount, amount),\n        eq(tradesTable.type, type),\n        sql`ABS(EXTRACT(EPOCH FROM (${tradesTable.executedAt} - ${executedAt}))) < 60`\n      ))\n      .limit(1);\n    return trades[0];\n  }\n\n  async getTradeByLotId(lotId: string): Promise<Trade | undefined> {\n    // lotId typically equals krakenOrderId for synced trades\n    const trades = await db.select().from(tradesTable)\n      .where(eq(tradesTable.krakenOrderId, lotId))\n      .limit(1);\n    return trades[0];\n  }\n\n  async getSellMatchingBuy(pair: string, buyLotId: string): Promise<Trade | undefined> {\n    // Find the BUY trade first to get its timestamp (case-insensitive)\n    const buyTrade = await db.select().from(tradesTable)\n      .where(and(\n        eq(tradesTable.krakenOrderId, buyLotId),\n        sql`UPPER(${tradesTable.type}) = 'BUY'`\n      ))\n      .limit(1);\n    \n    if (!buyTrade[0]) return undefined;\n    \n    // Find any SELL for the same pair that happened after this BUY (case-insensitive)\n    const sellTrades = await db.select().from(tradesTable)\n      .where(and(\n        eq(tradesTable.pair, pair),\n        sql`UPPER(${tradesTable.type}) = 'SELL'`,\n        gt(tradesTable.executedAt, buyTrade[0].executedAt!)\n      ))\n      .orderBy(tradesTable.executedAt)\n      .limit(1);\n    \n    return sellTrades[0];\n  }\n\n  async createNotification(notification: InsertNotification): Promise<Notification> {\n    const [newNotification] = await db.insert(notificationsTable).values(notification).returning();\n    return newNotification;\n  }\n\n  async getUnsentNotifications(): Promise<Notification[]> {\n    return await db.select().from(notificationsTable)\n      .where(eq(notificationsTable.telegramSent, false))\n      .orderBy(desc(notificationsTable.createdAt));\n  }\n\n  async markNotificationSent(id: number): Promise<void> {\n    await db.update(notificationsTable)\n      .set({ telegramSent: true, sentAt: new Date() })\n      .where(eq(notificationsTable.id, id));\n  }\n\n  async saveMarketData(data: InsertMarketData): Promise<MarketData> {\n    const [newData] = await db.insert(marketDataTable).values(data).returning();\n    return newData;\n  }\n\n  async getLatestMarketData(pair: string): Promise<MarketData | undefined> {\n    const data = await db.select().from(marketDataTable)\n      .where(eq(marketDataTable.pair, pair))\n      .orderBy(desc(marketDataTable.timestamp))\n      .limit(1);\n    return data[0];\n  }\n\n  async getTelegramChats(): Promise<TelegramChat[]> {\n    return await db.select().from(telegramChatsTable).orderBy(desc(telegramChatsTable.createdAt));\n  }\n\n  async getActiveTelegramChats(): Promise<TelegramChat[]> {\n    return await db.select().from(telegramChatsTable)\n      .where(eq(telegramChatsTable.isActive, true))\n      .orderBy(desc(telegramChatsTable.createdAt));\n  }\n\n  async getTelegramChatByChatId(chatId: string): Promise<TelegramChat | undefined> {\n    const chats = await db.select().from(telegramChatsTable)\n      .where(eq(telegramChatsTable.chatId, chatId))\n      .limit(1);\n    return chats[0];\n  }\n\n  async createTelegramChat(chat: InsertTelegramChat): Promise<TelegramChat> {\n    const [newChat] = await db.insert(telegramChatsTable).values(chat).returning();\n    return newChat;\n  }\n\n  async updateTelegramChat(id: number, chat: Partial<InsertTelegramChat>): Promise<TelegramChat> {\n    const [updated] = await db.update(telegramChatsTable)\n      .set(chat)\n      .where(eq(telegramChatsTable.id, id))\n      .returning();\n    return updated;\n  }\n\n  async deleteTelegramChat(id: number): Promise<void> {\n    await db.delete(telegramChatsTable).where(eq(telegramChatsTable.id, id));\n  }\n\n  async getOpenPositions(): Promise<OpenPosition[]> {\n    return await db.select().from(openPositionsTable);\n  }\n\n  async getOpenPosition(pair: string): Promise<OpenPosition | undefined> {\n    const positions = await db.select().from(openPositionsTable)\n      .where(eq(openPositionsTable.pair, pair))\n      .limit(1);\n    return positions[0];\n  }\n\n  async getOpenPositionByLotId(lotId: string): Promise<OpenPosition | undefined> {\n    const positions = await db.select().from(openPositionsTable)\n      .where(eq(openPositionsTable.lotId, lotId))\n      .limit(1);\n    return positions[0];\n  }\n\n  async getOpenPositionsByPair(pair: string): Promise<OpenPosition[]> {\n    return await db.select().from(openPositionsTable)\n      .where(eq(openPositionsTable.pair, pair));\n  }\n\n  async saveOpenPosition(position: InsertOpenPosition): Promise<OpenPosition> {\n    const existing = await this.getOpenPosition(position.pair);\n    if (existing) {\n      const [updated] = await db.update(openPositionsTable)\n        .set({ ...position, updatedAt: new Date() })\n        .where(eq(openPositionsTable.pair, position.pair))\n        .returning();\n      return updated;\n    }\n    const [newPosition] = await db.insert(openPositionsTable).values(position).returning();\n    return newPosition;\n  }\n\n  async saveOpenPositionByLotId(position: InsertOpenPosition): Promise<OpenPosition> {\n    if (!position.lotId) {\n      throw new Error(\"lotId is required for saveOpenPositionByLotId\");\n    }\n    const existing = await this.getOpenPositionByLotId(position.lotId);\n    if (existing) {\n      const [updated] = await db.update(openPositionsTable)\n        .set({ ...position, updatedAt: new Date() })\n        .where(eq(openPositionsTable.lotId, position.lotId))\n        .returning();\n      return updated;\n    }\n    const [newPosition] = await db.insert(openPositionsTable).values(position).returning();\n    return newPosition;\n  }\n\n  async updateOpenPosition(pair: string, updates: Partial<InsertOpenPosition>): Promise<OpenPosition | undefined> {\n    const [updated] = await db.update(openPositionsTable)\n      .set({ ...updates, updatedAt: new Date() })\n      .where(eq(openPositionsTable.pair, pair))\n      .returning();\n    return updated;\n  }\n\n  async updateOpenPositionByLotId(lotId: string, updates: Partial<InsertOpenPosition>): Promise<OpenPosition | undefined> {\n    const [updated] = await db.update(openPositionsTable)\n      .set({ ...updates, updatedAt: new Date() })\n      .where(eq(openPositionsTable.lotId, lotId))\n      .returning();\n    return updated;\n  }\n\n  async updateOpenPositionLotId(id: number, lotId: string): Promise<void> {\n    await db.update(openPositionsTable)\n      .set({ lotId, updatedAt: new Date() })\n      .where(eq(openPositionsTable.id, id));\n  }\n\n  async deleteOpenPosition(pair: string): Promise<void> {\n    await db.delete(openPositionsTable).where(eq(openPositionsTable.pair, pair));\n  }\n\n  async deleteOpenPositionByLotId(lotId: string): Promise<void> {\n    await db.delete(openPositionsTable).where(eq(openPositionsTable.lotId, lotId));\n  }\n\n  async getOpenPositionsWithQtyRemaining(): Promise<OpenPosition[]> {\n    // Returns only positions with qtyRemaining > 0 (or null which means not yet initialized)\n    return await db.select().from(openPositionsTable)\n      .where(sql`${openPositionsTable.qtyRemaining} > 0 OR ${openPositionsTable.qtyRemaining} IS NULL`)\n      .orderBy(openPositionsTable.openedAt);\n  }\n\n  async updateOpenPositionQty(lotId: string, qtyRemaining: string, qtyFilled: string): Promise<void> {\n    await db.update(openPositionsTable)\n      .set({ qtyRemaining, qtyFilled, updatedAt: new Date() })\n      .where(eq(openPositionsTable.lotId, lotId));\n  }\n\n  async initializeQtyRemainingForAll(): Promise<number> {\n    // Initialize qtyRemaining = amount for all positions where qtyRemaining is null\n    const result = await db.execute(sql`\n      UPDATE open_positions \n      SET qty_remaining = amount, qty_filled = '0'\n      WHERE qty_remaining IS NULL\n    `);\n    return Number(result.rowCount || 0);\n  }\n\n  // Trade fills\n  async upsertTradeFill(fill: InsertTradeFill): Promise<{ inserted: boolean; fill?: TradeFill }> {\n    const existing = await this.getTradeFillByTxid(fill.txid);\n    if (existing) {\n      return { inserted: false, fill: existing };\n    }\n    try {\n      const [newFill] = await db.insert(tradeFillsTable).values(fill).returning();\n      return { inserted: true, fill: newFill };\n    } catch (error: any) {\n      if (error.code === '23505') { // Unique violation\n        const existingFill = await this.getTradeFillByTxid(fill.txid);\n        return { inserted: false, fill: existingFill };\n      }\n      throw error;\n    }\n  }\n\n  async getTradeFillByTxid(txid: string): Promise<TradeFill | undefined> {\n    const fills = await db.select().from(tradeFillsTable)\n      .where(eq(tradeFillsTable.txid, txid))\n      .limit(1);\n    return fills[0];\n  }\n\n  async getUnmatchedSellFills(pair: string): Promise<TradeFill[]> {\n    return await db.select().from(tradeFillsTable)\n      .where(and(\n        eq(tradeFillsTable.pair, pair),\n        sql`UPPER(${tradeFillsTable.type}) = 'SELL'`,\n        eq(tradeFillsTable.matched, false)\n      ))\n      .orderBy(tradeFillsTable.executedAt);\n  }\n\n  async markFillAsMatched(txid: string): Promise<void> {\n    await db.update(tradeFillsTable)\n      .set({ matched: true })\n      .where(eq(tradeFillsTable.txid, txid));\n  }\n\n  // Lot matches\n  async createLotMatch(match: InsertLotMatch): Promise<LotMatch> {\n    try {\n      const [newMatch] = await db.insert(lotMatchesTable).values(match).returning();\n      return newMatch;\n    } catch (error: any) {\n      if (error.code === '23505') { // Unique violation - already exists\n        const existing = await this.getLotMatchBySellFillAndLot(match.sellFillTxid, match.lotId);\n        if (existing) return existing;\n      }\n      throw error;\n    }\n  }\n\n  async getLotMatchesByLotId(lotId: string): Promise<LotMatch[]> {\n    return await db.select().from(lotMatchesTable)\n      .where(eq(lotMatchesTable.lotId, lotId))\n      .orderBy(lotMatchesTable.createdAt);\n  }\n\n  async getLotMatchBySellFillAndLot(sellFillTxid: string, lotId: string): Promise<LotMatch | undefined> {\n    const matches = await db.select().from(lotMatchesTable)\n      .where(and(\n        eq(lotMatchesTable.sellFillTxid, sellFillTxid),\n        eq(lotMatchesTable.lotId, lotId)\n      ))\n      .limit(1);\n    return matches[0];\n  }\n\n  async saveAiSample(sample: InsertAiTradeSample): Promise<AiTradeSample> {\n    const [newSample] = await db.insert(aiTradeSamplesTable).values(sample).returning();\n    return newSample;\n  }\n\n  async updateAiSample(sampleId: number, updates: Partial<InsertAiTradeSample>): Promise<AiTradeSample | undefined> {\n    const [updated] = await db.update(aiTradeSamplesTable)\n      .set(updates)\n      .where(eq(aiTradeSamplesTable.id, sampleId))\n      .returning();\n    return updated;\n  }\n\n  async getAiSamples(options?: { complete?: boolean; limit?: number }): Promise<AiTradeSample[]> {\n    const { complete, limit = 1000 } = options || {};\n    if (complete !== undefined) {\n      return await db.select().from(aiTradeSamplesTable)\n        .where(eq(aiTradeSamplesTable.isComplete, complete))\n        .orderBy(desc(aiTradeSamplesTable.createdAt))\n        .limit(limit);\n    }\n    return await db.select().from(aiTradeSamplesTable)\n      .orderBy(desc(aiTradeSamplesTable.createdAt))\n      .limit(limit);\n  }\n\n  async getAiSamplesCount(complete?: boolean): Promise<number> {\n    if (complete !== undefined) {\n      const result = await db.select({ count: sql<number>`count(*)` })\n        .from(aiTradeSamplesTable)\n        .where(eq(aiTradeSamplesTable.isComplete, complete));\n      return Number(result[0]?.count || 0);\n    }\n    const result = await db.select({ count: sql<number>`count(*)` }).from(aiTradeSamplesTable);\n    return Number(result[0]?.count || 0);\n  }\n\n  async saveAiShadowDecision(decision: InsertAiShadowDecision): Promise<AiShadowDecision> {\n    const [newDecision] = await db.insert(aiShadowDecisionsTable).values(decision).returning();\n    return newDecision;\n  }\n\n  async updateAiShadowFinalPnl(tradeId: string, pnl: string): Promise<void> {\n    await db.update(aiShadowDecisionsTable)\n      .set({ finalPnlNet: pnl })\n      .where(eq(aiShadowDecisionsTable.tradeId, tradeId));\n  }\n\n  async getAiShadowReport(): Promise<{ total: number; blocked: number; blockedLosers: number; passedLosers: number }> {\n    const allDecisions = await db.select().from(aiShadowDecisionsTable)\n      .where(sql`${aiShadowDecisionsTable.finalPnlNet} IS NOT NULL`);\n    \n    const total = allDecisions.length;\n    const blocked = allDecisions.filter(d => d.wouldBlock).length;\n    const blockedLosers = allDecisions.filter(d => d.wouldBlock && parseFloat(d.finalPnlNet || '0') < 0).length;\n    const passedLosers = allDecisions.filter(d => !d.wouldBlock && parseFloat(d.finalPnlNet || '0') < 0).length;\n    \n    return { total, blocked, blockedLosers, passedLosers };\n  }\n\n  async getAiConfig(): Promise<AiConfig | undefined> {\n    const configs = await db.select().from(aiConfigTable).limit(1);\n    if (configs.length === 0) {\n      const [newConfig] = await db.insert(aiConfigTable).values({}).returning();\n      return newConfig;\n    }\n    return configs[0];\n  }\n\n  async updateAiConfig(config: Partial<InsertAiConfig>): Promise<AiConfig> {\n    const existing = await this.getAiConfig();\n    if (!existing) {\n      const [newConfig] = await db.insert(aiConfigTable).values(config as InsertAiConfig).returning();\n      return newConfig;\n    }\n    const [updated] = await db.update(aiConfigTable)\n      .set({ ...config, updatedAt: new Date() })\n      .where(eq(aiConfigTable.id, existing.id))\n      .returning();\n    return updated;\n  }\n\n  async saveTrainingTrade(trade: InsertTrainingTrade): Promise<TrainingTrade> {\n    const [newTrade] = await db.insert(trainingTradesTable).values(trade).returning();\n    return newTrade;\n  }\n\n  async updateTrainingTrade(id: number, updates: Partial<InsertTrainingTrade>): Promise<TrainingTrade | undefined> {\n    const [updated] = await db.update(trainingTradesTable)\n      .set(updates)\n      .where(eq(trainingTradesTable.id, id))\n      .returning();\n    return updated;\n  }\n\n  async getTrainingTradeByBuyTxid(buyTxid: string): Promise<TrainingTrade | undefined> {\n    const trades = await db.select().from(trainingTradesTable)\n      .where(eq(trainingTradesTable.buyTxid, buyTxid))\n      .limit(1);\n    return trades[0];\n  }\n\n  // Obtener duplicados por buyTxid para limpieza de training_trades\n  async getDuplicateTrainingTradesByBuyTxid(): Promise<{ buyTxid: string; count: number; ids: number[] }[]> {\n    const result = await db.execute(sql`\n      SELECT buy_txid, COUNT(*) as count, ARRAY_AGG(id ORDER BY id) as ids\n      FROM training_trades\n      GROUP BY buy_txid\n      HAVING COUNT(*) > 1\n    `);\n    return (result.rows as any[]).map(row => ({\n      buyTxid: row.buy_txid,\n      count: parseInt(row.count),\n      ids: row.ids,\n    }));\n  }\n\n  // Eliminar duplicados en training_trades manteniendo el mÃ¡s antiguo\n  async deleteDuplicateTrainingTrades(): Promise<number> {\n    const duplicates = await this.getDuplicateTrainingTradesByBuyTxid();\n    let deleted = 0;\n    \n    for (const dup of duplicates) {\n      const idsToDelete = dup.ids.slice(1);\n      for (const id of idsToDelete) {\n        await db.delete(trainingTradesTable).where(eq(trainingTradesTable.id, id));\n        deleted++;\n      }\n    }\n    \n    return deleted;\n  }\n\n  async getTrainingTrades(options?: { closed?: boolean; labeled?: boolean; limit?: number }): Promise<TrainingTrade[]> {\n    const { closed, labeled, limit = 1000 } = options || {};\n    const conditions: any[] = [];\n    \n    if (closed !== undefined) {\n      conditions.push(eq(trainingTradesTable.isClosed, closed));\n    }\n    if (labeled !== undefined) {\n      conditions.push(eq(trainingTradesTable.isLabeled, labeled));\n    }\n    \n    const whereClause = conditions.length > 0 \n      ? (conditions.length === 1 ? conditions[0] : and(...conditions)) \n      : undefined;\n    \n    const query = db.select().from(trainingTradesTable)\n      .orderBy(desc(trainingTradesTable.entryTs))\n      .limit(limit);\n    \n    return whereClause ? await query.where(whereClause) : await query;\n  }\n\n  async getTrainingTradesCount(options?: { closed?: boolean; labeled?: boolean; hasOpenLots?: boolean }): Promise<number> {\n    const { closed, labeled, hasOpenLots } = options || {};\n    const conditions: any[] = [];\n    \n    if (closed !== undefined) {\n      conditions.push(eq(trainingTradesTable.isClosed, closed));\n    }\n    if (labeled !== undefined) {\n      conditions.push(eq(trainingTradesTable.isLabeled, labeled));\n    }\n    if (hasOpenLots === true) {\n      conditions.push(sql`${trainingTradesTable.qtyRemaining} > 0`);\n    }\n    \n    const whereClause = conditions.length > 0 \n      ? (conditions.length === 1 ? conditions[0] : and(...conditions)) \n      : undefined;\n    \n    const query = db.select({ count: sql<number>`count(*)` }).from(trainingTradesTable);\n    const result = whereClause ? await query.where(whereClause) : await query;\n    return Number(result[0]?.count || 0);\n  }\n\n  async getDiscardReasonsDataset(): Promise<Record<string, number>> {\n    const result = await db.select({\n      discardReason: trainingTradesTable.discardReason,\n      count: sql<number>`count(*)`,\n    })\n    .from(trainingTradesTable)\n    .where(sql`${trainingTradesTable.discardReason} IS NOT NULL`)\n    .groupBy(trainingTradesTable.discardReason);\n    \n    const reasons: Record<string, number> = {};\n    for (const row of result) {\n      if (row.discardReason) {\n        reasons[row.discardReason] = Number(row.count);\n      }\n    }\n    return reasons;\n  }\n\n  async getAllTradesForBackfill(): Promise<Trade[]> {\n    return await db.select().from(tradesTable)\n      .where(eq(tradesTable.status, 'filled'))\n      .orderBy(tradesTable.executedAt);\n  }\n\n  async runTrainingTradesBackfill(): Promise<{ created: number; closed: number; labeled: number; discardReasons: Record<string, number> }> {\n    const allTrades = await this.getAllTradesForBackfill();\n    const discardReasons: Record<string, number> = {};\n    let created = 0;\n    let closed = 0;\n    let labeled = 0;\n    \n    const KRAKEN_FEE_RATE = 0.004;\n    const PNL_OUTLIER_THRESHOLD = 100; // Increased from 50% - crypto is volatile\n    const MAX_HOLD_TIME_DAYS = 30;\n    const MIN_FEE_PCT = 0.1; // Lowered from 0.5% - discount tiers exist\n    const MAX_FEE_PCT = 2.5; // Raised from 2.0% - allow for spread costs\n    const QTY_EPSILON = 0.00000001;\n    \n    const tradesByPair: Record<string, Trade[]> = {};\n    for (const trade of allTrades) {\n      if (!tradesByPair[trade.pair]) tradesByPair[trade.pair] = [];\n      tradesByPair[trade.pair].push(trade);\n    }\n    \n    for (const pair of Object.keys(tradesByPair)) {\n      // OrdenaciÃ³n estable FIFO: timestamp + id (tie-breaker determinista)\n      const pairTrades = tradesByPair[pair].sort((a, b) => {\n        const timeA = a.executedAt ? new Date(a.executedAt).getTime() : 0;\n        const timeB = b.executedAt ? new Date(b.executedAt).getTime() : 0;\n        if (timeA !== timeB) return timeA - timeB;\n        // Tie-breaker: ID de base de datos (determinista)\n        return a.id - b.id;\n      });\n      \n      interface OpenLot {\n        dbId: number | null;\n        buyTxid: string;\n        entryPrice: number;\n        entryAmount: number;\n        qtyRemaining: number;\n        entryTs: Date;\n        costUsd: number;\n        entryFee: number;\n        sellTxids: string[];\n        totalRevenue: number;\n        totalExitFee: number;\n        lastSellTs: Date | null;\n        lastSellPrice: number;\n      }\n      \n      const openLots: OpenLot[] = [];\n      \n      for (const trade of pairTrades) {\n        const tradeTime = trade.executedAt ? new Date(trade.executedAt) : null;\n        const tradeAmount = parseFloat(trade.amount || '0');\n        const tradePrice = parseFloat(trade.price || '0');\n        const tradeTxid = trade.krakenOrderId || trade.tradeId;\n        \n        if (!tradeTime) {\n          discardReasons['sin_fecha_ejecucion'] = (discardReasons['sin_fecha_ejecucion'] || 0) + 1;\n          continue;\n        }\n        \n        if (tradeAmount <= 0 || tradePrice <= 0) {\n          discardReasons['datos_invalidos'] = (discardReasons['datos_invalidos'] || 0) + 1;\n          continue;\n        }\n        \n        if (trade.type === 'buy') {\n          const existing = await this.getTrainingTradeByBuyTxid(tradeTxid);\n          if (existing) {\n            const qtyRem = parseFloat(existing.qtyRemaining || existing.entryAmount || '0');\n            \n            // Si ya estÃ¡ cerrado y etiquetado/descartado, es inmutable - no reprocesar\n            if (existing.isClosed && qtyRem <= QTY_EPSILON) {\n              // Trade ya procesado completamente - skip sin modificar\n              continue;\n            }\n            \n            // Solo aÃ±adir a openLots si tiene cantidad restante para procesar\n            if (qtyRem > QTY_EPSILON) {\n              openLots.push({\n                dbId: existing.id,\n                buyTxid: tradeTxid,\n                entryPrice: parseFloat(existing.entryPrice),\n                entryAmount: parseFloat(existing.entryAmount),\n                qtyRemaining: qtyRem,\n                entryTs: new Date(existing.entryTs),\n                costUsd: parseFloat(existing.costUsd),\n                entryFee: parseFloat(existing.entryFee || '0'),\n                sellTxids: (existing.sellTxidsJson as string[]) || [],\n                totalRevenue: parseFloat(existing.revenueUsd || '0'),\n                totalExitFee: parseFloat(existing.exitFee || '0'),\n                lastSellTs: existing.exitTs ? new Date(existing.exitTs) : null,\n                lastSellPrice: parseFloat(existing.exitPrice || '0'),\n              });\n            }\n            continue;\n          }\n          \n          const buyCost = tradeAmount * tradePrice;\n          const entryFee = buyCost * KRAKEN_FEE_RATE;\n          \n          const trainingTrade: InsertTrainingTrade = {\n            pair,\n            buyTxid: tradeTxid,\n            entryPrice: trade.price,\n            entryAmount: trade.amount,\n            qtyRemaining: trade.amount,\n            costUsd: buyCost.toFixed(8),\n            entryFee: entryFee.toFixed(8),\n            entryTs: tradeTime,\n            sellTxidsJson: [],\n            isClosed: false,\n            isLabeled: false,\n          };\n          \n          const saved = await this.saveTrainingTrade(trainingTrade);\n          created++;\n          \n          openLots.push({\n            dbId: saved.id,\n            buyTxid: tradeTxid,\n            entryPrice: tradePrice,\n            entryAmount: tradeAmount,\n            qtyRemaining: tradeAmount,\n            entryTs: tradeTime,\n            costUsd: buyCost,\n            entryFee,\n            sellTxids: [],\n            totalRevenue: 0,\n            totalExitFee: 0,\n            lastSellTs: null,\n            lastSellPrice: 0,\n          });\n          \n        } else if (trade.type === 'sell') {\n          let remainingToSell = tradeAmount;\n          const sellPrice = tradePrice;\n          const sellTime = tradeTime;\n          \n          if (openLots.length === 0) {\n            discardReasons['venta_sin_compra_previa'] = (discardReasons['venta_sin_compra_previa'] || 0) + 1;\n            continue;\n          }\n          \n          while (remainingToSell > QTY_EPSILON && openLots.length > 0) {\n            const lot = openLots[0];\n            const consumeQty = Math.min(remainingToSell, lot.qtyRemaining);\n            const proportion = consumeQty / lot.entryAmount;\n            const sellRevenue = consumeQty * sellPrice;\n            const sellFee = sellRevenue * KRAKEN_FEE_RATE;\n            \n            lot.qtyRemaining -= consumeQty;\n            remainingToSell -= consumeQty;\n            lot.sellTxids.push(tradeTxid);\n            lot.totalRevenue += sellRevenue;\n            lot.totalExitFee += sellFee;\n            lot.lastSellTs = sellTime;\n            lot.lastSellPrice = sellPrice;\n            \n            if (lot.qtyRemaining <= QTY_EPSILON) {\n              const pnlGross = lot.totalRevenue - lot.costUsd;\n              const pnlNet = pnlGross - lot.entryFee - lot.totalExitFee;\n              const pnlPct = (pnlNet / lot.costUsd) * 100;\n              const holdTimeMinutes = Math.round((lot.lastSellTs!.getTime() - lot.entryTs.getTime()) / 60000);\n              \n              let discardReason: string | null = null;\n              \n              const totalFeePct = ((lot.entryFee + lot.totalExitFee) / lot.costUsd) * 100;\n              if (totalFeePct > MAX_FEE_PCT || totalFeePct < MIN_FEE_PCT) {\n                discardReason = 'comisiones_anormales';\n              } else if (Math.abs(pnlPct) > PNL_OUTLIER_THRESHOLD) {\n                discardReason = 'pnl_atipico';\n              } else if (holdTimeMinutes / (60 * 24) > MAX_HOLD_TIME_DAYS) {\n                discardReason = 'hold_excesivo';\n              } else if (holdTimeMinutes < 0) {\n                discardReason = 'timestamps_invalidos';\n              }\n              \n              if (discardReason) {\n                discardReasons[discardReason] = (discardReasons[discardReason] || 0) + 1;\n              }\n              \n              const avgExitPrice = lot.totalRevenue / lot.entryAmount;\n              \n              await this.updateTrainingTrade(lot.dbId!, {\n                sellTxid: lot.sellTxids[lot.sellTxids.length - 1],\n                sellTxidsJson: lot.sellTxids,\n                exitPrice: avgExitPrice.toFixed(8),\n                exitAmount: lot.entryAmount.toFixed(8),\n                qtyRemaining: '0',\n                revenueUsd: lot.totalRevenue.toFixed(8),\n                exitFee: lot.totalExitFee.toFixed(8),\n                pnlGross: pnlGross.toFixed(8),\n                pnlNet: pnlNet.toFixed(8),\n                pnlPct: pnlPct.toFixed(4),\n                holdTimeMinutes,\n                labelWin: discardReason ? undefined : (pnlNet > 0 ? 1 : 0),\n                exitTs: lot.lastSellTs!,\n                isClosed: true,\n                isLabeled: discardReason ? false : true,\n                discardReason: discardReason || undefined,\n              });\n              \n              closed++;\n              if (!discardReason) labeled++;\n              \n              openLots.shift();\n            } else {\n              await this.updateTrainingTrade(lot.dbId!, {\n                qtyRemaining: lot.qtyRemaining.toFixed(8),\n                sellTxidsJson: lot.sellTxids,\n              });\n            }\n          }\n          \n          if (remainingToSell > QTY_EPSILON) {\n            discardReasons['venta_excede_lotes'] = (discardReasons['venta_excede_lotes'] || 0) + 1;\n          }\n        }\n      }\n      \n      for (const lot of openLots) {\n        if (lot.qtyRemaining > QTY_EPSILON && lot.qtyRemaining < lot.entryAmount) {\n          await this.updateTrainingTrade(lot.dbId!, {\n            qtyRemaining: lot.qtyRemaining.toFixed(8),\n            sellTxidsJson: lot.sellTxids,\n          });\n        }\n      }\n    }\n    \n    // Invariance check: if qtyRemaining <= epsilon then normalize to 0 and ensure isClosed=true\n    const allTrainingTrades = await db.select().from(trainingTradesTable);\n    for (const trade of allTrainingTrades) {\n      const qty = parseFloat(trade.qtyRemaining || trade.entryAmount || '0');\n      if (qty <= QTY_EPSILON && qty > 0) {\n        // Normalize tiny residuals to exactly 0\n        await this.updateTrainingTrade(trade.id, { qtyRemaining: '0', isClosed: true });\n      } else if (qty <= QTY_EPSILON && !trade.isClosed) {\n        // qty is already 0 but isClosed is false - fix invariance\n        await this.updateTrainingTrade(trade.id, { isClosed: true });\n      }\n    }\n    \n    return { created, closed, labeled, discardReasons };\n  }\n\n  async checkSchemaHealth(): Promise<{ healthy: boolean; missingColumns: string[]; migrationRan: boolean }> {\n    const missingColumns: string[] = [];\n    \n    // Check required columns in bot_config table\n    const requiredBotConfigColumns = [\n      { column: 'sg_max_open_lots_per_pair', table: 'bot_config' },\n      { column: 'sg_pair_overrides', table: 'bot_config' },\n      { column: 'dry_run_mode', table: 'bot_config' },\n      { column: 'sg_min_entry_usd', table: 'bot_config' },\n      { column: 'sg_allow_under_min', table: 'bot_config' },\n      { column: 'sg_be_at_pct', table: 'bot_config' },\n      { column: 'sg_trail_start_pct', table: 'bot_config' },\n      { column: 'sg_trail_distance_pct', table: 'bot_config' },\n      { column: 'sg_trail_step_pct', table: 'bot_config' },\n      { column: 'sg_tp_fixed_enabled', table: 'bot_config' },\n      { column: 'sg_tp_fixed_pct', table: 'bot_config' },\n      { column: 'sg_scale_out_enabled', table: 'bot_config' },\n      { column: 'sg_scale_out_pct', table: 'bot_config' },\n      { column: 'sg_min_part_usd', table: 'bot_config' },\n      { column: 'sg_scale_out_threshold', table: 'bot_config' },\n      { column: 'sg_fee_cushion_pct', table: 'bot_config' },\n      { column: 'sg_fee_cushion_auto', table: 'bot_config' },\n    ];\n    \n    const requiredOpenPositionsColumns = [\n      { column: 'lot_id', table: 'open_positions' },\n      { column: 'sg_break_even_activated', table: 'open_positions' },\n      { column: 'sg_trailing_activated', table: 'open_positions' },\n      { column: 'sg_current_stop_price', table: 'open_positions' },\n      { column: 'sg_scale_out_done', table: 'open_positions' },\n      { column: 'config_snapshot_json', table: 'open_positions' },\n    ];\n    \n    const allRequiredColumns = [...requiredBotConfigColumns, ...requiredOpenPositionsColumns];\n    \n    // Health check ONLY reports status - does NOT auto-migrate\n    // Migration should be run by script/migrate.ts (Docker startup) or manually\n    // This ensures the migration flow has a single source of truth\n    for (const { column, table } of allRequiredColumns) {\n      const result = await db.execute(sql`\n        SELECT column_name FROM information_schema.columns \n        WHERE table_name = ${table} AND column_name = ${column}\n      `);\n      if (result.rows.length === 0) {\n        missingColumns.push(`${table}.${column}`);\n      }\n    }\n    \n    if (missingColumns.length > 0) {\n      console.warn(`[schema] Health check: missing columns detected: ${missingColumns.join(', ')}`);\n      console.warn('[schema] Run \"npx tsx script/migrate.ts\" to fix schema issues');\n    }\n    \n    return { healthy: missingColumns.length === 0, missingColumns, migrationRan: false };\n  }\n\n  async runSchemaMigration(): Promise<{ success: boolean; columnsAdded: string[]; error?: string }> {\n    const columnsAdded: string[] = [];\n    \n    try {\n      // Define all migrations with safe ADD COLUMN IF NOT EXISTS\n      const migrations = [\n        // bot_config columns\n        { table: 'bot_config', column: 'sg_max_open_lots_per_pair', sql: 'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_max_open_lots_per_pair INTEGER DEFAULT 1' },\n        { table: 'bot_config', column: 'sg_pair_overrides', sql: 'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_pair_overrides JSONB' },\n        { table: 'bot_config', column: 'dry_run_mode', sql: 'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS dry_run_mode BOOLEAN DEFAULT false' },\n        { table: 'bot_config', column: 'sg_min_entry_usd', sql: 'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_min_entry_usd DECIMAL(10,2) DEFAULT 100.00' },\n        { table: 'bot_config', column: 'sg_allow_under_min', sql: 'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_allow_under_min BOOLEAN DEFAULT true' },\n        { table: 'bot_config', column: 'sg_be_at_pct', sql: 'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_be_at_pct DECIMAL(5,2) DEFAULT 1.50' },\n        { table: 'bot_config', column: 'sg_trail_start_pct', sql: 'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_trail_start_pct DECIMAL(5,2) DEFAULT 2.00' },\n        { table: 'bot_config', column: 'sg_trail_distance_pct', sql: 'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_trail_distance_pct DECIMAL(5,2) DEFAULT 1.50' },\n        { table: 'bot_config', column: 'sg_trail_step_pct', sql: 'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_trail_step_pct DECIMAL(5,2) DEFAULT 0.25' },\n        { table: 'bot_config', column: 'sg_tp_fixed_enabled', sql: 'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_tp_fixed_enabled BOOLEAN DEFAULT false' },\n        { table: 'bot_config', column: 'sg_tp_fixed_pct', sql: 'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_tp_fixed_pct DECIMAL(5,2) DEFAULT 10.00' },\n        { table: 'bot_config', column: 'sg_scale_out_enabled', sql: 'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_scale_out_enabled BOOLEAN DEFAULT false' },\n        { table: 'bot_config', column: 'sg_scale_out_pct', sql: 'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_scale_out_pct DECIMAL(5,2) DEFAULT 35.00' },\n        { table: 'bot_config', column: 'sg_min_part_usd', sql: 'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_min_part_usd DECIMAL(10,2) DEFAULT 50.00' },\n        { table: 'bot_config', column: 'sg_scale_out_threshold', sql: 'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_scale_out_threshold DECIMAL(5,2) DEFAULT 80.00' },\n        { table: 'bot_config', column: 'sg_fee_cushion_pct', sql: 'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_fee_cushion_pct DECIMAL(5,2) DEFAULT 0.45' },\n        { table: 'bot_config', column: 'sg_fee_cushion_auto', sql: 'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_fee_cushion_auto BOOLEAN DEFAULT true' },\n        \n        // open_positions columns\n        { table: 'open_positions', column: 'lot_id', sql: 'ALTER TABLE open_positions ADD COLUMN IF NOT EXISTS lot_id TEXT' },\n        { table: 'open_positions', column: 'sg_break_even_activated', sql: 'ALTER TABLE open_positions ADD COLUMN IF NOT EXISTS sg_break_even_activated BOOLEAN DEFAULT false' },\n        { table: 'open_positions', column: 'sg_trailing_activated', sql: 'ALTER TABLE open_positions ADD COLUMN IF NOT EXISTS sg_trailing_activated BOOLEAN DEFAULT false' },\n        { table: 'open_positions', column: 'sg_current_stop_price', sql: 'ALTER TABLE open_positions ADD COLUMN IF NOT EXISTS sg_current_stop_price DECIMAL(18,8)' },\n        { table: 'open_positions', column: 'sg_scale_out_done', sql: 'ALTER TABLE open_positions ADD COLUMN IF NOT EXISTS sg_scale_out_done BOOLEAN DEFAULT false' },\n        { table: 'open_positions', column: 'config_snapshot_json', sql: 'ALTER TABLE open_positions ADD COLUMN IF NOT EXISTS config_snapshot_json JSONB' },\n      ];\n      \n      for (const migration of migrations) {\n        try {\n          await db.execute(sql.raw(migration.sql));\n          columnsAdded.push(`${migration.table}.${migration.column}`);\n        } catch (e) {\n          // Column may already exist, continue\n        }\n      }\n      \n      // Backfill lot_id for existing positions without it\n      try {\n        await db.execute(sql`\n          UPDATE open_positions \n          SET lot_id = 'LEGACY-' || id::text || '-' || SUBSTRING(MD5(pair || opened_at::text) FROM 1 FOR 6)\n          WHERE lot_id IS NULL\n        `);\n        \n        // Add unique constraint if not exists (safe: only if all lot_ids are unique)\n        const duplicates = await db.execute(sql`\n          SELECT lot_id, COUNT(*) FROM open_positions WHERE lot_id IS NOT NULL GROUP BY lot_id HAVING COUNT(*) > 1\n        `);\n        if (duplicates.rows.length === 0) {\n          try {\n            await db.execute(sql`\n              ALTER TABLE open_positions ADD CONSTRAINT open_positions_lot_id_unique UNIQUE (lot_id)\n            `);\n          } catch (e) {\n            // Constraint may already exist\n          }\n        }\n      } catch (e) {\n        console.log('[schema] lot_id backfill note:', e);\n      }\n      \n      console.log(`[schema] Migration completed. Columns added: ${columnsAdded.join(', ') || 'none (all exist)'}`);\n      return { success: true, columnsAdded };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      console.error('[schema] Migration failed:', errorMessage);\n      return { success: false, columnsAdded, error: errorMessage };\n    }\n  }\n}\n\nexport const storage = new DatabaseStorage();\n","path":null,"size_bytes":50679,"size_tokens":null},"client/src/pages/not-found.tsx":{"content":"import { Card, CardContent } from \"@/components/ui/card\";\nimport { AlertCircle } from \"lucide-react\";\n\nexport default function NotFound() {\n  return (\n    <div className=\"min-h-screen w-full flex items-center justify-center bg-gray-50\">\n      <Card className=\"w-full max-w-md mx-4\">\n        <CardContent className=\"pt-6\">\n          <div className=\"flex mb-4 gap-2\">\n            <AlertCircle className=\"h-8 w-8 text-red-500\" />\n            <h1 className=\"text-2xl font-bold text-gray-900\">404 Page Not Found</h1>\n          </div>\n\n          <p className=\"mt-4 text-sm text-gray-600\">\n            Did you forget to add the page to the router?\n          </p>\n        </CardContent>\n      </Card>\n    </div>\n  );\n}\n","path":null,"size_bytes":711,"size_tokens":null},"client/src/components/ui/input-group.tsx":{"content":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\nimport { Input } from \"@/components/ui/input\"\nimport { Textarea } from \"@/components/ui/textarea\"\n\nfunction InputGroup({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"input-group\"\n      role=\"group\"\n      className={cn(\n        \"group/input-group border-input dark:bg-input/30 shadow-xs relative flex w-full items-center rounded-md border outline-none transition-[color,box-shadow]\",\n        \"h-9 has-[>textarea]:h-auto\",\n\n        // Variants based on alignment.\n        \"has-[>[data-align=inline-start]]:[&>input]:pl-2\",\n        \"has-[>[data-align=inline-end]]:[&>input]:pr-2\",\n        \"has-[>[data-align=block-start]]:h-auto has-[>[data-align=block-start]]:flex-col has-[>[data-align=block-start]]:[&>input]:pb-3\",\n        \"has-[>[data-align=block-end]]:h-auto has-[>[data-align=block-end]]:flex-col has-[>[data-align=block-end]]:[&>input]:pt-3\",\n\n        // Focus state.\n        \"has-[[data-slot=input-group-control]:focus-visible]:ring-ring has-[[data-slot=input-group-control]:focus-visible]:ring-1\",\n\n        // Error state.\n        \"has-[[data-slot][aria-invalid=true]]:ring-destructive/20 has-[[data-slot][aria-invalid=true]]:border-destructive dark:has-[[data-slot][aria-invalid=true]]:ring-destructive/40\",\n\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nconst inputGroupAddonVariants = cva(\n  \"text-muted-foreground flex h-auto cursor-text select-none items-center justify-center gap-2 py-1.5 text-sm font-medium group-data-[disabled=true]/input-group:opacity-50 [&>kbd]:rounded-[calc(var(--radius)-5px)] [&>svg:not([class*='size-'])]:size-4\",\n  {\n    variants: {\n      align: {\n        \"inline-start\":\n          \"order-first pl-3 has-[>button]:ml-[-0.45rem] has-[>kbd]:ml-[-0.35rem]\",\n        \"inline-end\":\n          \"order-last pr-3 has-[>button]:mr-[-0.4rem] has-[>kbd]:mr-[-0.35rem]\",\n        \"block-start\":\n          \"[.border-b]:pb-3 order-first w-full justify-start px-3 pt-3 group-has-[>input]/input-group:pt-2.5\",\n        \"block-end\":\n          \"[.border-t]:pt-3 order-last w-full justify-start px-3 pb-3 group-has-[>input]/input-group:pb-2.5\",\n      },\n    },\n    defaultVariants: {\n      align: \"inline-start\",\n    },\n  }\n)\n\nfunction InputGroupAddon({\n  className,\n  align = \"inline-start\",\n  ...props\n}: React.ComponentProps<\"div\"> & VariantProps<typeof inputGroupAddonVariants>) {\n  return (\n    <div\n      role=\"group\"\n      data-slot=\"input-group-addon\"\n      data-align={align}\n      className={cn(inputGroupAddonVariants({ align }), className)}\n      onClick={(e) => {\n        if ((e.target as HTMLElement).closest(\"button\")) {\n          return\n        }\n        e.currentTarget.parentElement?.querySelector(\"input\")?.focus()\n      }}\n      {...props}\n    />\n  )\n}\n\nconst inputGroupButtonVariants = cva(\n  \"flex items-center gap-2 text-sm shadow-none\",\n  {\n    variants: {\n      size: {\n        xs: \"h-6 gap-1 rounded-[calc(var(--radius)-5px)] px-2 has-[>svg]:px-2 [&>svg:not([class*='size-'])]:size-3.5\",\n        sm: \"h-8 gap-1.5 rounded-md px-2.5 has-[>svg]:px-2.5\",\n        \"icon-xs\":\n          \"size-6 rounded-[calc(var(--radius)-5px)] p-0 has-[>svg]:p-0\",\n        \"icon-sm\": \"size-8 p-0 has-[>svg]:p-0\",\n      },\n    },\n    defaultVariants: {\n      size: \"xs\",\n    },\n  }\n)\n\nfunction InputGroupButton({\n  className,\n  type = \"button\",\n  variant = \"ghost\",\n  size = \"xs\",\n  ...props\n}: Omit<React.ComponentProps<typeof Button>, \"size\"> &\n  VariantProps<typeof inputGroupButtonVariants>) {\n  return (\n    <Button\n      type={type}\n      data-size={size}\n      variant={variant}\n      className={cn(inputGroupButtonVariants({ size }), className)}\n      {...props}\n    />\n  )\n}\n\nfunction InputGroupText({ className, ...props }: React.ComponentProps<\"span\">) {\n  return (\n    <span\n      className={cn(\n        \"text-muted-foreground flex items-center gap-2 text-sm [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction InputGroupInput({\n  className,\n  ...props\n}: React.ComponentProps<\"input\">) {\n  return (\n    <Input\n      data-slot=\"input-group-control\"\n      className={cn(\n        \"flex-1 rounded-none border-0 bg-transparent shadow-none focus-visible:ring-0 dark:bg-transparent\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction InputGroupTextarea({\n  className,\n  ...props\n}: React.ComponentProps<\"textarea\">) {\n  return (\n    <Textarea\n      data-slot=\"input-group-control\"\n      className={cn(\n        \"flex-1 resize-none rounded-none border-0 bg-transparent py-3 shadow-none focus-visible:ring-0 dark:bg-transparent\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport {\n  InputGroup,\n  InputGroupAddon,\n  InputGroupButton,\n  InputGroupText,\n  InputGroupInput,\n  InputGroupTextarea,\n}\n","path":null,"size_bytes":4971,"size_tokens":null},"client/src/components/ui/skeleton.tsx":{"content":"import { cn } from \"@/lib/utils\"\n\nfunction Skeleton({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) {\n  return (\n    <div\n      className={cn(\"animate-pulse rounded-md bg-primary/10\", className)}\n      {...props}\n    />\n  )\n}\n\nexport { Skeleton }\n","path":null,"size_bytes":266,"size_tokens":null},"client/src/components/ui/hover-card.tsx":{"content":"import * as React from \"react\"\nimport * as HoverCardPrimitive from \"@radix-ui/react-hover-card\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst HoverCard = HoverCardPrimitive.Root\n\nconst HoverCardTrigger = HoverCardPrimitive.Trigger\n\nconst HoverCardContent = React.forwardRef<\n  React.ElementRef<typeof HoverCardPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\n  <HoverCardPrimitive.Content\n    ref={ref}\n    align={align}\n    sideOffset={sideOffset}\n    className={cn(\n      \"z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-hover-card-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nHoverCardContent.displayName = HoverCardPrimitive.Content.displayName\n\nexport { HoverCard, HoverCardTrigger, HoverCardContent }\n","path":null,"size_bytes":1237,"size_tokens":null},"client/src/components/ui/carousel.tsx":{"content":"import * as React from \"react\"\nimport useEmblaCarousel, {\n  type UseEmblaCarouselType,\n} from \"embla-carousel-react\"\nimport { ArrowLeft, ArrowRight } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\n\ntype CarouselApi = UseEmblaCarouselType[1]\ntype UseCarouselParameters = Parameters<typeof useEmblaCarousel>\ntype CarouselOptions = UseCarouselParameters[0]\ntype CarouselPlugin = UseCarouselParameters[1]\n\ntype CarouselProps = {\n  opts?: CarouselOptions\n  plugins?: CarouselPlugin\n  orientation?: \"horizontal\" | \"vertical\"\n  setApi?: (api: CarouselApi) => void\n}\n\ntype CarouselContextProps = {\n  carouselRef: ReturnType<typeof useEmblaCarousel>[0]\n  api: ReturnType<typeof useEmblaCarousel>[1]\n  scrollPrev: () => void\n  scrollNext: () => void\n  canScrollPrev: boolean\n  canScrollNext: boolean\n} & CarouselProps\n\nconst CarouselContext = React.createContext<CarouselContextProps | null>(null)\n\nfunction useCarousel() {\n  const context = React.useContext(CarouselContext)\n\n  if (!context) {\n    throw new Error(\"useCarousel must be used within a <Carousel />\")\n  }\n\n  return context\n}\n\nconst Carousel = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement> & CarouselProps\n>(\n  (\n    {\n      orientation = \"horizontal\",\n      opts,\n      setApi,\n      plugins,\n      className,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    const [carouselRef, api] = useEmblaCarousel(\n      {\n        ...opts,\n        axis: orientation === \"horizontal\" ? \"x\" : \"y\",\n      },\n      plugins\n    )\n    const [canScrollPrev, setCanScrollPrev] = React.useState(false)\n    const [canScrollNext, setCanScrollNext] = React.useState(false)\n\n    const onSelect = React.useCallback((api: CarouselApi) => {\n      if (!api) {\n        return\n      }\n\n      setCanScrollPrev(api.canScrollPrev())\n      setCanScrollNext(api.canScrollNext())\n    }, [])\n\n    const scrollPrev = React.useCallback(() => {\n      api?.scrollPrev()\n    }, [api])\n\n    const scrollNext = React.useCallback(() => {\n      api?.scrollNext()\n    }, [api])\n\n    const handleKeyDown = React.useCallback(\n      (event: React.KeyboardEvent<HTMLDivElement>) => {\n        if (event.key === \"ArrowLeft\") {\n          event.preventDefault()\n          scrollPrev()\n        } else if (event.key === \"ArrowRight\") {\n          event.preventDefault()\n          scrollNext()\n        }\n      },\n      [scrollPrev, scrollNext]\n    )\n\n    React.useEffect(() => {\n      if (!api || !setApi) {\n        return\n      }\n\n      setApi(api)\n    }, [api, setApi])\n\n    React.useEffect(() => {\n      if (!api) {\n        return\n      }\n\n      onSelect(api)\n      api.on(\"reInit\", onSelect)\n      api.on(\"select\", onSelect)\n\n      return () => {\n        api?.off(\"select\", onSelect)\n      }\n    }, [api, onSelect])\n\n    return (\n      <CarouselContext.Provider\n        value={{\n          carouselRef,\n          api: api,\n          opts,\n          orientation:\n            orientation || (opts?.axis === \"y\" ? \"vertical\" : \"horizontal\"),\n          scrollPrev,\n          scrollNext,\n          canScrollPrev,\n          canScrollNext,\n        }}\n      >\n        <div\n          ref={ref}\n          onKeyDownCapture={handleKeyDown}\n          className={cn(\"relative\", className)}\n          role=\"region\"\n          aria-roledescription=\"carousel\"\n          {...props}\n        >\n          {children}\n        </div>\n      </CarouselContext.Provider>\n    )\n  }\n)\nCarousel.displayName = \"Carousel\"\n\nconst CarouselContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const { carouselRef, orientation } = useCarousel()\n\n  return (\n    <div ref={carouselRef} className=\"overflow-hidden\">\n      <div\n        ref={ref}\n        className={cn(\n          \"flex\",\n          orientation === \"horizontal\" ? \"-ml-4\" : \"-mt-4 flex-col\",\n          className\n        )}\n        {...props}\n      />\n    </div>\n  )\n})\nCarouselContent.displayName = \"CarouselContent\"\n\nconst CarouselItem = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const { orientation } = useCarousel()\n\n  return (\n    <div\n      ref={ref}\n      role=\"group\"\n      aria-roledescription=\"slide\"\n      className={cn(\n        \"min-w-0 shrink-0 grow-0 basis-full\",\n        orientation === \"horizontal\" ? \"pl-4\" : \"pt-4\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nCarouselItem.displayName = \"CarouselItem\"\n\nconst CarouselPrevious = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<typeof Button>\n>(({ className, variant = \"outline\", size = \"icon\", ...props }, ref) => {\n  const { orientation, scrollPrev, canScrollPrev } = useCarousel()\n\n  return (\n    <Button\n      ref={ref}\n      variant={variant}\n      size={size}\n      className={cn(\n        \"absolute  h-8 w-8 rounded-full\",\n        orientation === \"horizontal\"\n          ? \"-left-12 top-1/2 -translate-y-1/2\"\n          : \"-top-12 left-1/2 -translate-x-1/2 rotate-90\",\n        className\n      )}\n      disabled={!canScrollPrev}\n      onClick={scrollPrev}\n      {...props}\n    >\n      <ArrowLeft className=\"h-4 w-4\" />\n      <span className=\"sr-only\">Previous slide</span>\n    </Button>\n  )\n})\nCarouselPrevious.displayName = \"CarouselPrevious\"\n\nconst CarouselNext = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<typeof Button>\n>(({ className, variant = \"outline\", size = \"icon\", ...props }, ref) => {\n  const { orientation, scrollNext, canScrollNext } = useCarousel()\n\n  return (\n    <Button\n      ref={ref}\n      variant={variant}\n      size={size}\n      className={cn(\n        \"absolute h-8 w-8 rounded-full\",\n        orientation === \"horizontal\"\n          ? \"-right-12 top-1/2 -translate-y-1/2\"\n          : \"-bottom-12 left-1/2 -translate-x-1/2 rotate-90\",\n        className\n      )}\n      disabled={!canScrollNext}\n      onClick={scrollNext}\n      {...props}\n    >\n      <ArrowRight className=\"h-4 w-4\" />\n      <span className=\"sr-only\">Next slide</span>\n    </Button>\n  )\n})\nCarouselNext.displayName = \"CarouselNext\"\n\nexport {\n  type CarouselApi,\n  Carousel,\n  CarouselContent,\n  CarouselItem,\n  CarouselPrevious,\n  CarouselNext,\n}\n","path":null,"size_bytes":6210,"size_tokens":null},"server/index.ts":{"content":"import express, { type Request, Response, NextFunction } from \"express\";\nimport { registerRoutes, initializeWebSockets } from \"./routes\";\nimport { serveStatic } from \"./static\";\nimport { createServer } from \"http\";\n\nconst app = express();\nconst httpServer = createServer(app);\n\ninitializeWebSockets(httpServer);\n\ndeclare module \"http\" {\n  interface IncomingMessage {\n    rawBody: unknown;\n  }\n}\n\napp.use(\n  express.json({\n    verify: (req, _res, buf) => {\n      req.rawBody = buf;\n    },\n  }),\n);\n\napp.use(express.urlencoded({ extended: false }));\n\nexport function log(message: string, source = \"express\") {\n  const formattedTime = new Date().toLocaleTimeString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    hour12: true,\n  });\n\n  console.log(`${formattedTime} [${source}] ${message}`);\n}\n\napp.use((req, res, next) => {\n  const start = Date.now();\n  const path = req.path;\n  let capturedJsonResponse: Record<string, any> | undefined = undefined;\n\n  const originalResJson = res.json;\n  res.json = function (bodyJson, ...args) {\n    capturedJsonResponse = bodyJson;\n    return originalResJson.apply(res, [bodyJson, ...args]);\n  };\n\n  res.on(\"finish\", () => {\n    const duration = Date.now() - start;\n    if (path.startsWith(\"/api\")) {\n      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;\n      if (capturedJsonResponse) {\n        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;\n      }\n\n      log(logLine);\n    }\n  });\n\n  next();\n});\n\n(async () => {\n  await registerRoutes(httpServer, app);\n\n  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {\n    const status = err.status || err.statusCode || 500;\n    const message = err.message || \"Internal Server Error\";\n\n    res.status(status).json({ message });\n    throw err;\n  });\n\n  // importantly only setup vite in development and after\n  // setting up all the other routes so the catch-all route\n  // doesn't interfere with the other routes\n  if (process.env.NODE_ENV === \"production\") {\n    serveStatic(app);\n  } else {\n    const { setupVite } = await import(\"./vite\");\n    await setupVite(httpServer, app);\n  }\n\n  // ALWAYS serve the app on the port specified in the environment variable PORT\n  // Other ports are firewalled. Default to 5000 if not specified.\n  // this serves both the API and the client.\n  // It is the only port that is not firewalled.\n  const port = parseInt(process.env.PORT || \"5000\", 10);\n  httpServer.listen(\n    {\n      port,\n      host: \"0.0.0.0\",\n      reusePort: true,\n    },\n    () => {\n      log(`serving on port ${port}`);\n    },\n  );\n})();\n","path":null,"size_bytes":2617,"size_tokens":null},"client/src/components/ui/badge.tsx":{"content":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  // @replit\n  // Whitespace-nowrap: Badges should never wrap.\n  \"whitespace-nowrap inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\" +\n  \" hover-elevate \",\n  {\n    variants: {\n      variant: {\n        default:\n          // @replit shadow-xs instead of shadow, no hover because we use hover-elevate\n          \"border-transparent bg-primary text-primary-foreground shadow-xs\",\n        secondary:\n          // @replit no hover because we use hover-elevate\n          \"border-transparent bg-secondary text-secondary-foreground\",\n        destructive:\n          // @replit shadow-xs instead of shadow, no hover because we use hover-elevate\n          \"border-transparent bg-destructive text-destructive-foreground shadow-xs\",\n          // @replit shadow-xs\" - use badge outline variable\n        outline: \"text-foreground border [border-color:var(--badge-outline)]\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nexport interface BadgeProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof badgeVariants> {}\n\nfunction Badge({ className, variant, ...props }: BadgeProps) {\n  return (\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\n  )\n}\n\nexport { Badge, badgeVariants }\n","path":null,"size_bytes":1522,"size_tokens":null},"drizzle.config.ts":{"content":"import { defineConfig } from \"drizzle-kit\";\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\"DATABASE_URL, ensure the database is provisioned\");\n}\n\nexport default defineConfig({\n  out: \"./migrations\",\n  schema: \"./shared/schema.ts\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL,\n  },\n});\n","path":null,"size_bytes":325,"size_tokens":null},"client/src/components/ui/context-menu.tsx":{"content":"import * as React from \"react\"\nimport * as ContextMenuPrimitive from \"@radix-ui/react-context-menu\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ContextMenu = ContextMenuPrimitive.Root\n\nconst ContextMenuTrigger = ContextMenuPrimitive.Trigger\n\nconst ContextMenuGroup = ContextMenuPrimitive.Group\n\nconst ContextMenuPortal = ContextMenuPrimitive.Portal\n\nconst ContextMenuSub = ContextMenuPrimitive.Sub\n\nconst ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup\n\nconst ContextMenuSubTrigger = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <ContextMenuPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto h-4 w-4\" />\n  </ContextMenuPrimitive.SubTrigger>\n))\nContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName\n\nconst ContextMenuSubContent = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName\n\nconst ContextMenuContent = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.Portal>\n    <ContextMenuPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"z-50 max-h-[--radix-context-menu-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]\",\n        className\n      )}\n      {...props}\n    />\n  </ContextMenuPrimitive.Portal>\n))\nContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName\n\nconst ContextMenuItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <ContextMenuPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName\n\nconst ContextMenuCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <ContextMenuPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <ContextMenuPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </ContextMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </ContextMenuPrimitive.CheckboxItem>\n))\nContextMenuCheckboxItem.displayName =\n  ContextMenuPrimitive.CheckboxItem.displayName\n\nconst ContextMenuRadioItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <ContextMenuPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <ContextMenuPrimitive.ItemIndicator>\n        <Circle className=\"h-4 w-4 fill-current\" />\n      </ContextMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </ContextMenuPrimitive.RadioItem>\n))\nContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName\n\nconst ContextMenuLabel = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <ContextMenuPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold text-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName\n\nconst ContextMenuSeparator = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-border\", className)}\n    {...props}\n  />\n))\nContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName\n\nconst ContextMenuShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nContextMenuShortcut.displayName = \"ContextMenuShortcut\"\n\nexport {\n  ContextMenu,\n  ContextMenuTrigger,\n  ContextMenuContent,\n  ContextMenuItem,\n  ContextMenuCheckboxItem,\n  ContextMenuRadioItem,\n  ContextMenuLabel,\n  ContextMenuSeparator,\n  ContextMenuShortcut,\n  ContextMenuGroup,\n  ContextMenuPortal,\n  ContextMenuSub,\n  ContextMenuSubContent,\n  ContextMenuSubTrigger,\n  ContextMenuRadioGroup,\n}\n","path":null,"size_bytes":7406,"size_tokens":null},"client/src/components/ui/spinner.tsx":{"content":"import { Loader2Icon } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction Spinner({ className, ...props }: React.ComponentProps<\"svg\">) {\n  return (\n    <Loader2Icon\n      role=\"status\"\n      aria-label=\"Loading\"\n      className={cn(\"size-4 animate-spin\", className)}\n      {...props}\n    />\n  )\n}\n\nexport { Spinner }\n","path":null,"size_bytes":331,"size_tokens":null},"client/src/components/ui/accordion.tsx":{"content":"import * as React from \"react\"\nimport * as AccordionPrimitive from \"@radix-ui/react-accordion\"\nimport { ChevronDown } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Accordion = AccordionPrimitive.Root\n\nconst AccordionItem = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <AccordionPrimitive.Item\n    ref={ref}\n    className={cn(\"border-b\", className)}\n    {...props}\n  />\n))\nAccordionItem.displayName = \"AccordionItem\"\n\nconst AccordionTrigger = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Header className=\"flex\">\n    <AccordionPrimitive.Trigger\n      ref={ref}\n      className={cn(\n        \"flex flex-1 items-center justify-between py-4 text-sm font-medium transition-all hover:underline text-left [&[data-state=open]>svg]:rotate-180\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <ChevronDown className=\"h-4 w-4 shrink-0 text-muted-foreground transition-transform duration-200\" />\n    </AccordionPrimitive.Trigger>\n  </AccordionPrimitive.Header>\n))\nAccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName\n\nconst AccordionContent = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Content\n    ref={ref}\n    className=\"overflow-hidden text-sm data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down\"\n    {...props}\n  >\n    <div className={cn(\"pb-4 pt-0\", className)}>{children}</div>\n  </AccordionPrimitive.Content>\n))\nAccordionContent.displayName = AccordionPrimitive.Content.displayName\n\nexport { Accordion, AccordionItem, AccordionTrigger, AccordionContent }\n","path":null,"size_bytes":2001,"size_tokens":null},"server/db.ts":{"content":"import { drizzle } from \"drizzle-orm/node-postgres\";\nimport pg from \"pg\";\nimport * as schema from \"@shared/schema\";\n\nconst { Pool } = pg;\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\"DATABASE_URL environment variable is not set\");\n}\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\n\nexport const db = drizzle(pool, { schema });\n","path":null,"size_bytes":362,"size_tokens":null},"client/src/components/ui/radio-group.tsx":{"content":"import * as React from \"react\"\nimport * as RadioGroupPrimitive from \"@radix-ui/react-radio-group\"\nimport { Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst RadioGroup = React.forwardRef<\n  React.ElementRef<typeof RadioGroupPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>\n>(({ className, ...props }, ref) => {\n  return (\n    <RadioGroupPrimitive.Root\n      className={cn(\"grid gap-2\", className)}\n      {...props}\n      ref={ref}\n    />\n  )\n})\nRadioGroup.displayName = RadioGroupPrimitive.Root.displayName\n\nconst RadioGroupItem = React.forwardRef<\n  React.ElementRef<typeof RadioGroupPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>\n>(({ className, ...props }, ref) => {\n  return (\n    <RadioGroupPrimitive.Item\n      ref={ref}\n      className={cn(\n        \"aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    >\n      <RadioGroupPrimitive.Indicator className=\"flex items-center justify-center\">\n        <Circle className=\"h-3.5 w-3.5 fill-primary\" />\n      </RadioGroupPrimitive.Indicator>\n    </RadioGroupPrimitive.Item>\n  )\n})\nRadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName\n\nexport { RadioGroup, RadioGroupItem }\n","path":null,"size_bytes":1410,"size_tokens":null},"client/src/components/dashboard/Nav.tsx":{"content":"import { useState } from \"react\";\nimport { Link, useLocation } from \"wouter\";\nimport { cn } from \"@/lib/utils\";\nimport { LayoutDashboard, Activity, Settings, Wallet, Bell, Plug, Menu, X, BookOpen, BarChart3, Monitor } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\n\nexport function Nav() {\n  const [location] = useLocation();\n  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);\n\n  const links = [\n    { href: \"/\", label: \"PANEL\", icon: LayoutDashboard },\n    { href: \"/strategies\", label: \"ESTRATEGIAS\", icon: Activity },\n    { href: \"/terminal\", label: \"TERMINAL\", icon: BarChart3 },\n    { href: \"/monitor\", label: \"MONITOR\", icon: Monitor },\n    { href: \"/wallet\", label: \"CARTERA\", icon: Wallet },\n    { href: \"/integrations\", label: \"INTEGRACIONES\", icon: Plug },\n    { href: \"/settings\", label: \"AJUSTES\", icon: Settings },\n    { href: \"/guide\", label: \"GUÃA\", icon: BookOpen },\n  ];\n\n  return (\n    <>\n      <nav className=\"h-14 md:h-16 border-b border-border bg-card/80 backdrop-blur-md sticky top-0 z-50 px-4 md:px-6 flex items-center justify-between\">\n        <div className=\"flex items-center gap-4 md:gap-8\">\n          <Button \n            variant=\"ghost\" \n            size=\"icon\" \n            className=\"md:hidden text-muted-foreground\"\n            onClick={() => setMobileMenuOpen(!mobileMenuOpen)}\n            data-testid=\"button-mobile-menu\"\n          >\n            {mobileMenuOpen ? <X className=\"h-5 w-5\" /> : <Menu className=\"h-5 w-5\" />}\n          </Button>\n          \n          <div className=\"flex items-center gap-2\">\n            <div className=\"h-7 w-7 md:h-8 md:w-8 bg-primary/20 rounded-md flex items-center justify-center border border-primary/50\">\n              <Activity className=\"h-4 w-4 md:h-5 md:w-5 text-primary\" />\n            </div>\n            <span className=\"font-sans font-bold text-base md:text-lg tracking-tight\">\n              KRAKEN<span className=\"text-primary\">BOT</span><span className=\"hidden sm:inline\">.AI</span>\n            </span>\n          </div>\n\n          <div className=\"hidden md:flex items-center gap-1\">\n            {links.map((link) => (\n              <Link \n                key={link.href} \n                href={link.href}\n                className={cn(\n                  \"px-2 lg:px-3 xl:px-4 py-2 rounded-md text-xs font-mono transition-colors flex items-center gap-1.5 lg:gap-2\",\n                  location === link.href \n                    ? \"bg-primary/10 text-primary border border-primary/20\" \n                    : \"text-muted-foreground hover:text-foreground hover:bg-white/5\"\n                )}\n              >\n                <link.icon className=\"h-4 w-4\" />\n                <span className=\"hidden lg:inline text-xs\">{link.label}</span>\n              </Link>\n            ))}\n          </div>\n        </div>\n\n        <div className=\"flex items-center gap-2 md:gap-4\">\n          <Button variant=\"ghost\" size=\"icon\" className=\"relative text-muted-foreground hover:text-foreground h-8 w-8 md:h-10 md:w-10\">\n            <Bell className=\"h-4 w-4 md:h-5 md:w-5\" />\n            <span className=\"absolute top-1.5 right-1.5 md:top-2 md:right-2 h-2 w-2 bg-red-500 rounded-full animate-pulse\" />\n          </Button>\n          <div className=\"h-7 w-7 md:h-8 md:w-8 rounded-full bg-gradient-to-tr from-primary to-purple-500 border border-white/10\" />\n        </div>\n      </nav>\n      \n      {mobileMenuOpen && (\n        <>\n          <div \n            className=\"md:hidden fixed inset-0 top-14 z-30 bg-black/50\"\n            onClick={() => setMobileMenuOpen(false)}\n            aria-hidden=\"true\"\n          />\n          <div className=\"md:hidden fixed inset-x-0 top-14 z-40 bg-background border-b border-border max-h-[calc(100vh-3.5rem)] overflow-y-auto\">\n            <div className=\"flex flex-col p-4 gap-2\">\n              {links.map((link) => (\n                <Link \n                  key={link.href} \n                  href={link.href}\n                  onClick={() => setMobileMenuOpen(false)}\n                  className={cn(\n                    \"px-4 py-3 rounded-lg text-sm font-mono transition-colors flex items-center gap-3\",\n                    location === link.href \n                      ? \"bg-primary/10 text-primary border border-primary/20\" \n                      : \"text-muted-foreground hover:text-foreground hover:bg-white/5 border border-transparent\"\n                  )}\n                >\n                  <link.icon className=\"h-5 w-5\" />\n                  {link.label}\n                </Link>\n              ))}\n            </div>\n          </div>\n        </>\n      )}\n    </>\n  );\n}\n","path":null,"size_bytes":4603,"size_tokens":null},"client/src/components/dashboard/Ticker.tsx":{"content":"import { ArrowUpRight, ArrowDownRight } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport { useQuery } from \"@tanstack/react-query\";\n\ninterface DashboardData {\n  prices: Record<string, { price: string; change: string }>;\n}\n\nconst PAIR_NAMES: Record<string, string> = {\n  \"XXBTZUSD\": \"BTC/USD\",\n  \"XETHZUSD\": \"ETH/USD\",\n  \"SOLUSD\": \"SOL/USD\",\n  \"XXRPZUSD\": \"XRP/USD\",\n  \"TONUSD\": \"TON/USD\",\n};\n\nfunction formatPrice(price: string): string {\n  const num = parseFloat(price);\n  if (num >= 1000) {\n    return num.toLocaleString(\"en-US\", { minimumFractionDigits: 2, maximumFractionDigits: 2 });\n  }\n  return num.toFixed(num < 1 ? 6 : 2);\n}\n\nexport function Ticker() {\n  const { data } = useQuery<DashboardData>({\n    queryKey: [\"/api/dashboard\"],\n    refetchInterval: 10000,\n  });\n\n  const pairs = data?.prices \n    ? Object.entries(data.prices).map(([key, value]) => ({\n        symbol: PAIR_NAMES[key] || key,\n        price: formatPrice(value.price),\n        change: `${parseFloat(value.change) >= 0 ? \"+\" : \"\"}${value.change}%`,\n        up: parseFloat(value.change) >= 0,\n      }))\n    : [\n        { symbol: \"BTC/USD\", price: \"--\", change: \"--%\", up: true },\n        { symbol: \"ETH/USD\", price: \"--\", change: \"--%\", up: true },\n        { symbol: \"SOL/USD\", price: \"--\", change: \"--%\", up: true },\n      ];\n\n  return (\n    <div className=\"w-full bg-card/50 border-b border-border overflow-hidden py-2 flex items-center whitespace-nowrap group\">\n      <div className=\"flex animate-ticker group-hover:[animation-play-state:paused] gap-12 px-4\">\n        {[...pairs, ...pairs, ...pairs, ...pairs].map((pair, idx) => (\n          <div key={idx} className=\"flex items-center gap-3 font-mono text-sm\">\n            <span className=\"text-muted-foreground font-bold\">{pair.symbol}</span>\n            <span className=\"text-foreground font-medium\">${pair.price}</span>\n            <span className={cn(\"flex items-center text-xs font-medium\", pair.up ? \"text-green-500\" : \"text-red-500\")}>\n              {pair.up ? <ArrowUpRight className=\"h-3 w-3 mr-0.5\" /> : <ArrowDownRight className=\"h-3 w-3 mr-0.5\" />}\n              {pair.change}\n            </span>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":2210,"size_tokens":null},"client/src/components/dashboard/ChartWidget.tsx":{"content":"import { useQuery } from \"@tanstack/react-query\";\nimport { Area, AreaChart, CartesianGrid, ResponsiveContainer, Tooltip, XAxis, YAxis } from \"recharts\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { RefreshCw, TrendingUp, TrendingDown, Target, Activity } from \"lucide-react\";\n\ninterface PerformanceData {\n  curve: { time: string; equity: number; pnl?: number }[];\n  summary: {\n    startingEquity: number;\n    endingEquity: number;\n    totalPnlUsd: number;\n    totalPnlPct: number;\n    maxDrawdownPct: number;\n    winRatePct: number;\n    totalTrades: number;\n    wins: number;\n    losses: number;\n  };\n}\n\nexport function ChartWidget() {\n  const { data, isLoading, refetch, isFetching } = useQuery<PerformanceData>({\n    queryKey: [\"performance\"],\n    queryFn: async () => {\n      const res = await fetch(\"/api/performance\");\n      if (!res.ok) throw new Error(\"Failed to fetch performance\");\n      return res.json();\n    },\n    refetchInterval: false,\n  });\n\n  const chartData = data?.curve.map((point) => ({\n    time: new Date(point.time).toLocaleDateString(\"es-ES\", { \n      month: \"short\", \n      day: \"numeric\",\n      hour: \"2-digit\",\n      minute: \"2-digit\"\n    }),\n    equity: point.equity,\n  })) || [];\n\n  const summary = data?.summary;\n  const isPositive = (summary?.totalPnlUsd || 0) >= 0;\n  const hasTrades = (summary?.totalTrades || 0) > 0;\n\n  return (\n    <Card className=\"col-span-2 glass-panel border-border/50 h-full flex flex-col\">\n      <CardHeader className=\"flex flex-row items-center justify-between pb-2\">\n        <CardTitle className=\"text-sm font-medium font-mono tracking-wider text-muted-foreground\">\n          RENDIMIENTO DEL PORTAFOLIO\n        </CardTitle>\n        <Button \n          variant=\"ghost\" \n          size=\"sm\" \n          onClick={() => refetch()}\n          disabled={isFetching}\n          className=\"h-8 px-2\"\n          data-testid=\"btn-refresh-chart\"\n        >\n          <RefreshCw className={`h-4 w-4 ${isFetching ? 'animate-spin' : ''}`} />\n        </Button>\n      </CardHeader>\n      \n      {summary && (\n        <div className=\"px-6 pb-2 grid grid-cols-2 md:grid-cols-4 gap-3\">\n          <div className=\"flex items-center gap-2 p-2 rounded-lg bg-muted/30\">\n            {isPositive ? (\n              <TrendingUp className=\"h-4 w-4 text-emerald-400\" />\n            ) : (\n              <TrendingDown className=\"h-4 w-4 text-red-400\" />\n            )}\n            <div>\n              <div className=\"text-xs text-muted-foreground\">P&L Total</div>\n              <div className={`font-mono font-semibold ${isPositive ? 'text-emerald-400' : 'text-red-400'}`}>\n                {isPositive ? '+' : ''}{summary.totalPnlUsd.toFixed(2)} USD\n              </div>\n            </div>\n          </div>\n          <div className=\"flex items-center gap-2 p-2 rounded-lg bg-muted/30\">\n            <Target className=\"h-4 w-4 text-cyan-400\" />\n            <div>\n              <div className=\"text-xs text-muted-foreground\">Win Rate</div>\n              <div className=\"font-mono font-semibold text-cyan-400\">\n                {summary.winRatePct.toFixed(1)}%\n              </div>\n            </div>\n          </div>\n          <div className=\"flex items-center gap-2 p-2 rounded-lg bg-muted/30\">\n            <Activity className=\"h-4 w-4 text-purple-400\" />\n            <div>\n              <div className=\"text-xs text-muted-foreground\">Trades</div>\n              <div className=\"font-mono font-semibold text-purple-400\">\n                {summary.totalTrades} ({summary.wins}W/{summary.losses}L)\n              </div>\n            </div>\n          </div>\n          <div className=\"flex items-center gap-2 p-2 rounded-lg bg-muted/30\">\n            <TrendingDown className=\"h-4 w-4 text-orange-400\" />\n            <div>\n              <div className=\"text-xs text-muted-foreground\">Max Drawdown</div>\n              <div className=\"font-mono font-semibold text-orange-400\">\n                -{summary.maxDrawdownPct.toFixed(2)}%\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n\n      <CardContent className=\"flex-1 min-h-[280px] w-full pt-2\">\n        {isLoading ? (\n          <div className=\"h-full flex items-center justify-center text-muted-foreground\">\n            Cargando datos de rendimiento...\n          </div>\n        ) : !hasTrades ? (\n          <div className=\"h-full flex flex-col items-center justify-center text-muted-foreground gap-3\">\n            <Activity className=\"h-12 w-12 opacity-30\" />\n            <div className=\"text-center\">\n              <p className=\"font-medium\">Sin operaciones completadas</p>\n              <p className=\"text-sm opacity-70\">El grÃ¡fico mostrarÃ¡ la curva de equity cuando el bot ejecute trades</p>\n            </div>\n          </div>\n        ) : (\n          <ResponsiveContainer width=\"100%\" height=\"100%\">\n            <AreaChart data={chartData}>\n              <defs>\n                <linearGradient id=\"equityGradient\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\">\n                  <stop offset=\"5%\" stopColor=\"#00FF88\" stopOpacity={0.4} />\n                  <stop offset=\"50%\" stopColor=\"#00FF88\" stopOpacity={0.15} />\n                  <stop offset=\"95%\" stopColor=\"#00FF88\" stopOpacity={0} />\n                </linearGradient>\n              </defs>\n              <CartesianGrid \n                strokeDasharray=\"3 3\" \n                stroke=\"rgba(255,255,255,0.1)\" \n                vertical={false} \n              />\n              <XAxis \n                dataKey=\"time\" \n                stroke=\"#888888\" \n                fontSize={11} \n                tickLine={false} \n                axisLine={{ stroke: 'rgba(255,255,255,0.2)' }}\n                fontFamily=\"JetBrains Mono\"\n                tick={{ fill: '#aaaaaa' }}\n              />\n              <YAxis \n                stroke=\"#888888\" \n                fontSize={11} \n                tickLine={false} \n                axisLine={{ stroke: 'rgba(255,255,255,0.2)' }}\n                tickFormatter={(value) => `$${value.toFixed(0)}`}\n                fontFamily=\"JetBrains Mono\"\n                tick={{ fill: '#aaaaaa' }}\n                domain={['dataMin - 10', 'dataMax + 10']}\n              />\n              <Tooltip \n                contentStyle={{ \n                  backgroundColor: 'rgba(20, 20, 30, 0.95)', \n                  borderColor: '#00FF88',\n                  borderWidth: 1,\n                  borderRadius: '8px',\n                  fontFamily: 'JetBrains Mono',\n                  boxShadow: '0 4px 20px rgba(0, 255, 136, 0.2)'\n                }}\n                labelStyle={{ color: '#ffffff', fontWeight: 'bold' }}\n                itemStyle={{ color: '#00FF88' }}\n                formatter={(value: number) => [`$${value.toFixed(2)}`, 'Equity']}\n              />\n              <Area \n                type=\"monotone\" \n                dataKey=\"equity\" \n                stroke=\"#00FF88\" \n                strokeWidth={3}\n                fillOpacity={1} \n                fill=\"url(#equityGradient)\"\n                dot={false}\n                activeDot={{ r: 6, fill: '#00FF88', stroke: '#ffffff', strokeWidth: 2 }}\n              />\n            </AreaChart>\n          </ResponsiveContainer>\n        )}\n      </CardContent>\n    </Card>\n  );\n}\n","path":null,"size_bytes":7277,"size_tokens":null},"client/src/components/ui/button.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\" +\n\" hover-elevate active-elevate-2\",\n  {\n    variants: {\n      variant: {\n        default:\n           // @replit: no hover, and add primary border\n           \"bg-primary text-primary-foreground border border-primary-border\",\n        destructive:\n          \"bg-destructive text-destructive-foreground shadow-sm border-destructive-border\",\n        outline:\n          // @replit Shows the background color of whatever card / sidebar / accent background it is inside of.\n          // Inherits the current text color. Uses shadow-xs. no shadow on active\n          // No hover state\n          \" border [border-color:var(--button-outline)] shadow-xs active:shadow-none \",\n        secondary:\n          // @replit border, no hover, no shadow, secondary border.\n          \"border bg-secondary text-secondary-foreground border border-secondary-border \",\n        // @replit no hover, transparent border\n        ghost: \"border border-transparent\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        // @replit changed sizes\n        default: \"min-h-9 px-4 py-2\",\n        sm: \"min-h-8 rounded-md px-3 text-xs\",\n        lg: \"min-h-10 rounded-md px-8\",\n        icon: \"h-9 w-9\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }\n","path":null,"size_bytes":2356,"size_tokens":null},"client/src/components/ui/drawer.tsx":{"content":"import * as React from \"react\"\nimport { Drawer as DrawerPrimitive } from \"vaul\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Drawer = ({\n  shouldScaleBackground = true,\n  ...props\n}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (\n  <DrawerPrimitive.Root\n    shouldScaleBackground={shouldScaleBackground}\n    {...props}\n  />\n)\nDrawer.displayName = \"Drawer\"\n\nconst DrawerTrigger = DrawerPrimitive.Trigger\n\nconst DrawerPortal = DrawerPrimitive.Portal\n\nconst DrawerClose = DrawerPrimitive.Close\n\nconst DrawerOverlay = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Overlay\n    ref={ref}\n    className={cn(\"fixed inset-0 z-50 bg-black/80\", className)}\n    {...props}\n  />\n))\nDrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName\n\nconst DrawerContent = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DrawerPortal>\n    <DrawerOverlay />\n    <DrawerPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background\",\n        className\n      )}\n      {...props}\n    >\n      <div className=\"mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted\" />\n      {children}\n    </DrawerPrimitive.Content>\n  </DrawerPortal>\n))\nDrawerContent.displayName = \"DrawerContent\"\n\nconst DrawerHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\"grid gap-1.5 p-4 text-center sm:text-left\", className)}\n    {...props}\n  />\n)\nDrawerHeader.displayName = \"DrawerHeader\"\n\nconst DrawerFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\"mt-auto flex flex-col gap-2 p-4\", className)}\n    {...props}\n  />\n)\nDrawerFooter.displayName = \"DrawerFooter\"\n\nconst DrawerTitle = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDrawerTitle.displayName = DrawerPrimitive.Title.displayName\n\nconst DrawerDescription = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDrawerDescription.displayName = DrawerPrimitive.Description.displayName\n\nexport {\n  Drawer,\n  DrawerPortal,\n  DrawerOverlay,\n  DrawerTrigger,\n  DrawerClose,\n  DrawerContent,\n  DrawerHeader,\n  DrawerFooter,\n  DrawerTitle,\n  DrawerDescription,\n}\n","path":null,"size_bytes":3007,"size_tokens":null},"client/src/components/ui/progress.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as ProgressPrimitive from \"@radix-ui/react-progress\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Progress = React.forwardRef<\n  React.ElementRef<typeof ProgressPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>\n>(({ className, value, ...props }, ref) => (\n  <ProgressPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative h-2 w-full overflow-hidden rounded-full bg-primary/20\",\n      className\n    )}\n    {...props}\n  >\n    <ProgressPrimitive.Indicator\n      className=\"h-full w-full flex-1 bg-primary transition-all\"\n      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}\n    />\n  </ProgressPrimitive.Root>\n))\nProgress.displayName = ProgressPrimitive.Root.displayName\n\nexport { Progress }\n","path":null,"size_bytes":792,"size_tokens":null},"client/src/components/ui/label.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst labelVariants = cva(\n  \"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\"\n)\n\nconst Label = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &\n    VariantProps<typeof labelVariants>\n>(({ className, ...props }, ref) => (\n  <LabelPrimitive.Root\n    ref={ref}\n    className={cn(labelVariants(), className)}\n    {...props}\n  />\n))\nLabel.displayName = LabelPrimitive.Root.displayName\n\nexport { Label }\n","path":null,"size_bytes":724,"size_tokens":null},"client/src/components/ui/chart.tsx":{"content":"import * as React from \"react\"\nimport * as RechartsPrimitive from \"recharts\"\n\nimport { cn } from \"@/lib/utils\"\n\n// Format: { THEME_NAME: CSS_SELECTOR }\nconst THEMES = { light: \"\", dark: \".dark\" } as const\n\nexport type ChartConfig = {\n  [k in string]: {\n    label?: React.ReactNode\n    icon?: React.ComponentType\n  } & (\n    | { color?: string; theme?: never }\n    | { color?: never; theme: Record<keyof typeof THEMES, string> }\n  )\n}\n\ntype ChartContextProps = {\n  config: ChartConfig\n}\n\nconst ChartContext = React.createContext<ChartContextProps | null>(null)\n\nfunction useChart() {\n  const context = React.useContext(ChartContext)\n\n  if (!context) {\n    throw new Error(\"useChart must be used within a <ChartContainer />\")\n  }\n\n  return context\n}\n\nconst ChartContainer = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    config: ChartConfig\n    children: React.ComponentProps<\n      typeof RechartsPrimitive.ResponsiveContainer\n    >[\"children\"]\n  }\n>(({ id, className, children, config, ...props }, ref) => {\n  const uniqueId = React.useId()\n  const chartId = `chart-${id || uniqueId.replace(/:/g, \"\")}`\n\n  return (\n    <ChartContext.Provider value={{ config }}>\n      <div\n        data-chart={chartId}\n        ref={ref}\n        className={cn(\n          \"flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none\",\n          className\n        )}\n        {...props}\n      >\n        <ChartStyle id={chartId} config={config} />\n        <RechartsPrimitive.ResponsiveContainer>\n          {children}\n        </RechartsPrimitive.ResponsiveContainer>\n      </div>\n    </ChartContext.Provider>\n  )\n})\nChartContainer.displayName = \"Chart\"\n\nconst ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {\n  const colorConfig = Object.entries(config).filter(\n    ([, config]) => config.theme || config.color\n  )\n\n  if (!colorConfig.length) {\n    return null\n  }\n\n  return (\n    <style\n      dangerouslySetInnerHTML={{\n        __html: Object.entries(THEMES)\n          .map(\n            ([theme, prefix]) => `\n${prefix} [data-chart=${id}] {\n${colorConfig\n  .map(([key, itemConfig]) => {\n    const color =\n      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||\n      itemConfig.color\n    return color ? `  --color-${key}: ${color};` : null\n  })\n  .join(\"\\n\")}\n}\n`\n          )\n          .join(\"\\n\"),\n      }}\n    />\n  )\n}\n\nconst ChartTooltip = RechartsPrimitive.Tooltip\n\nconst ChartTooltipContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &\n    React.ComponentProps<\"div\"> & {\n      hideLabel?: boolean\n      hideIndicator?: boolean\n      indicator?: \"line\" | \"dot\" | \"dashed\"\n      nameKey?: string\n      labelKey?: string\n    }\n>(\n  (\n    {\n      active,\n      payload,\n      className,\n      indicator = \"dot\",\n      hideLabel = false,\n      hideIndicator = false,\n      label,\n      labelFormatter,\n      labelClassName,\n      formatter,\n      color,\n      nameKey,\n      labelKey,\n    },\n    ref\n  ) => {\n    const { config } = useChart()\n\n    const tooltipLabel = React.useMemo(() => {\n      if (hideLabel || !payload?.length) {\n        return null\n      }\n\n      const [item] = payload\n      const key = `${labelKey || item?.dataKey || item?.name || \"value\"}`\n      const itemConfig = getPayloadConfigFromPayload(config, item, key)\n      const value =\n        !labelKey && typeof label === \"string\"\n          ? config[label as keyof typeof config]?.label || label\n          : itemConfig?.label\n\n      if (labelFormatter) {\n        return (\n          <div className={cn(\"font-medium\", labelClassName)}>\n            {labelFormatter(value, payload)}\n          </div>\n        )\n      }\n\n      if (!value) {\n        return null\n      }\n\n      return <div className={cn(\"font-medium\", labelClassName)}>{value}</div>\n    }, [\n      label,\n      labelFormatter,\n      payload,\n      hideLabel,\n      labelClassName,\n      config,\n      labelKey,\n    ])\n\n    if (!active || !payload?.length) {\n      return null\n    }\n\n    const nestLabel = payload.length === 1 && indicator !== \"dot\"\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          \"grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl\",\n          className\n        )}\n      >\n        {!nestLabel ? tooltipLabel : null}\n        <div className=\"grid gap-1.5\">\n          {payload\n            .filter((item) => item.type !== \"none\")\n            .map((item, index) => {\n              const key = `${nameKey || item.name || item.dataKey || \"value\"}`\n              const itemConfig = getPayloadConfigFromPayload(config, item, key)\n              const indicatorColor = color || item.payload.fill || item.color\n\n              return (\n                <div\n                  key={item.dataKey}\n                  className={cn(\n                    \"flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground\",\n                    indicator === \"dot\" && \"items-center\"\n                  )}\n                >\n                  {formatter && item?.value !== undefined && item.name ? (\n                    formatter(item.value, item.name, item, index, item.payload)\n                  ) : (\n                    <>\n                      {itemConfig?.icon ? (\n                        <itemConfig.icon />\n                      ) : (\n                        !hideIndicator && (\n                          <div\n                            className={cn(\n                              \"shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]\",\n                              {\n                                \"h-2.5 w-2.5\": indicator === \"dot\",\n                                \"w-1\": indicator === \"line\",\n                                \"w-0 border-[1.5px] border-dashed bg-transparent\":\n                                  indicator === \"dashed\",\n                                \"my-0.5\": nestLabel && indicator === \"dashed\",\n                              }\n                            )}\n                            style={\n                              {\n                                \"--color-bg\": indicatorColor,\n                                \"--color-border\": indicatorColor,\n                              } as React.CSSProperties\n                            }\n                          />\n                        )\n                      )}\n                      <div\n                        className={cn(\n                          \"flex flex-1 justify-between leading-none\",\n                          nestLabel ? \"items-end\" : \"items-center\"\n                        )}\n                      >\n                        <div className=\"grid gap-1.5\">\n                          {nestLabel ? tooltipLabel : null}\n                          <span className=\"text-muted-foreground\">\n                            {itemConfig?.label || item.name}\n                          </span>\n                        </div>\n                        {item.value && (\n                          <span className=\"font-mono font-medium tabular-nums text-foreground\">\n                            {item.value.toLocaleString()}\n                          </span>\n                        )}\n                      </div>\n                    </>\n                  )}\n                </div>\n              )\n            })}\n        </div>\n      </div>\n    )\n  }\n)\nChartTooltipContent.displayName = \"ChartTooltip\"\n\nconst ChartLegend = RechartsPrimitive.Legend\n\nconst ChartLegendContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> &\n    Pick<RechartsPrimitive.LegendProps, \"payload\" | \"verticalAlign\"> & {\n      hideIcon?: boolean\n      nameKey?: string\n    }\n>(\n  (\n    { className, hideIcon = false, payload, verticalAlign = \"bottom\", nameKey },\n    ref\n  ) => {\n    const { config } = useChart()\n\n    if (!payload?.length) {\n      return null\n    }\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          \"flex items-center justify-center gap-4\",\n          verticalAlign === \"top\" ? \"pb-3\" : \"pt-3\",\n          className\n        )}\n      >\n        {payload\n          .filter((item) => item.type !== \"none\")\n          .map((item) => {\n            const key = `${nameKey || item.dataKey || \"value\"}`\n            const itemConfig = getPayloadConfigFromPayload(config, item, key)\n\n            return (\n              <div\n                key={item.value}\n                className={cn(\n                  \"flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground\"\n                )}\n              >\n                {itemConfig?.icon && !hideIcon ? (\n                  <itemConfig.icon />\n                ) : (\n                  <div\n                    className=\"h-2 w-2 shrink-0 rounded-[2px]\"\n                    style={{\n                      backgroundColor: item.color,\n                    }}\n                  />\n                )}\n                {itemConfig?.label}\n              </div>\n            )\n          })}\n      </div>\n    )\n  }\n)\nChartLegendContent.displayName = \"ChartLegend\"\n\n// Helper to extract item config from a payload.\nfunction getPayloadConfigFromPayload(\n  config: ChartConfig,\n  payload: unknown,\n  key: string\n) {\n  if (typeof payload !== \"object\" || payload === null) {\n    return undefined\n  }\n\n  const payloadPayload =\n    \"payload\" in payload &&\n    typeof payload.payload === \"object\" &&\n    payload.payload !== null\n      ? payload.payload\n      : undefined\n\n  let configLabelKey: string = key\n\n  if (\n    key in payload &&\n    typeof payload[key as keyof typeof payload] === \"string\"\n  ) {\n    configLabelKey = payload[key as keyof typeof payload] as string\n  } else if (\n    payloadPayload &&\n    key in payloadPayload &&\n    typeof payloadPayload[key as keyof typeof payloadPayload] === \"string\"\n  ) {\n    configLabelKey = payloadPayload[\n      key as keyof typeof payloadPayload\n    ] as string\n  }\n\n  return configLabelKey in config\n    ? config[configLabelKey]\n    : config[key as keyof typeof config]\n}\n\nexport {\n  ChartContainer,\n  ChartTooltip,\n  ChartTooltipContent,\n  ChartLegend,\n  ChartLegendContent,\n  ChartStyle,\n}\n","path":null,"size_bytes":10763,"size_tokens":null},"client/src/components/ui/kbd.tsx":{"content":"import { cn } from \"@/lib/utils\"\n\nfunction Kbd({ className, ...props }: React.ComponentProps<\"kbd\">) {\n  return (\n    <kbd\n      data-slot=\"kbd\"\n      className={cn(\n        \"bg-muted text-muted-foreground pointer-events-none inline-flex h-5 w-fit min-w-5 select-none items-center justify-center gap-1 rounded-sm px-1 font-sans text-xs font-medium\",\n        \"[&_svg:not([class*='size-'])]:size-3\",\n        \"[[data-slot=tooltip-content]_&]:bg-background/20 [[data-slot=tooltip-content]_&]:text-background dark:[[data-slot=tooltip-content]_&]:bg-background/10\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction KbdGroup({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <kbd\n      data-slot=\"kbd-group\"\n      className={cn(\"inline-flex items-center gap-1\", className)}\n      {...props}\n    />\n  )\n}\n\nexport { Kbd, KbdGroup }\n","path":null,"size_bytes":862,"size_tokens":null},"client/src/components/ui/tooltip.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as TooltipPrimitive from \"@radix-ui/react-tooltip\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst TooltipProvider = TooltipPrimitive.Provider\n\nconst Tooltip = TooltipPrimitive.Root\n\nconst TooltipTrigger = TooltipPrimitive.Trigger\n\nconst TooltipContent = React.forwardRef<\n  React.ElementRef<typeof TooltipPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>\n>(({ className, sideOffset = 4, ...props }, ref) => (\n  <TooltipPrimitive.Portal>\n    <TooltipPrimitive.Content\n      ref={ref}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]\",\n        className\n      )}\n      {...props}\n    />\n  </TooltipPrimitive.Portal>\n))\nTooltipContent.displayName = TooltipPrimitive.Content.displayName\n\nexport { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }\n","path":null,"size_bytes":1267,"size_tokens":null},"client/src/components/ui/menubar.tsx":{"content":"import * as React from \"react\"\nimport * as MenubarPrimitive from \"@radix-ui/react-menubar\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction MenubarMenu({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {\n  return <MenubarPrimitive.Menu {...props} />\n}\n\nfunction MenubarGroup({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Group>) {\n  return <MenubarPrimitive.Group {...props} />\n}\n\nfunction MenubarPortal({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {\n  return <MenubarPrimitive.Portal {...props} />\n}\n\nfunction MenubarRadioGroup({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {\n  return <MenubarPrimitive.RadioGroup {...props} />\n}\n\nfunction MenubarSub({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {\n  return <MenubarPrimitive.Sub data-slot=\"menubar-sub\" {...props} />\n}\n\nconst Menubar = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"flex h-9 items-center space-x-1 rounded-md border bg-background p-1 shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubar.displayName = MenubarPrimitive.Root.displayName\n\nconst MenubarTrigger = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-3 py-1 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName\n\nconst MenubarSubTrigger = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <MenubarPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto h-4 w-4\" />\n  </MenubarPrimitive.SubTrigger>\n))\nMenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName\n\nconst MenubarSubContent = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName\n\nconst MenubarContent = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>\n>(\n  (\n    { className, align = \"start\", alignOffset = -4, sideOffset = 8, ...props },\n    ref\n  ) => (\n    <MenubarPrimitive.Portal>\n      <MenubarPrimitive.Content\n        ref={ref}\n        align={align}\n        alignOffset={alignOffset}\n        sideOffset={sideOffset}\n        className={cn(\n          \"z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]\",\n          className\n        )}\n        {...props}\n      />\n    </MenubarPrimitive.Portal>\n  )\n)\nMenubarContent.displayName = MenubarPrimitive.Content.displayName\n\nconst MenubarItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <MenubarPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarItem.displayName = MenubarPrimitive.Item.displayName\n\nconst MenubarCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <MenubarPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <MenubarPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </MenubarPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </MenubarPrimitive.CheckboxItem>\n))\nMenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName\n\nconst MenubarRadioItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <MenubarPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <MenubarPrimitive.ItemIndicator>\n        <Circle className=\"h-4 w-4 fill-current\" />\n      </MenubarPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </MenubarPrimitive.RadioItem>\n))\nMenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName\n\nconst MenubarLabel = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <MenubarPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarLabel.displayName = MenubarPrimitive.Label.displayName\n\nconst MenubarSeparator = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nMenubarSeparator.displayName = MenubarPrimitive.Separator.displayName\n\nconst MenubarShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nMenubarShortcut.displayname = \"MenubarShortcut\"\n\nexport {\n  Menubar,\n  MenubarMenu,\n  MenubarTrigger,\n  MenubarContent,\n  MenubarItem,\n  MenubarSeparator,\n  MenubarLabel,\n  MenubarCheckboxItem,\n  MenubarRadioGroup,\n  MenubarRadioItem,\n  MenubarPortal,\n  MenubarSubContent,\n  MenubarSubTrigger,\n  MenubarGroup,\n  MenubarSub,\n  MenubarShortcut,\n}\n","path":null,"size_bytes":8608,"size_tokens":null},"client/src/components/ui/alert-dialog.tsx":{"content":"import * as React from \"react\"\nimport * as AlertDialogPrimitive from \"@radix-ui/react-alert-dialog\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nconst AlertDialog = AlertDialogPrimitive.Root\n\nconst AlertDialogTrigger = AlertDialogPrimitive.Trigger\n\nconst AlertDialogPortal = AlertDialogPrimitive.Portal\n\nconst AlertDialogOverlay = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Overlay\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  />\n))\nAlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName\n\nconst AlertDialogContent = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPortal>\n    <AlertDialogOverlay />\n    <AlertDialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    />\n  </AlertDialogPortal>\n))\nAlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName\n\nconst AlertDialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogHeader.displayName = \"AlertDialogHeader\"\n\nconst AlertDialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogFooter.displayName = \"AlertDialogFooter\"\n\nconst AlertDialogTitle = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold\", className)}\n    {...props}\n  />\n))\nAlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName\n\nconst AlertDialogDescription = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nAlertDialogDescription.displayName =\n  AlertDialogPrimitive.Description.displayName\n\nconst AlertDialogAction = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Action>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Action\n    ref={ref}\n    className={cn(buttonVariants(), className)}\n    {...props}\n  />\n))\nAlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName\n\nconst AlertDialogCancel = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Cancel\n    ref={ref}\n    className={cn(\n      buttonVariants({ variant: \"outline\" }),\n      \"mt-2 sm:mt-0\",\n      className\n    )}\n    {...props}\n  />\n))\nAlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName\n\nexport {\n  AlertDialog,\n  AlertDialogPortal,\n  AlertDialogOverlay,\n  AlertDialogTrigger,\n  AlertDialogContent,\n  AlertDialogHeader,\n  AlertDialogFooter,\n  AlertDialogTitle,\n  AlertDialogDescription,\n  AlertDialogAction,\n  AlertDialogCancel,\n}\n","path":null,"size_bytes":4419,"size_tokens":null},"client/src/components/ui/aspect-ratio.tsx":{"content":"import * as AspectRatioPrimitive from \"@radix-ui/react-aspect-ratio\"\n\nconst AspectRatio = AspectRatioPrimitive.Root\n\nexport { AspectRatio }\n","path":null,"size_bytes":140,"size_tokens":null},"client/src/components/ui/textarea.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Textarea = React.forwardRef<\n  HTMLTextAreaElement,\n  React.ComponentProps<\"textarea\">\n>(({ className, ...props }, ref) => {\n  return (\n    <textarea\n      className={cn(\n        \"flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-base shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        className\n      )}\n      ref={ref}\n      {...props}\n    />\n  )\n})\nTextarea.displayName = \"Textarea\"\n\nexport { Textarea }\n","path":null,"size_bytes":649,"size_tokens":null},"client/src/App.tsx":{"content":"import { Switch, Route } from \"wouter\";\nimport { queryClient } from \"./lib/queryClient\";\nimport { QueryClientProvider } from \"@tanstack/react-query\";\nimport { Toaster } from \"@/components/ui/toaster\";\nimport { TooltipProvider } from \"@/components/ui/tooltip\";\nimport { EventsWebSocketProvider } from \"@/context/EventsWebSocketContext\";\nimport Dashboard from \"@/pages/Dashboard\";\nimport Settings from \"@/pages/Settings\";\nimport Terminal from \"@/pages/Terminal\";\nimport Strategies from \"@/pages/Strategies\";\nimport Wallet from \"@/pages/Wallet\";\nimport Integrations from \"@/pages/Integrations\";\nimport Guide from \"@/pages/Guide\";\nimport Monitor from \"@/pages/Monitor\";\nimport NotFound from \"@/pages/not-found\";\n\nfunction Router() {\n  return (\n    <Switch>\n      <Route path=\"/\" component={Dashboard} />\n      <Route path=\"/settings\" component={Settings} />\n      <Route path=\"/terminal\" component={Terminal} />\n      <Route path=\"/strategies\" component={Strategies} />\n      <Route path=\"/wallet\" component={Wallet} />\n      <Route path=\"/integrations\" component={Integrations} />\n      <Route path=\"/guide\" component={Guide} />\n      <Route path=\"/monitor\" component={Monitor} />\n      \n      <Route component={NotFound} />\n    </Switch>\n  );\n}\n\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <TooltipProvider>\n        <EventsWebSocketProvider>\n          <Toaster />\n          <Router />\n        </EventsWebSocketProvider>\n      </TooltipProvider>\n    </QueryClientProvider>\n  );\n}\n\nexport default App;\n","path":null,"size_bytes":1535,"size_tokens":null},"client/src/components/ui/sonner.tsx":{"content":"\"use client\"\n\nimport { useTheme } from \"next-themes\"\nimport { Toaster as Sonner } from \"sonner\"\n\ntype ToasterProps = React.ComponentProps<typeof Sonner>\n\nconst Toaster = ({ ...props }: ToasterProps) => {\n  const { theme = \"system\" } = useTheme()\n\n  return (\n    <Sonner\n      theme={theme as ToasterProps[\"theme\"]}\n      className=\"toaster group\"\n      toastOptions={{\n        classNames: {\n          toast:\n            \"group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg\",\n          description: \"group-[.toast]:text-muted-foreground\",\n          actionButton:\n            \"group-[.toast]:bg-primary group-[.toast]:text-primary-foreground\",\n          cancelButton:\n            \"group-[.toast]:bg-muted group-[.toast]:text-muted-foreground\",\n        },\n      }}\n      {...props}\n    />\n  )\n}\n\nexport { Toaster }\n","path":null,"size_bytes":894,"size_tokens":null},"client/src/components/dashboard/AssetCard.tsx":{"content":"import { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { cn } from \"@/lib/utils\";\nimport { ArrowUp, ArrowDown, Wallet } from \"lucide-react\";\n\ninterface AssetCardProps {\n  symbol: string;\n  name: string;\n  balance: string;\n  value: string;\n  change: number; // percentage\n}\n\nexport function AssetCard({ symbol, name, balance, value, change }: AssetCardProps) {\n  const isPositive = change >= 0;\n\n  return (\n    <Card className=\"glass-panel border-border/50 shadow-lg relative overflow-hidden group\">\n      <div className=\"absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity hidden sm:block\">\n        <Wallet className=\"h-16 md:h-24 w-16 md:w-24 -mr-6 md:-mr-8 -mt-6 md:-mt-8 rotate-12\" />\n      </div>\n      <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-1 md:pb-2 px-3 md:px-6 pt-3 md:pt-6\">\n        <CardTitle className=\"text-xs md:text-sm font-medium font-mono text-muted-foreground truncate\">\n          <span className=\"hidden sm:inline\">{name}</span>\n          <span className=\"sm:hidden\">{symbol}</span>\n          <span className=\"text-primary/50 ml-1 md:ml-2 hidden sm:inline\">[{symbol}]</span>\n        </CardTitle>\n        {isPositive ? (\n          <ArrowUp className=\"h-3 w-3 md:h-4 md:w-4 text-green-500 shrink-0\" />\n        ) : (\n          <ArrowDown className=\"h-3 w-3 md:h-4 md:w-4 text-red-500 shrink-0\" />\n        )}\n      </CardHeader>\n      <CardContent className=\"px-3 md:px-6 pb-3 md:pb-6\">\n        <div className=\"text-lg md:text-2xl font-bold font-mono tracking-tighter truncate\">{value}</div>\n        <p className=\"text-[10px] md:text-xs text-muted-foreground mt-1 font-mono\">\n          <span className=\"hidden sm:inline\">{balance} {symbol}</span>\n          <span className={cn(\"sm:ml-2\", isPositive ? \"text-green-500\" : \"text-red-500\")}>\n            {isPositive ? \"+\" : \"\"}{change}%\n          </span>\n        </p>\n      </CardContent>\n    </Card>\n  );\n}\n","path":null,"size_bytes":1969,"size_tokens":null},"client/src/components/ui/collapsible.tsx":{"content":"\"use client\"\n\nimport * as CollapsiblePrimitive from \"@radix-ui/react-collapsible\"\n\nconst Collapsible = CollapsiblePrimitive.Root\n\nconst CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger\n\nconst CollapsibleContent = CollapsiblePrimitive.CollapsibleContent\n\nexport { Collapsible, CollapsibleTrigger, CollapsibleContent }\n","path":null,"size_bytes":329,"size_tokens":null},"client/src/main.tsx":{"content":"import { createRoot } from \"react-dom/client\";\nimport App from \"./App\";\nimport \"./index.css\";\n\ncreateRoot(document.getElementById(\"root\")!).render(<App />);\n","path":null,"size_bytes":157,"size_tokens":null},"server/services/kraken.ts":{"content":"import * as KrakenAPI from \"node-kraken-api\";\nimport { telegramService } from \"./telegram\";\nimport { storage } from \"../storage\";\n\nconst { Kraken } = KrakenAPI as any;\n\ninterface KrakenConfig {\n  apiKey: string;\n  apiSecret: string;\n}\n\nexport interface PairMetadata {\n  lotDecimals: number;\n  orderMin: number;\n  pairDecimals: number;\n  stepSize: number;\n}\n\nconst NONCE_ALERT_INTERVAL_MS = 30 * 60 * 1000;\nconst MAX_RETRIES = 3;\nconst RETRY_DELAYS = [500, 1000, 2000];\nconst METADATA_REFRESH_INTERVAL_MS = 6 * 60 * 60 * 1000; // 6 hours\n\nexport class KrakenService {\n  private client: any | null = null;\n  private publicClient: any;\n  private lastNonceAlertTime: number = 0;\n  private lastNonce: number = 0;\n  private pairMetadataCache: Map<string, PairMetadata> = new Map();\n  private metadataLastRefresh: number = 0;\n  private metadataRefreshTimer: NodeJS.Timeout | null = null;\n\n  constructor() {\n    this.publicClient = new Kraken();\n  }\n\n  async loadPairMetadata(pairs: string[]): Promise<void> {\n    try {\n      console.log(`[kraken] Loading pair metadata for: ${pairs.join(\", \")}`);\n      const response = await this.publicClient.assetPairs();\n      \n      for (const pair of pairs) {\n        const krakenPair = this.formatPair(pair);\n        const pairData = response[krakenPair];\n        \n        if (pairData) {\n          const lotDecimals = pairData.lot_decimals || 8;\n          const orderMin = parseFloat(pairData.ordermin) || 0.01;\n          const pairDecimals = pairData.pair_decimals || 5;\n          const stepSize = Math.pow(10, -lotDecimals);\n          \n          this.pairMetadataCache.set(pair, {\n            lotDecimals,\n            orderMin,\n            pairDecimals,\n            stepSize,\n          });\n          \n          console.log(`[kraken] ${pair}: lotDecimals=${lotDecimals}, orderMin=${orderMin}, stepSize=${stepSize}`);\n        } else {\n          console.warn(`[kraken] No metadata found for ${pair} (${krakenPair})`);\n        }\n      }\n      \n      this.metadataLastRefresh = Date.now();\n      console.log(`[kraken] Pair metadata loaded successfully for ${this.pairMetadataCache.size} pairs`);\n    } catch (error: any) {\n      console.error(`[kraken] Failed to load pair metadata: ${error.message}`);\n      if (this.pairMetadataCache.size === 0) {\n        console.error(`[kraken] CRITICAL: No pair metadata available - trades will be skipped`);\n      }\n    }\n  }\n\n  startMetadataRefresh(pairs: string[]): void {\n    if (this.metadataRefreshTimer) {\n      clearInterval(this.metadataRefreshTimer);\n    }\n    \n    this.metadataRefreshTimer = setInterval(async () => {\n      console.log(`[kraken] Refreshing pair metadata...`);\n      await this.loadPairMetadata(pairs);\n    }, METADATA_REFRESH_INTERVAL_MS);\n    \n    console.log(`[kraken] Metadata refresh scheduled every ${METADATA_REFRESH_INTERVAL_MS / 3600000}h`);\n  }\n\n  getPairMetadata(pair: string): PairMetadata | null {\n    return this.pairMetadataCache.get(pair) || null;\n  }\n\n  getStepSize(pair: string): number | null {\n    const metadata = this.pairMetadataCache.get(pair);\n    return metadata ? metadata.stepSize : null;\n  }\n\n  getOrderMin(pair: string): number | null {\n    const metadata = this.pairMetadataCache.get(pair);\n    return metadata ? metadata.orderMin : null;\n  }\n\n  hasMetadata(pair: string): boolean {\n    return this.pairMetadataCache.has(pair);\n  }\n\n  initialize(config: KrakenConfig) {\n    this.client = new Kraken({\n      key: config.apiKey,\n      secret: config.apiSecret,\n      gennonce: () => this.generateNonce(),\n    });\n  }\n\n  private generateNonce(): number {\n    let nonce = Date.now() * 1000 + Math.floor(Math.random() * 1000);\n    if (nonce <= this.lastNonce) {\n      nonce = this.lastNonce + 1;\n    }\n    this.lastNonce = nonce;\n    return nonce;\n  }\n\n  isInitialized(): boolean {\n    return this.client !== null;\n  }\n\n  private async executeWithNonceRetry<T>(\n    endpoint: string,\n    operation: () => Promise<T>\n  ): Promise<T> {\n    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {\n      try {\n        if (attempt > 1) {\n          await new Promise(resolve => setTimeout(resolve, RETRY_DELAYS[attempt - 2]));\n        }\n        return await operation();\n      } catch (error: any) {\n        const isNonceError = error.message?.includes(\"EAPI:Invalid nonce\") || \n                            error.message?.includes(\"Invalid nonce\");\n        \n        if (isNonceError) {\n          console.log(`[kraken] Nonce error on '${endpoint}', retrying (${attempt}/${MAX_RETRIES})...`);\n          \n          if (attempt === MAX_RETRIES) {\n            console.error(`[kraken] CRITICAL: Persistent nonce error on '${endpoint}' after ${attempt}/${MAX_RETRIES} attempts`);\n            await this.sendNonceAlert(endpoint);\n            throw new Error(`Persistent nonce error on '${endpoint}' - possible duplicate instance running`);\n          }\n          continue;\n        }\n        throw error;\n      }\n    }\n    throw new Error(`Failed after ${MAX_RETRIES} retries on '${endpoint}'`);\n  }\n\n  private async sendNonceAlert(endpoint: string): Promise<void> {\n    const now = Date.now();\n    \n    if (now - this.lastNonceAlertTime < NONCE_ALERT_INTERVAL_MS) {\n      console.log(`[kraken] Skipping Telegram nonce alert (rate limited, last sent ${Math.round((now - this.lastNonceAlertTime) / 1000)}s ago)`);\n      return;\n    }\n\n    try {\n      const config = await storage.getBotConfig();\n      if (config && config.nonceErrorAlertsEnabled === false) {\n        console.log(`[kraken] Nonce error alerts disabled in config, skipping Telegram notification`);\n        return;\n      }\n\n      await telegramService.sendAlert(\n        \"Error de Nonce con Kraken\",\n        `Error persistente de nonce en '${endpoint}' despuÃ©s de 3 intentos.\\n\\n` +\n        `âš ï¸ Verifica que no haya otra instancia del bot usando la misma API key de Kraken.\\n\\n` +\n        `_Este mensaje se enviarÃ¡ mÃ¡ximo cada 30 minutos mientras persista el problema._`\n      );\n      this.lastNonceAlertTime = now;\n      console.log(`[kraken] Nonce alert sent to Telegram`);\n    } catch (alertError) {\n      console.error(`[kraken] Failed to send nonce alert to Telegram:`, alertError);\n    }\n  }\n\n  async getBalance() {\n    if (!this.client) throw new Error(\"Kraken client not initialized\");\n    return await this.executeWithNonceRetry(\"getBalance\", () => this.client.balance());\n  }\n\n  async getTicker(pair: string) {\n    const krakenPair = this.formatPair(pair);\n    const response = await this.publicClient.ticker({ pair: krakenPair });\n    return response;\n  }\n\n  async getAssetPairs() {\n    return await this.publicClient.assetPairs();\n  }\n\n  async placeOrder(params: {\n    pair: string;\n    type: \"buy\" | \"sell\";\n    ordertype: string;\n    price?: string;\n    volume: string;\n  }) {\n    if (!this.client) throw new Error(\"Kraken client not initialized\");\n    \n    const krakenPair = this.formatPair(params.pair);\n    const orderParams: any = {\n      pair: krakenPair,\n      type: params.type,\n      ordertype: params.ordertype,\n      volume: params.volume,\n    };\n\n    if (params.price) {\n      orderParams.price = params.price;\n    }\n\n    return await this.executeWithNonceRetry(\"addOrder\", () => this.client.addOrder(orderParams));\n  }\n\n  async cancelOrder(txid: string) {\n    if (!this.client) throw new Error(\"Kraken client not initialized\");\n    return await this.executeWithNonceRetry(\"cancelOrder\", () => this.client.cancelOrder({ txid }));\n  }\n\n  async getOpenOrders() {\n    if (!this.client) throw new Error(\"Kraken client not initialized\");\n    return await this.executeWithNonceRetry(\"openOrders\", () => this.client.openOrders());\n  }\n\n  async getClosedOrders(limit: number = 50) {\n    if (!this.client) throw new Error(\"Kraken client not initialized\");\n    return await this.executeWithNonceRetry(\"closedOrders\", () => this.client.closedOrders({ ofs: 0 }));\n  }\n\n  async getTradesHistory(options?: { start?: number; end?: number; fetchAll?: boolean }): Promise<any> {\n    if (!this.client) throw new Error(\"Kraken client not initialized\");\n    \n    const params: any = { type: \"all\" };\n    if (options?.start) params.start = options.start;\n    if (options?.end) params.end = options.end;\n    \n    // Si no se pide todo el historial, devolver solo la primera pÃ¡gina\n    if (!options?.fetchAll) {\n      return await this.executeWithNonceRetry(\"tradesHistory\", () => this.client.tradesHistory(params));\n    }\n    \n    // Fetch all trades with pagination\n    const allTrades: Record<string, any> = {};\n    let offset = 0;\n    let totalCount = 0;\n    const RATE_LIMIT_DELAY = 2000; // 2 segundos entre llamadas\n    \n    console.log(\"[kraken] Fetching all trades history with pagination...\");\n    \n    while (true) {\n      const paginatedParams = { ...params, ofs: offset };\n      \n      const response: any = await this.executeWithNonceRetry(\"tradesHistory\", () => \n        this.client.tradesHistory(paginatedParams)\n      );\n      \n      const trades = response.trades || {};\n      const count = response.count || 0;\n      \n      if (offset === 0) {\n        totalCount = count;\n        console.log(`[kraken] Total trades in Kraken: ${totalCount}`);\n      }\n      \n      const tradeIds = Object.keys(trades);\n      if (tradeIds.length === 0) {\n        console.log(`[kraken] No more trades at offset ${offset}`);\n        break;\n      }\n      \n      // Merge trades\n      for (const [id, trade] of Object.entries(trades)) {\n        allTrades[id] = trade;\n      }\n      \n      console.log(`[kraken] Fetched ${tradeIds.length} trades at offset ${offset}, total collected: ${Object.keys(allTrades).length}`);\n      \n      offset += 50;\n      \n      if (offset >= totalCount) {\n        console.log(`[kraken] Reached end of trades history`);\n        break;\n      }\n      \n      // Rate limiting - esperar entre llamadas\n      await new Promise(resolve => setTimeout(resolve, RATE_LIMIT_DELAY));\n    }\n    \n    console.log(`[kraken] Finished fetching ${Object.keys(allTrades).length} total trades`);\n    \n    return { trades: allTrades, count: Object.keys(allTrades).length };\n  }\n\n  async getOHLC(pair: string, interval: number = 5): Promise<{\n    time: number;\n    open: number;\n    high: number;\n    low: number;\n    close: number;\n    volume: number;\n  }[]> {\n    const krakenPair = this.formatPair(pair);\n    const response = await this.publicClient.ohlc({ pair: krakenPair, interval });\n    \n    const pairData = Object.values(response).find(Array.isArray) as any[];\n    if (!pairData) return [];\n    \n    return pairData.map((candle: any[]) => ({\n      time: candle[0],\n      open: parseFloat(candle[1]),\n      high: parseFloat(candle[2]),\n      low: parseFloat(candle[3]),\n      close: parseFloat(candle[4]),\n      volume: parseFloat(candle[6]),\n    }));\n  }\n\n  formatPairReverse(krakenPair: string): string {\n    const pairMap: Record<string, string> = {\n      \"XXBTZUSD\": \"BTC/USD\",\n      \"XETHZUSD\": \"ETH/USD\",\n      \"SOLUSD\": \"SOL/USD\",\n      \"XXRPZUSD\": \"XRP/USD\",\n      \"XRPUSD\": \"XRP/USD\",\n      \"TONUSD\": \"TON/USD\",\n      \"XXBTZXETH\": \"BTC/ETH\",\n      \"XETHXXBT\": \"ETH/BTC\",\n      \"ETHXBT\": \"ETH/BTC\",\n      \"SOLETH\": \"SOL/ETH\",\n    };\n    return pairMap[krakenPair] || krakenPair;\n  }\n\n  formatPair(pair: string): string {\n    const pairMap: Record<string, string> = {\n      \"BTC/USD\": \"XXBTZUSD\",\n      \"ETH/USD\": \"XETHZUSD\",\n      \"SOL/USD\": \"SOLUSD\",\n      \"XRP/USD\": \"XXRPZUSD\",\n      \"TON/USD\": \"TONUSD\",\n      \"ETH/BTC\": \"XETHXXBT\",\n      \"BTC/ETH\": \"XXBTZXETH\",\n      \"SOL/ETH\": \"SOLETH\",\n    };\n    return pairMap[pair] || pair;\n  }\n}\n\nexport const krakenService = new KrakenService();\n","path":null,"size_bytes":11600,"size_tokens":null},"client/src/components/ui/navigation-menu.tsx":{"content":"import * as React from \"react\"\nimport * as NavigationMenuPrimitive from \"@radix-ui/react-navigation-menu\"\nimport { cva } from \"class-variance-authority\"\nimport { ChevronDown } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst NavigationMenu = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>\n>(({ className, children, ...props }, ref) => (\n  <NavigationMenuPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative z-10 flex max-w-max flex-1 items-center justify-center\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <NavigationMenuViewport />\n  </NavigationMenuPrimitive.Root>\n))\nNavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName\n\nconst NavigationMenuList = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.List\n    ref={ref}\n    className={cn(\n      \"group flex flex-1 list-none items-center justify-center space-x-1\",\n      className\n    )}\n    {...props}\n  />\n))\nNavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName\n\nconst NavigationMenuItem = NavigationMenuPrimitive.Item\n\nconst navigationMenuTriggerStyle = cva(\n  \"group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[state=open]:text-accent-foreground data-[state=open]:bg-accent/50 data-[state=open]:hover:bg-accent data-[state=open]:focus:bg-accent\"\n)\n\nconst NavigationMenuTrigger = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <NavigationMenuPrimitive.Trigger\n    ref={ref}\n    className={cn(navigationMenuTriggerStyle(), \"group\", className)}\n    {...props}\n  >\n    {children}{\" \"}\n    <ChevronDown\n      className=\"relative top-[1px] ml-1 h-3 w-3 transition duration-300 group-data-[state=open]:rotate-180\"\n      aria-hidden=\"true\"\n    />\n  </NavigationMenuPrimitive.Trigger>\n))\nNavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName\n\nconst NavigationMenuContent = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.Content\n    ref={ref}\n    className={cn(\n      \"left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto \",\n      className\n    )}\n    {...props}\n  />\n))\nNavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName\n\nconst NavigationMenuLink = NavigationMenuPrimitive.Link\n\nconst NavigationMenuViewport = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>\n>(({ className, ...props }, ref) => (\n  <div className={cn(\"absolute left-0 top-full flex justify-center\")}>\n    <NavigationMenuPrimitive.Viewport\n      className={cn(\n        \"origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]\",\n        className\n      )}\n      ref={ref}\n      {...props}\n    />\n  </div>\n))\nNavigationMenuViewport.displayName =\n  NavigationMenuPrimitive.Viewport.displayName\n\nconst NavigationMenuIndicator = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.Indicator\n    ref={ref}\n    className={cn(\n      \"top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in\",\n      className\n    )}\n    {...props}\n  >\n    <div className=\"relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md\" />\n  </NavigationMenuPrimitive.Indicator>\n))\nNavigationMenuIndicator.displayName =\n  NavigationMenuPrimitive.Indicator.displayName\n\nexport {\n  navigationMenuTriggerStyle,\n  NavigationMenu,\n  NavigationMenuList,\n  NavigationMenuItem,\n  NavigationMenuContent,\n  NavigationMenuTrigger,\n  NavigationMenuLink,\n  NavigationMenuIndicator,\n  NavigationMenuViewport,\n}\n","path":null,"size_bytes":5124,"size_tokens":null},"client/src/components/ui/toggle-group.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as ToggleGroupPrimitive from \"@radix-ui/react-toggle-group\"\nimport { type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\nimport { toggleVariants } from \"@/components/ui/toggle\"\n\nconst ToggleGroupContext = React.createContext<\n  VariantProps<typeof toggleVariants>\n>({\n  size: \"default\",\n  variant: \"default\",\n})\n\nconst ToggleGroup = React.forwardRef<\n  React.ElementRef<typeof ToggleGroupPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &\n    VariantProps<typeof toggleVariants>\n>(({ className, variant, size, children, ...props }, ref) => (\n  <ToggleGroupPrimitive.Root\n    ref={ref}\n    className={cn(\"flex items-center justify-center gap-1\", className)}\n    {...props}\n  >\n    <ToggleGroupContext.Provider value={{ variant, size }}>\n      {children}\n    </ToggleGroupContext.Provider>\n  </ToggleGroupPrimitive.Root>\n))\n\nToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName\n\nconst ToggleGroupItem = React.forwardRef<\n  React.ElementRef<typeof ToggleGroupPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &\n    VariantProps<typeof toggleVariants>\n>(({ className, children, variant, size, ...props }, ref) => {\n  const context = React.useContext(ToggleGroupContext)\n\n  return (\n    <ToggleGroupPrimitive.Item\n      ref={ref}\n      className={cn(\n        toggleVariants({\n          variant: context.variant || variant,\n          size: context.size || size,\n        }),\n        className\n      )}\n      {...props}\n    >\n      {children}\n    </ToggleGroupPrimitive.Item>\n  )\n})\n\nToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName\n\nexport { ToggleGroup, ToggleGroupItem }\n","path":null,"size_bytes":1753,"size_tokens":null},"client/src/components/ui/switch.tsx":{"content":"import * as React from \"react\"\nimport * as SwitchPrimitives from \"@radix-ui/react-switch\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Switch = React.forwardRef<\n  React.ElementRef<typeof SwitchPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>\n>(({ className, ...props }, ref) => (\n  <SwitchPrimitives.Root\n    className={cn(\n      \"peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  >\n    <SwitchPrimitives.Thumb\n      className={cn(\n        \"pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0\"\n      )}\n    />\n  </SwitchPrimitives.Root>\n))\nSwitch.displayName = SwitchPrimitives.Root.displayName\n\nexport { Switch }\n","path":null,"size_bytes":1148,"size_tokens":null},"client/src/components/ui/form.tsx":{"content":"import * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport {\n  Controller,\n  FormProvider,\n  useFormContext,\n  type ControllerProps,\n  type FieldPath,\n  type FieldValues,\n} from \"react-hook-form\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Label } from \"@/components/ui/label\"\n\nconst Form = FormProvider\n\ntype FormFieldContextValue<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n> = {\n  name: TName\n}\n\nconst FormFieldContext = React.createContext<FormFieldContextValue | null>(null)\n\nconst FormField = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n>({\n  ...props\n}: ControllerProps<TFieldValues, TName>) => {\n  return (\n    <FormFieldContext.Provider value={{ name: props.name }}>\n      <Controller {...props} />\n    </FormFieldContext.Provider>\n  )\n}\n\nconst useFormField = () => {\n  const fieldContext = React.useContext(FormFieldContext)\n  const itemContext = React.useContext(FormItemContext)\n  const { getFieldState, formState } = useFormContext()\n\n  if (!fieldContext) {\n    throw new Error(\"useFormField should be used within <FormField>\")\n  }\n\n  if (!itemContext) {\n    throw new Error(\"useFormField should be used within <FormItem>\")\n  }\n\n  const fieldState = getFieldState(fieldContext.name, formState)\n\n  const { id } = itemContext\n\n  return {\n    id,\n    name: fieldContext.name,\n    formItemId: `${id}-form-item`,\n    formDescriptionId: `${id}-form-item-description`,\n    formMessageId: `${id}-form-item-message`,\n    ...fieldState,\n  }\n}\n\ntype FormItemContextValue = {\n  id: string\n}\n\nconst FormItemContext = React.createContext<FormItemContextValue | null>(null)\n\nconst FormItem = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const id = React.useId()\n\n  return (\n    <FormItemContext.Provider value={{ id }}>\n      <div ref={ref} className={cn(\"space-y-2\", className)} {...props} />\n    </FormItemContext.Provider>\n  )\n})\nFormItem.displayName = \"FormItem\"\n\nconst FormLabel = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>\n>(({ className, ...props }, ref) => {\n  const { error, formItemId } = useFormField()\n\n  return (\n    <Label\n      ref={ref}\n      className={cn(error && \"text-destructive\", className)}\n      htmlFor={formItemId}\n      {...props}\n    />\n  )\n})\nFormLabel.displayName = \"FormLabel\"\n\nconst FormControl = React.forwardRef<\n  React.ElementRef<typeof Slot>,\n  React.ComponentPropsWithoutRef<typeof Slot>\n>(({ ...props }, ref) => {\n  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()\n\n  return (\n    <Slot\n      ref={ref}\n      id={formItemId}\n      aria-describedby={\n        !error\n          ? `${formDescriptionId}`\n          : `${formDescriptionId} ${formMessageId}`\n      }\n      aria-invalid={!!error}\n      {...props}\n    />\n  )\n})\nFormControl.displayName = \"FormControl\"\n\nconst FormDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => {\n  const { formDescriptionId } = useFormField()\n\n  return (\n    <p\n      ref={ref}\n      id={formDescriptionId}\n      className={cn(\"text-[0.8rem] text-muted-foreground\", className)}\n      {...props}\n    />\n  )\n})\nFormDescription.displayName = \"FormDescription\"\n\nconst FormMessage = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, children, ...props }, ref) => {\n  const { error, formMessageId } = useFormField()\n  const body = error ? String(error?.message ?? \"\") : children\n\n  if (!body) {\n    return null\n  }\n\n  return (\n    <p\n      ref={ref}\n      id={formMessageId}\n      className={cn(\"text-[0.8rem] font-medium text-destructive\", className)}\n      {...props}\n    >\n      {body}\n    </p>\n  )\n})\nFormMessage.displayName = \"FormMessage\"\n\nexport {\n  useFormField,\n  Form,\n  FormItem,\n  FormLabel,\n  FormControl,\n  FormDescription,\n  FormMessage,\n  FormField,\n}\n","path":null,"size_bytes":4175,"size_tokens":null},"client/src/components/ui/sidebar.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, VariantProps } from \"class-variance-authority\"\nimport { PanelLeftIcon } from \"lucide-react\"\n\nimport { useIsMobile } from \"@/hooks/use-mobile\"\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\nimport { Input } from \"@/components/ui/input\"\nimport { Separator } from \"@/components/ui/separator\"\nimport {\n  Sheet,\n  SheetContent,\n  SheetDescription,\n  SheetHeader,\n  SheetTitle,\n} from \"@/components/ui/sheet\"\nimport { Skeleton } from \"@/components/ui/skeleton\"\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\"\n\nconst SIDEBAR_COOKIE_NAME = \"sidebar_state\"\nconst SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7\nconst SIDEBAR_WIDTH = \"16rem\"\nconst SIDEBAR_WIDTH_MOBILE = \"18rem\"\nconst SIDEBAR_WIDTH_ICON = \"3rem\"\nconst SIDEBAR_KEYBOARD_SHORTCUT = \"b\"\n\ntype SidebarContextProps = {\n  state: \"expanded\" | \"collapsed\"\n  open: boolean\n  setOpen: (open: boolean) => void\n  openMobile: boolean\n  setOpenMobile: (open: boolean) => void\n  isMobile: boolean\n  toggleSidebar: () => void\n}\n\nconst SidebarContext = React.createContext<SidebarContextProps | null>(null)\n\nfunction useSidebar() {\n  const context = React.useContext(SidebarContext)\n  if (!context) {\n    throw new Error(\"useSidebar must be used within a SidebarProvider.\")\n  }\n\n  return context\n}\n\nfunction SidebarProvider({\n  defaultOpen = true,\n  open: openProp,\n  onOpenChange: setOpenProp,\n  className,\n  style,\n  children,\n  ...props\n}: React.ComponentProps<\"div\"> & {\n  defaultOpen?: boolean\n  open?: boolean\n  onOpenChange?: (open: boolean) => void\n}) {\n  const isMobile = useIsMobile()\n  const [openMobile, setOpenMobile] = React.useState(false)\n\n  // This is the internal state of the sidebar.\n  // We use openProp and setOpenProp for control from outside the component.\n  const [_open, _setOpen] = React.useState(defaultOpen)\n  const open = openProp ?? _open\n  const setOpen = React.useCallback(\n    (value: boolean | ((value: boolean) => boolean)) => {\n      const openState = typeof value === \"function\" ? value(open) : value\n      if (setOpenProp) {\n        setOpenProp(openState)\n      } else {\n        _setOpen(openState)\n      }\n\n      // This sets the cookie to keep the sidebar state.\n      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`\n    },\n    [setOpenProp, open]\n  )\n\n  // Helper to toggle the sidebar.\n  const toggleSidebar = React.useCallback(() => {\n    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open)\n  }, [isMobile, setOpen, setOpenMobile])\n\n  // Adds a keyboard shortcut to toggle the sidebar.\n  React.useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (\n        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&\n        (event.metaKey || event.ctrlKey)\n      ) {\n        event.preventDefault()\n        toggleSidebar()\n      }\n    }\n\n    window.addEventListener(\"keydown\", handleKeyDown)\n    return () => window.removeEventListener(\"keydown\", handleKeyDown)\n  }, [toggleSidebar])\n\n  // We add a state so that we can do data-state=\"expanded\" or \"collapsed\".\n  // This makes it easier to style the sidebar with Tailwind classes.\n  const state = open ? \"expanded\" : \"collapsed\"\n\n  const contextValue = React.useMemo<SidebarContextProps>(\n    () => ({\n      state,\n      open,\n      setOpen,\n      isMobile,\n      openMobile,\n      setOpenMobile,\n      toggleSidebar,\n    }),\n    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]\n  )\n\n  return (\n    <SidebarContext.Provider value={contextValue}>\n      <TooltipProvider delayDuration={0}>\n        <div\n          data-slot=\"sidebar-wrapper\"\n          style={\n            {\n              \"--sidebar-width\": SIDEBAR_WIDTH,\n              \"--sidebar-width-icon\": SIDEBAR_WIDTH_ICON,\n              ...style,\n            } as React.CSSProperties\n          }\n          className={cn(\n            \"group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full\",\n            className\n          )}\n          {...props}\n        >\n          {children}\n        </div>\n      </TooltipProvider>\n    </SidebarContext.Provider>\n  )\n}\n\nfunction Sidebar({\n  side = \"left\",\n  variant = \"sidebar\",\n  collapsible = \"offcanvas\",\n  className,\n  children,\n  ...props\n}: React.ComponentProps<\"div\"> & {\n  side?: \"left\" | \"right\"\n  variant?: \"sidebar\" | \"floating\" | \"inset\"\n  collapsible?: \"offcanvas\" | \"icon\" | \"none\"\n}) {\n  const { isMobile, state, openMobile, setOpenMobile } = useSidebar()\n\n  if (collapsible === \"none\") {\n    return (\n      <div\n        data-slot=\"sidebar\"\n        className={cn(\n          \"bg-sidebar text-sidebar-foreground flex h-full w-[var(--sidebar-width)] flex-col\",\n          className\n        )}\n        {...props}\n      >\n        {children}\n      </div>\n    )\n  }\n\n  if (isMobile) {\n    return (\n      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>\n        <SheetContent\n          data-sidebar=\"sidebar\"\n          data-slot=\"sidebar\"\n          data-mobile=\"true\"\n          className=\"bg-sidebar text-sidebar-foreground w-[var(--sidebar-width)] p-0 [&>button]:hidden\"\n          style={\n            {\n              \"--sidebar-width\": SIDEBAR_WIDTH_MOBILE,\n            } as React.CSSProperties\n          }\n          side={side}\n        >\n          <SheetHeader className=\"sr-only\">\n            <SheetTitle>Sidebar</SheetTitle>\n            <SheetDescription>Displays the mobile sidebar.</SheetDescription>\n          </SheetHeader>\n          <div className=\"flex h-full w-full flex-col\">{children}</div>\n        </SheetContent>\n      </Sheet>\n    )\n  }\n\n  return (\n    <div\n      className=\"group peer text-sidebar-foreground hidden md:block\"\n      data-state={state}\n      data-collapsible={state === \"collapsed\" ? collapsible : \"\"}\n      data-variant={variant}\n      data-side={side}\n      data-slot=\"sidebar\"\n    >\n      {/* This is what handles the sidebar gap on desktop */}\n      <div\n        data-slot=\"sidebar-gap\"\n        className={cn(\n          \"relative w-[var(--sidebar-width)] bg-transparent transition-[width] duration-200 ease-linear\",\n          \"group-data-[collapsible=offcanvas]:w-0\",\n          \"group-data-[side=right]:rotate-180\",\n          variant === \"floating\" || variant === \"inset\"\n            ? \"group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+var(--spacing-4))]\"\n            : \"group-data-[collapsible=icon]:w-[var(--sidebar-width-icon)]\"\n        )}\n      />\n      <div\n        data-slot=\"sidebar-container\"\n        className={cn(\n          \"fixed inset-y-0 z-10 hidden h-svh w-[var(--sidebar-width)] transition-[left,right,width] duration-200 ease-linear md:flex\",\n          side === \"left\"\n            ? \"left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]\"\n            : \"right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]\",\n          // Adjust the padding for floating and inset variants.\n          variant === \"floating\" || variant === \"inset\"\n            ? \"p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+var(--spacing-4)+2px)]\"\n            : \"group-data-[collapsible=icon]:w-[var(--sidebar-width-icon)] group-data-[side=left]:border-r group-data-[side=right]:border-l\",\n          className\n        )}\n        {...props}\n      >\n        <div\n          data-sidebar=\"sidebar\"\n          data-slot=\"sidebar-inner\"\n          className=\"bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm\"\n        >\n          {children}\n        </div>\n      </div>\n    </div>\n  )\n}\n\nfunction SidebarTrigger({\n  className,\n  onClick,\n  ...props\n}: React.ComponentProps<typeof Button>) {\n  const { toggleSidebar } = useSidebar()\n\n  return (\n    <Button\n      data-sidebar=\"trigger\"\n      data-slot=\"sidebar-trigger\"\n      variant=\"ghost\"\n      size=\"icon\"\n      className={cn(\"h-7 w-7\", className)}\n      onClick={(event) => {\n        onClick?.(event)\n        toggleSidebar()\n      }}\n      {...props}\n    >\n      <PanelLeftIcon />\n      <span className=\"sr-only\">Toggle Sidebar</span>\n    </Button>\n  )\n}\n\nfunction SidebarRail({ className, ...props }: React.ComponentProps<\"button\">) {\n  const { toggleSidebar } = useSidebar()\n\n  // Note: Tailwind v3.4 doesn't support \"in-\" selectors. So the rail won't work perfectly.\n  return (\n    <button\n      data-sidebar=\"rail\"\n      data-slot=\"sidebar-rail\"\n      aria-label=\"Toggle Sidebar\"\n      tabIndex={-1}\n      onClick={toggleSidebar}\n      title=\"Toggle Sidebar\"\n      className={cn(\n        \"hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex\",\n        \"in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize\",\n        \"[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize\",\n        \"hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full\",\n        \"[[data-side=left][data-collapsible=offcanvas]_&]:-right-2\",\n        \"[[data-side=right][data-collapsible=offcanvas]_&]:-left-2\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarInset({ className, ...props }: React.ComponentProps<\"main\">) {\n  return (\n    <main\n      data-slot=\"sidebar-inset\"\n      className={cn(\n        \"bg-background relative flex w-full flex-1 flex-col\",\n        \"md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarInput({\n  className,\n  ...props\n}: React.ComponentProps<typeof Input>) {\n  return (\n    <Input\n      data-slot=\"sidebar-input\"\n      data-sidebar=\"input\"\n      className={cn(\"bg-background h-8 w-full shadow-none\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarHeader({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"sidebar-header\"\n      data-sidebar=\"header\"\n      className={cn(\"flex flex-col gap-2 p-2\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarFooter({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"sidebar-footer\"\n      data-sidebar=\"footer\"\n      className={cn(\"flex flex-col gap-2 p-2\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarSeparator({\n  className,\n  ...props\n}: React.ComponentProps<typeof Separator>) {\n  return (\n    <Separator\n      data-slot=\"sidebar-separator\"\n      data-sidebar=\"separator\"\n      className={cn(\"bg-sidebar-border mx-2 w-auto\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarContent({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"sidebar-content\"\n      data-sidebar=\"content\"\n      className={cn(\n        \"flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarGroup({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"sidebar-group\"\n      data-sidebar=\"group\"\n      className={cn(\"relative flex w-full min-w-0 flex-col p-2\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarGroupLabel({\n  className,\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"div\"> & { asChild?: boolean }) {\n  const Comp = asChild ? Slot : \"div\"\n\n  return (\n    <Comp\n      data-slot=\"sidebar-group-label\"\n      data-sidebar=\"group-label\"\n      className={cn(\n        \"text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:h-4 [&>svg]:w-4 [&>svg]:shrink-0\",\n        \"group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarGroupAction({\n  className,\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"button\"> & { asChild?: boolean }) {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      data-slot=\"sidebar-group-action\"\n      data-sidebar=\"group-action\"\n      className={cn(\n        \"text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0\",\n        // Increases the hit area of the button on mobile.\n        \"after:absolute after:-inset-2 md:after:hidden\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarGroupContent({\n  className,\n  ...props\n}: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"sidebar-group-content\"\n      data-sidebar=\"group-content\"\n      className={cn(\"w-full text-sm\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenu({ className, ...props }: React.ComponentProps<\"ul\">) {\n  return (\n    <ul\n      data-slot=\"sidebar-menu\"\n      data-sidebar=\"menu\"\n      className={cn(\"flex w-full min-w-0 flex-col gap-1\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenuItem({ className, ...props }: React.ComponentProps<\"li\">) {\n  return (\n    <li\n      data-slot=\"sidebar-menu-item\"\n      data-sidebar=\"menu-item\"\n      className={cn(\"group/menu-item relative\", className)}\n      {...props}\n    />\n  )\n}\n\nconst sidebarMenuButtonVariants = cva(\n  \"peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:w-8! group-data-[collapsible=icon]:h-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default: \"hover:bg-sidebar-accent hover:text-sidebar-accent-foreground\",\n        outline:\n          \"bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]\",\n      },\n      size: {\n        default: \"h-8 text-sm\",\n        sm: \"h-7 text-xs\",\n        lg: \"h-12 text-sm group-data-[collapsible=icon]:p-0!\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nfunction SidebarMenuButton({\n  asChild = false,\n  isActive = false,\n  variant = \"default\",\n  size = \"default\",\n  tooltip,\n  className,\n  ...props\n}: React.ComponentProps<\"button\"> & {\n  asChild?: boolean\n  isActive?: boolean\n  tooltip?: string | React.ComponentProps<typeof TooltipContent>\n} & VariantProps<typeof sidebarMenuButtonVariants>) {\n  const Comp = asChild ? Slot : \"button\"\n  const { isMobile, state } = useSidebar()\n\n  const button = (\n    <Comp\n      data-slot=\"sidebar-menu-button\"\n      data-sidebar=\"menu-button\"\n      data-size={size}\n      data-active={isActive}\n      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}\n      {...props}\n    />\n  )\n\n  if (!tooltip) {\n    return button\n  }\n\n  if (typeof tooltip === \"string\") {\n    tooltip = {\n      children: tooltip,\n    }\n  }\n\n  return (\n    <Tooltip>\n      <TooltipTrigger asChild>{button}</TooltipTrigger>\n      <TooltipContent\n        side=\"right\"\n        align=\"center\"\n        hidden={state !== \"collapsed\" || isMobile}\n        {...tooltip}\n      />\n    </Tooltip>\n  )\n}\n\nfunction SidebarMenuAction({\n  className,\n  asChild = false,\n  showOnHover = false,\n  ...props\n}: React.ComponentProps<\"button\"> & {\n  asChild?: boolean\n  showOnHover?: boolean\n}) {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      data-slot=\"sidebar-menu-action\"\n      data-sidebar=\"menu-action\"\n      className={cn(\n        \"text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0\",\n        // Increases the hit area of the button on mobile.\n        \"after:absolute after:-inset-2 md:after:hidden\",\n        \"peer-data-[size=sm]/menu-button:top-1\",\n        \"peer-data-[size=default]/menu-button:top-1.5\",\n        \"peer-data-[size=lg]/menu-button:top-2.5\",\n        \"group-data-[collapsible=icon]:hidden\",\n        showOnHover &&\n          \"peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenuBadge({\n  className,\n  ...props\n}: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"sidebar-menu-badge\"\n      data-sidebar=\"menu-badge\"\n      className={cn(\n        \"text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none\",\n        \"peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground\",\n        \"peer-data-[size=sm]/menu-button:top-1\",\n        \"peer-data-[size=default]/menu-button:top-1.5\",\n        \"peer-data-[size=lg]/menu-button:top-2.5\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenuSkeleton({\n  className,\n  showIcon = false,\n  ...props\n}: React.ComponentProps<\"div\"> & {\n  showIcon?: boolean\n}) {\n  // Random width between 50 to 90%.\n  const width = React.useMemo(() => {\n    return `${Math.floor(Math.random() * 40) + 50}%`\n  }, [])\n\n  return (\n    <div\n      data-slot=\"sidebar-menu-skeleton\"\n      data-sidebar=\"menu-skeleton\"\n      className={cn(\"flex h-8 items-center gap-2 rounded-md px-2\", className)}\n      {...props}\n    >\n      {showIcon && (\n        <Skeleton\n          className=\"size-4 rounded-md\"\n          data-sidebar=\"menu-skeleton-icon\"\n        />\n      )}\n      <Skeleton\n        className=\"h-4 max-w-[var(--skeleton-width)] flex-1\"\n        data-sidebar=\"menu-skeleton-text\"\n        style={\n          {\n            \"--skeleton-width\": width,\n          } as React.CSSProperties\n        }\n      />\n    </div>\n  )\n}\n\nfunction SidebarMenuSub({ className, ...props }: React.ComponentProps<\"ul\">) {\n  return (\n    <ul\n      data-slot=\"sidebar-menu-sub\"\n      data-sidebar=\"menu-sub\"\n      className={cn(\n        \"border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenuSubItem({\n  className,\n  ...props\n}: React.ComponentProps<\"li\">) {\n  return (\n    <li\n      data-slot=\"sidebar-menu-sub-item\"\n      data-sidebar=\"menu-sub-item\"\n      className={cn(\"group/menu-sub-item relative\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenuSubButton({\n  asChild = false,\n  size = \"md\",\n  isActive = false,\n  className,\n  ...props\n}: React.ComponentProps<\"a\"> & {\n  asChild?: boolean\n  size?: \"sm\" | \"md\"\n  isActive?: boolean\n}) {\n  const Comp = asChild ? Slot : \"a\"\n\n  return (\n    <Comp\n      data-slot=\"sidebar-menu-sub-button\"\n      data-sidebar=\"menu-sub-button\"\n      data-size={size}\n      data-active={isActive}\n      className={cn(\n        \"text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline outline-2 outline-transparent outline-offset-2 focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0\",\n        \"data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground\",\n        size === \"sm\" && \"text-xs\",\n        size === \"md\" && \"text-sm\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport {\n  Sidebar,\n  SidebarContent,\n  SidebarFooter,\n  SidebarGroup,\n  SidebarGroupAction,\n  SidebarGroupContent,\n  SidebarGroupLabel,\n  SidebarHeader,\n  SidebarInput,\n  SidebarInset,\n  SidebarMenu,\n  SidebarMenuAction,\n  SidebarMenuBadge,\n  SidebarMenuButton,\n  SidebarMenuItem,\n  SidebarMenuSkeleton,\n  SidebarMenuSub,\n  SidebarMenuSubButton,\n  SidebarMenuSubItem,\n  SidebarProvider,\n  SidebarRail,\n  SidebarSeparator,\n  SidebarTrigger,\n  useSidebar,\n}\n","path":null,"size_bytes":21846,"size_tokens":null},"script/build.ts":{"content":"import { build as esbuild } from \"esbuild\";\nimport { build as viteBuild } from \"vite\";\nimport { rm, readFile } from \"fs/promises\";\n\n// server deps to bundle to reduce openat(2) syscalls\n// which helps cold start times\nconst allowlist = [\n  \"@google/generative-ai\",\n  \"axios\",\n  \"connect-pg-simple\",\n  \"cors\",\n  \"date-fns\",\n  \"drizzle-orm\",\n  \"drizzle-zod\",\n  \"express\",\n  \"express-rate-limit\",\n  \"express-session\",\n  \"jsonwebtoken\",\n  \"memorystore\",\n  \"multer\",\n  \"nanoid\",\n  \"nodemailer\",\n  \"node-kraken-api\",\n  \"node-telegram-bot-api\",\n  \"openai\",\n  \"passport\",\n  \"passport-local\",\n  \"pg\",\n  \"stripe\",\n  \"uuid\",\n  \"ws\",\n  \"xlsx\",\n  \"zod\",\n  \"zod-validation-error\",\n];\n\nasync function buildAll() {\n  await rm(\"dist\", { recursive: true, force: true });\n\n  console.log(\"building client...\");\n  await viteBuild();\n\n  console.log(\"building server...\");\n  const pkg = JSON.parse(await readFile(\"package.json\", \"utf-8\"));\n  const allDeps = [\n    ...Object.keys(pkg.dependencies || {}),\n    ...Object.keys(pkg.devDependencies || {}),\n  ];\n  const externals = allDeps.filter((dep) => !allowlist.includes(dep));\n\n  await esbuild({\n    entryPoints: [\"server/index.ts\"],\n    platform: \"node\",\n    bundle: true,\n    format: \"cjs\",\n    outfile: \"dist/index.cjs\",\n    define: {\n      \"process.env.NODE_ENV\": '\"production\"',\n    },\n    minify: true,\n    external: externals,\n    logLevel: \"info\",\n  });\n}\n\nbuildAll().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n","path":null,"size_bytes":1465,"size_tokens":null},"client/src/components/ui/sheet.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as SheetPrimitive from \"@radix-ui/react-dialog\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Sheet = SheetPrimitive.Root\n\nconst SheetTrigger = SheetPrimitive.Trigger\n\nconst SheetClose = SheetPrimitive.Close\n\nconst SheetPortal = SheetPrimitive.Portal\n\nconst SheetOverlay = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Overlay\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  />\n))\nSheetOverlay.displayName = SheetPrimitive.Overlay.displayName\n\nconst sheetVariants = cva(\n  \"fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500 data-[state=open]:animate-in data-[state=closed]:animate-out\",\n  {\n    variants: {\n      side: {\n        top: \"inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top\",\n        bottom:\n          \"inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom\",\n        left: \"inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm\",\n        right:\n          \"inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm\",\n      },\n    },\n    defaultVariants: {\n      side: \"right\",\n    },\n  }\n)\n\ninterface SheetContentProps\n  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,\n    VariantProps<typeof sheetVariants> {}\n\nconst SheetContent = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Content>,\n  SheetContentProps\n>(({ side = \"right\", className, children, ...props }, ref) => (\n  <SheetPortal>\n    <SheetOverlay />\n    <SheetPrimitive.Content\n      ref={ref}\n      className={cn(sheetVariants({ side }), className)}\n      {...props}\n    >\n      <SheetPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </SheetPrimitive.Close>\n      {children}\n    </SheetPrimitive.Content>\n  </SheetPortal>\n))\nSheetContent.displayName = SheetPrimitive.Content.displayName\n\nconst SheetHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nSheetHeader.displayName = \"SheetHeader\"\n\nconst SheetFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nSheetFooter.displayName = \"SheetFooter\"\n\nconst SheetTitle = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold text-foreground\", className)}\n    {...props}\n  />\n))\nSheetTitle.displayName = SheetPrimitive.Title.displayName\n\nconst SheetDescription = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nSheetDescription.displayName = SheetPrimitive.Description.displayName\n\nexport {\n  Sheet,\n  SheetPortal,\n  SheetOverlay,\n  SheetTrigger,\n  SheetClose,\n  SheetContent,\n  SheetHeader,\n  SheetFooter,\n  SheetTitle,\n  SheetDescription,\n}\n","path":null,"size_bytes":4280,"size_tokens":null},"client/src/pages/Settings.tsx":{"content":"import { useState, useEffect } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { Nav } from \"@/components/dashboard/Nav\";\nimport { EnvironmentBadge } from \"@/components/dashboard/EnvironmentBadge\";\nimport generatedImage from '@assets/generated_images/dark_digital_hex_grid_background.png';\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription } from \"@/components/ui/card\";\nimport { Label } from \"@/components/ui/label\";\nimport { Input } from \"@/components/ui/input\";\nimport { Button } from \"@/components/ui/button\";\nimport { Switch } from \"@/components/ui/switch\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { Progress } from \"@/components/ui/progress\";\nimport { HardDrive, Bot, Server, Cog, AlertTriangle, Clock, Brain, Loader2, Layers, Eye, EyeOff, Check, Monitor, Shield, ChevronRight, Trash2, Plus, X } from \"lucide-react\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { cn } from \"@/lib/utils\";\nimport { Link } from \"wouter\";\nimport { toast } from \"sonner\";\n\ninterface AiStatus {\n  phase: \"red\" | \"yellow\" | \"green\";\n  phaseLabel: string;\n  completeSamples: number;\n  minSamplesForTrain: number;\n  minSamplesForActivate: number;\n  canTrain: boolean;\n  canActivate: boolean;\n  filterEnabled: boolean;\n  shadowEnabled: boolean;\n  modelLoaded: boolean;\n  lastTrainTs: string | null;\n  threshold: number;\n  metrics: {\n    accuracy?: number;\n    precision?: number;\n    recall?: number;\n    f1?: number;\n  } | null;\n}\n\ninterface AiDiagnostic {\n  operationsCount: number;\n  trainingTradesTotal: number;\n  closedTradesCount: number;\n  labeledTradesCount: number;\n  openTradesCount: number;\n  openLotsCount: number;\n  openTradesDescription: string;\n  openLotsDescription: string;\n  lastBackfillRun: string | null;\n  lastBackfillError: string | null;\n  lastTrainRun: string | null;\n  lastTrainError: string | null;\n  modelVersion: string | null;\n  discardReasonsDataset: Record<string, number>;\n  lastBackfillDiscardReasons: Record<string, number>;\n  winRate: number | null;\n  avgPnlNet: number | null;\n  avgHoldTimeMinutes: number | null;\n}\n\ninterface BotConfig {\n  id: number;\n  isActive: boolean;\n  strategy: string;\n  riskLevel: string;\n  activePairs: string[];\n  stopLossPercent: string;\n  takeProfitPercent: string;\n  trailingStopEnabled: boolean;\n  trailingStopPercent: string;\n  nonceErrorAlertsEnabled: boolean;\n  tradingHoursEnabled: boolean;\n  tradingHoursStart: string;\n  tradingHoursEnd: string;\n  positionMode: string;\n  // SMART_GUARD fields\n  sgMinEntryUsd: string;\n  sgAllowUnderMin: boolean;\n  sgBeAtPct: string;\n  sgFeeCushionPct: string;\n  sgFeeCushionAuto: boolean;\n  sgTrailStartPct: string;\n  sgTrailDistancePct: string;\n  sgTrailStepPct: string;\n  sgTpFixedEnabled: boolean;\n  sgTpFixedPct: string;\n  sgScaleOutEnabled: boolean;\n  sgScaleOutPct: string;\n  sgMinPartUsd: string;\n  sgScaleOutThreshold: string;\n  sgMaxOpenLotsPerPair: number;\n  sgPairOverrides: Record<string, unknown> | null;\n}\n\nexport default function Settings() {\n  const queryClient = useQueryClient();\n  \n  const [wsAdminToken, setWsAdminToken] = useState(\"\");\n  const [terminalToken, setTerminalToken] = useState(\"\");\n  const [showWsToken, setShowWsToken] = useState(false);\n  const [showTerminalToken, setShowTerminalToken] = useState(false);\n  const [wsTokenSaved, setWsTokenSaved] = useState(false);\n  const [terminalTokenSaved, setTerminalTokenSaved] = useState(false);\n\n  useEffect(() => {\n    const savedWsToken = localStorage.getItem(\"WS_ADMIN_TOKEN\") || \"\";\n    const savedTerminalToken = localStorage.getItem(\"TERMINAL_TOKEN\") || \"\";\n    setWsAdminToken(savedWsToken);\n    setTerminalToken(savedTerminalToken);\n    setWsTokenSaved(!!savedWsToken);\n    setTerminalTokenSaved(!!savedTerminalToken);\n  }, []);\n\n  const handleSaveTokens = () => {\n    if (wsAdminToken) {\n      localStorage.setItem(\"WS_ADMIN_TOKEN\", wsAdminToken);\n      setWsTokenSaved(true);\n    } else {\n      localStorage.removeItem(\"WS_ADMIN_TOKEN\");\n      setWsTokenSaved(false);\n    }\n    if (terminalToken) {\n      localStorage.setItem(\"TERMINAL_TOKEN\", terminalToken);\n      setTerminalTokenSaved(true);\n    } else {\n      localStorage.removeItem(\"TERMINAL_TOKEN\");\n      setTerminalTokenSaved(false);\n    }\n    toast.success(\"Tokens guardados. Recarga la pÃ¡gina para aplicar cambios.\");\n  };\n\n  const { data: config } = useQuery<BotConfig>({\n    queryKey: [\"botConfig\"],\n    queryFn: async () => {\n      const res = await fetch(\"/api/config\");\n      if (!res.ok) throw new Error(\"Failed to fetch config\");\n      return res.json();\n    },\n  });\n\n  const { data: aiStatus, isLoading: aiLoading } = useQuery<AiStatus>({\n    queryKey: [\"aiStatus\"],\n    queryFn: async () => {\n      const res = await fetch(\"/api/ai/status\");\n      if (!res.ok) throw new Error(\"Failed to fetch AI status\");\n      return res.json();\n    },\n    refetchInterval: 30000,\n  });\n\n  const { data: aiDiagnostic } = useQuery<AiDiagnostic>({\n    queryKey: [\"aiDiagnostic\"],\n    queryFn: async () => {\n      const res = await fetch(\"/api/ai/diagnostic\");\n      if (!res.ok) throw new Error(\"Failed to fetch AI diagnostic\");\n      return res.json();\n    },\n    refetchInterval: 60000,\n  });\n\n  const backfillMutation = useMutation({\n    mutationFn: async () => {\n      const res = await fetch(\"/api/ai/backfill\", { method: \"POST\" });\n      if (!res.ok) throw new Error(\"Failed to backfill\");\n      return res.json();\n    },\n    onSuccess: (data) => {\n      queryClient.invalidateQueries({ queryKey: [\"aiStatus\"] });\n      queryClient.invalidateQueries({ queryKey: [\"aiDiagnostic\"] });\n      if (data.success) {\n        toast.success(data.message || \"Backfill completado\");\n      } else {\n        toast.error(data.message || \"Error en backfill\");\n      }\n    },\n    onError: () => {\n      toast.error(\"Error al ejecutar backfill\");\n    },\n  });\n\n  const updateMutation = useMutation({\n    mutationFn: async (updates: Partial<BotConfig>) => {\n      const res = await fetch(\"/api/config\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(updates),\n      });\n      if (!res.ok) throw new Error(\"Failed to update config\");\n      return res.json();\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: [\"botConfig\"] });\n      toast.success(\"ConfiguraciÃ³n actualizada\");\n    },\n    onError: () => {\n      toast.error(\"Error al actualizar configuraciÃ³n\");\n    },\n  });\n\n  const trainMutation = useMutation({\n    mutationFn: async () => {\n      const res = await fetch(\"/api/ai/retrain\", { method: \"POST\" });\n      if (!res.ok) throw new Error(\"Failed to train\");\n      return res.json();\n    },\n    onSuccess: (data) => {\n      queryClient.invalidateQueries({ queryKey: [\"aiStatus\"] });\n      if (data.success) {\n        toast.success(data.message || \"Entrenamiento completado\");\n      } else {\n        toast.error(data.message || \"Error en entrenamiento\");\n      }\n    },\n    onError: () => {\n      toast.error(\"Error al entrenar modelo\");\n    },\n  });\n\n  const toggleAiMutation = useMutation({\n    mutationFn: async (payload: { filterEnabled?: boolean; shadowEnabled?: boolean }) => {\n      const res = await fetch(\"/api/ai/toggle\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(payload),\n      });\n      if (!res.ok) throw new Error(\"Failed to toggle\");\n      return res.json();\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: [\"aiStatus\"] });\n      toast.success(\"ConfiguraciÃ³n IA actualizada\");\n    },\n    onError: () => {\n      toast.error(\"Error al actualizar configuraciÃ³n IA\");\n    },\n  });\n\n  return (\n    <div className=\"min-h-screen bg-background flex flex-col relative overflow-hidden\">\n      <div \n        className=\"fixed inset-0 z-0 opacity-20 pointer-events-none\" \n        style={{ \n          backgroundImage: `url(${generatedImage})`, \n          backgroundSize: 'cover',\n          backgroundPosition: 'center',\n          mixBlendMode: 'overlay'\n        }} \n      />\n      \n      <div className=\"relative z-10 flex flex-col min-h-screen\">\n        <Nav />\n        \n        <main className=\"flex-1 p-4 md:p-6 max-w-4xl mx-auto w-full space-y-6 md:space-y-8\">\n          <EnvironmentBadge />\n          \n          <div className=\"flex items-center justify-between\">\n            <div>\n              <h1 className=\"text-xl md:text-3xl font-bold font-sans tracking-tight flex items-center gap-2 md:gap-3\">\n                <Cog className=\"h-6 w-6 md:h-8 md:w-8 text-primary\" />\n                Ajustes del Sistema\n              </h1>\n              <p className=\"text-sm md:text-base text-muted-foreground mt-1\">ConfiguraciÃ³n del bot, IA y despliegue.</p>\n            </div>\n          </div>\n\n          <div className=\"grid gap-6\">\n            {/* Quick Link to Integrations */}\n            <Card className=\"glass-panel border-primary/30 bg-primary/5\">\n              <CardContent className=\"p-4\">\n                <div className=\"flex items-center justify-between\">\n                  <div className=\"flex items-center gap-3\">\n                    <Server className=\"h-5 w-5 text-primary\" />\n                    <div>\n                      <p className=\"font-medium\">APIs y Credenciales</p>\n                      <p className=\"text-sm text-muted-foreground\">Configura Kraken, Telegram y otras integraciones</p>\n                    </div>\n                  </div>\n                  <Link href=\"/integrations\">\n                    <Button variant=\"outline\" data-testid=\"link-integrations\">\n                      Ir a Integraciones\n                    </Button>\n                  </Link>\n                </div>\n              </CardContent>\n            </Card>\n\n            {/* Monitor Tokens */}\n            <Card className=\"glass-panel border-border/50\">\n              <CardHeader>\n                <div className=\"flex items-center gap-3\">\n                  <div className=\"p-2 bg-cyan-500/20 rounded-lg\">\n                    <Monitor className=\"h-6 w-6 text-cyan-400\" />\n                  </div>\n                  <div>\n                    <CardTitle>Tokens de Monitor</CardTitle>\n                    <CardDescription>Tokens de autenticaciÃ³n para WebSocket (deben coincidir con los del servidor).</CardDescription>\n                  </div>\n                </div>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                <div className=\"grid gap-3\">\n                  <div className=\"grid gap-2\">\n                    <Label htmlFor=\"ws-admin-token\">WS_ADMIN_TOKEN (Eventos)</Label>\n                    <div className=\"flex gap-2\">\n                      <div className=\"relative flex-1\">\n                        <Input\n                          id=\"ws-admin-token\"\n                          type={showWsToken ? \"text\" : \"password\"}\n                          value={wsAdminToken}\n                          onChange={(e) => setWsAdminToken(e.target.value)}\n                          placeholder=\"Token para /ws/events\"\n                          className=\"font-mono pr-10\"\n                          data-testid=\"input-ws-admin-token\"\n                        />\n                        <button\n                          type=\"button\"\n                          onClick={() => setShowWsToken(!showWsToken)}\n                          className=\"absolute right-2 top-1/2 -translate-y-1/2 text-muted-foreground hover:text-foreground\"\n                        >\n                          {showWsToken ? <EyeOff className=\"h-4 w-4\" /> : <Eye className=\"h-4 w-4\" />}\n                        </button>\n                      </div>\n                      {wsTokenSaved && (\n                        <Check className=\"h-5 w-5 text-green-500 self-center\" data-testid=\"check-ws-token\" />\n                      )}\n                    </div>\n                    <p className=\"text-xs text-muted-foreground\">Opcional en desarrollo, requerido en producciÃ³n.</p>\n                  </div>\n                  \n                  <div className=\"grid gap-2\">\n                    <Label htmlFor=\"terminal-token\">TERMINAL_TOKEN (Terminal)</Label>\n                    <div className=\"flex gap-2\">\n                      <div className=\"relative flex-1\">\n                        <Input\n                          id=\"terminal-token\"\n                          type={showTerminalToken ? \"text\" : \"password\"}\n                          value={terminalToken}\n                          onChange={(e) => setTerminalToken(e.target.value)}\n                          placeholder=\"Token para /ws/logs\"\n                          className=\"font-mono pr-10\"\n                          data-testid=\"input-terminal-token\"\n                        />\n                        <button\n                          type=\"button\"\n                          onClick={() => setShowTerminalToken(!showTerminalToken)}\n                          className=\"absolute right-2 top-1/2 -translate-y-1/2 text-muted-foreground hover:text-foreground\"\n                        >\n                          {showTerminalToken ? <EyeOff className=\"h-4 w-4\" /> : <Eye className=\"h-4 w-4\" />}\n                        </button>\n                      </div>\n                      {terminalTokenSaved && (\n                        <Check className=\"h-5 w-5 text-green-500 self-center\" data-testid=\"check-terminal-token\" />\n                      )}\n                    </div>\n                    <p className=\"text-xs text-muted-foreground\">Obligatorio para ver logs del servidor.</p>\n                  </div>\n                </div>\n                \n                <Button onClick={handleSaveTokens} className=\"w-full\" data-testid=\"button-save-tokens\">\n                  Guardar Tokens\n                </Button>\n                \n                <p className=\"text-xs text-muted-foreground text-center\">\n                  Los tokens se guardan en tu navegador. Recarga la pÃ¡gina despuÃ©s de guardar para aplicar cambios.\n                </p>\n              </CardContent>\n            </Card>\n\n            {/* Notifications Settings */}\n            <Card className=\"glass-panel border-border/50\">\n              <CardHeader>\n                <div className=\"flex items-center gap-3\">\n                  <div className=\"p-2 bg-yellow-500/20 rounded-lg\">\n                    <AlertTriangle className=\"h-6 w-6 text-yellow-400\" />\n                  </div>\n                  <div>\n                    <CardTitle>Alertas y Notificaciones</CardTitle>\n                    <CardDescription>Configura las alertas de Telegram del bot.</CardDescription>\n                  </div>\n                </div>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                <div className=\"flex items-center justify-between p-4 border border-border rounded-lg bg-card/30\">\n                  <div className=\"space-y-0.5\">\n                    <Label>Alertas de Error de Nonce</Label>\n                    <p className=\"text-sm text-muted-foreground\">\n                      EnvÃ­a alerta por Telegram si hay errores persistentes de nonce con Kraken (mÃ¡x. 1 cada 30 min)\n                    </p>\n                  </div>\n                  <Switch \n                    checked={config?.nonceErrorAlertsEnabled ?? true}\n                    onCheckedChange={(checked) => updateMutation.mutate({ nonceErrorAlertsEnabled: checked })}\n                    data-testid=\"switch-nonce-alerts\"\n                  />\n                </div>\n              </CardContent>\n            </Card>\n\n            {/* Trading Hours Settings */}\n            <Card className=\"glass-panel border-border/50\">\n              <CardHeader>\n                <div className=\"flex items-center gap-3\">\n                  <div className=\"p-2 bg-blue-500/20 rounded-lg\">\n                    <Clock className=\"h-6 w-6 text-blue-400\" />\n                  </div>\n                  <div>\n                    <CardTitle>Horario de Trading</CardTitle>\n                    <CardDescription>Limita las operaciones a horas de mayor liquidez (UTC).</CardDescription>\n                  </div>\n                </div>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                <div className=\"flex items-center justify-between p-4 border border-border rounded-lg bg-card/30\">\n                  <div className=\"space-y-0.5\">\n                    <Label>Activar Filtro de Horario</Label>\n                    <p className=\"text-sm text-muted-foreground\">\n                      Solo opera dentro del horario configurado (evita baja liquidez nocturna)\n                    </p>\n                  </div>\n                  <Switch \n                    checked={config?.tradingHoursEnabled ?? true}\n                    onCheckedChange={(checked) => updateMutation.mutate({ tradingHoursEnabled: checked })}\n                    data-testid=\"switch-trading-hours\"\n                  />\n                </div>\n                <div className=\"grid grid-cols-2 gap-4\">\n                  <div className=\"grid gap-2\">\n                    <Label className=\"text-sm\">Hora de Inicio (UTC)</Label>\n                    <Input \n                      type=\"number\"\n                      min=\"0\"\n                      max=\"23\"\n                      defaultValue={config?.tradingHoursStart ?? \"8\"}\n                      key={`start-${config?.tradingHoursStart}`}\n                      onBlur={(e) => {\n                        const val = parseInt(e.target.value);\n                        if (!isNaN(val) && val >= 0 && val <= 23) {\n                          updateMutation.mutate({ tradingHoursStart: val.toString() });\n                        }\n                      }}\n                      className=\"font-mono bg-background/50\"\n                      data-testid=\"input-trading-hours-start\"\n                    />\n                  </div>\n                  <div className=\"grid gap-2\">\n                    <Label className=\"text-sm\">Hora de Fin (UTC)</Label>\n                    <Input \n                      type=\"number\"\n                      min=\"0\"\n                      max=\"23\"\n                      defaultValue={config?.tradingHoursEnd ?? \"22\"}\n                      key={`end-${config?.tradingHoursEnd}`}\n                      onBlur={(e) => {\n                        const val = parseInt(e.target.value);\n                        if (!isNaN(val) && val >= 0 && val <= 23) {\n                          updateMutation.mutate({ tradingHoursEnd: val.toString() });\n                        }\n                      }}\n                      className=\"font-mono bg-background/50\"\n                      data-testid=\"input-trading-hours-end\"\n                    />\n                  </div>\n                </div>\n                <p className=\"text-xs text-muted-foreground\">\n                  Horario actual: {config?.tradingHoursStart ?? \"8\"}:00 - {config?.tradingHoursEnd ?? \"22\"}:00 UTC\n                </p>\n              </CardContent>\n            </Card>\n\n            {/* Position Mode Settings */}\n            <Card className=\"glass-panel border-border/50\">\n              <CardHeader>\n                <div className=\"flex items-center gap-3\">\n                  <div className=\"p-2 bg-purple-500/20 rounded-lg\">\n                    <Layers className=\"h-6 w-6 text-purple-400\" />\n                  </div>\n                  <div>\n                    <CardTitle>Modo de PosiciÃ³n</CardTitle>\n                    <CardDescription>Controla cÃ³mo se acumulan posiciones por cada par.</CardDescription>\n                  </div>\n                </div>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                <div className=\"p-4 border border-border rounded-lg bg-card/30\">\n                  <div className=\"flex flex-col sm:flex-row sm:items-center justify-between gap-4\">\n                    <div className=\"space-y-1\">\n                      <Label>Modo de AcumulaciÃ³n</Label>\n                      <p className=\"text-sm text-muted-foreground\">\n                        SINGLE: Una sola posiciÃ³n por par (bloquea nuevas compras si ya hay posiciÃ³n abierta).\n                        <br />\n                        DCA: Permite mÃºltiples compras del mismo par (Dollar Cost Averaging).\n                      </p>\n                    </div>\n                    <Select \n                      value={config?.positionMode ?? \"SINGLE\"}\n                      onValueChange={(value) => updateMutation.mutate({ positionMode: value })}\n                    >\n                      <SelectTrigger className=\"w-[160px] font-mono bg-background/50\" data-testid=\"select-position-mode\">\n                        <SelectValue />\n                      </SelectTrigger>\n                      <SelectContent>\n                        <SelectItem value=\"SINGLE\">SINGLE</SelectItem>\n                        <SelectItem value=\"DCA\">DCA</SelectItem>\n                        <SelectItem value=\"SMART_GUARD\">SMART_GUARD</SelectItem>\n                      </SelectContent>\n                    </Select>\n                  </div>\n                </div>\n                <div className={`p-3 rounded-lg text-sm ${\n                  config?.positionMode === \"DCA\" \n                    ? \"bg-yellow-500/10 border border-yellow-500/30 text-yellow-400\" \n                    : config?.positionMode === \"SMART_GUARD\"\n                    ? \"bg-blue-500/10 border border-blue-500/30 text-blue-400\"\n                    : \"bg-green-500/10 border border-green-500/30 text-green-400\"\n                }`}>\n                  {config?.positionMode === \"DCA\" ? (\n                    <>\n                      <strong>Modo DCA activo:</strong> El bot puede realizar mÃºltiples compras del mismo par para promediar el precio de entrada.\n                    </>\n                  ) : config?.positionMode === \"SMART_GUARD\" ? (\n                    <>\n                      <strong>Modo SMART_GUARD activo:</strong> Una posiciÃ³n por par con protecciÃ³n inteligente: break-even automÃ¡tico, stop dinÃ¡mico (trailing) y salida escalonada opcional.\n                    </>\n                  ) : (\n                    <>\n                      <strong>Modo SINGLE activo:</strong> El bot bloquearÃ¡ nuevas compras de un par si ya existe una posiciÃ³n abierta.\n                    </>\n                  )}\n                </div>\n                \n                {config?.positionMode === \"SMART_GUARD\" && (\n                  <div className=\"space-y-4 p-4 border border-blue-500/30 rounded-lg bg-blue-500/5\" data-testid=\"panel-smart-guard-config\">\n                    <h4 className=\"font-medium text-blue-400 flex items-center gap-2\" data-testid=\"text-smart-guard-title\">\n                      <Shield className=\"h-4 w-4\" />\n                      ConfiguraciÃ³n SMART_GUARD\n                    </h4>\n                    \n                    <p className=\"text-xs text-muted-foreground bg-muted/30 p-2 rounded border border-border/50\" data-testid=\"text-sg-global-limits-note\">\n                      Los lÃ­mites globales de Riesgo por Trade y ExposiciÃ³n estÃ¡n en \"TamaÃ±o de Trade\" y \"Control de ExposiciÃ³n\" (pÃ¡gina Estrategias).\n                    </p>\n                    \n                    <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n                      <div className=\"space-y-2\">\n                        <Label className=\"text-sm\">MÃ­nimo por operaciÃ³n (USD)</Label>\n                        <Input\n                          type=\"number\"\n                          value={config.sgMinEntryUsd}\n                          onChange={(e) => updateMutation.mutate({ sgMinEntryUsd: e.target.value })}\n                          className=\"font-mono bg-background/50\"\n                          data-testid=\"input-sg-min-entry\"\n                        />\n                        <p className=\"text-xs text-muted-foreground\" data-testid=\"text-sg-min-entry-desc\">No entrar si el monto disponible es menor a este valor.</p>\n                        <div className=\"flex items-center justify-between mt-2\">\n                          <Label className=\"text-xs text-muted-foreground\">Permitir entradas menores</Label>\n                          <Switch\n                            checked={config.sgAllowUnderMin}\n                            onCheckedChange={(checked) => updateMutation.mutate({ sgAllowUnderMin: checked })}\n                            data-testid=\"switch-sg-allow-under-min\"\n                          />\n                        </div>\n                      </div>\n                      \n                      <div className=\"space-y-2\">\n                        <Label className=\"text-sm\">MÃ¡ximo lotes por par</Label>\n                        <Input\n                          type=\"number\"\n                          min={1}\n                          max={10}\n                          value={config.sgMaxOpenLotsPerPair || 1}\n                          onChange={(e) => updateMutation.mutate({ sgMaxOpenLotsPerPair: parseInt(e.target.value) || 1 })}\n                          className=\"font-mono bg-background/50\"\n                          data-testid=\"input-sg-max-lots\"\n                        />\n                        <p className=\"text-xs text-muted-foreground\" data-testid=\"text-sg-max-lots-desc\">NÃºmero mÃ¡ximo de posiciones abiertas por par (1 = una entrada, 2+ = permitir DCA en SMART_GUARD).</p>\n                      </div>\n                      \n                      <div className=\"space-y-2\">\n                        <Label className=\"text-sm\">Proteger ganancias a partir de (%)</Label>\n                        <Input\n                          type=\"number\"\n                          step=\"0.1\"\n                          value={config.sgBeAtPct}\n                          onChange={(e) => updateMutation.mutate({ sgBeAtPct: e.target.value })}\n                          className=\"font-mono bg-background/50\"\n                          data-testid=\"input-sg-be-at\"\n                        />\n                        <p className=\"text-xs text-muted-foreground\" data-testid=\"text-sg-be-at-desc\">Mover stop a break-even cuando la ganancia alcance este %.</p>\n                      </div>\n                      \n                      <div className=\"space-y-2\">\n                        <Label className=\"text-sm\">ColchÃ³n de comisiones (%)</Label>\n                        <Input\n                          type=\"number\"\n                          step=\"0.05\"\n                          value={config.sgFeeCushionPct}\n                          onChange={(e) => updateMutation.mutate({ sgFeeCushionPct: e.target.value })}\n                          className=\"font-mono bg-background/50\"\n                          disabled={config.sgFeeCushionAuto}\n                          data-testid=\"input-sg-fee-cushion\"\n                        />\n                        <p className=\"text-xs text-muted-foreground\" data-testid=\"text-sg-fee-cushion-desc\">Margen sobre precio de entrada para cubrir fees (~0.45%).</p>\n                        <div className=\"flex items-center justify-between mt-2\">\n                          <Label className=\"text-xs text-muted-foreground\">Calcular automÃ¡ticamente</Label>\n                          <Switch\n                            checked={config.sgFeeCushionAuto}\n                            onCheckedChange={(checked) => updateMutation.mutate({ sgFeeCushionAuto: checked })}\n                            data-testid=\"switch-sg-fee-cushion-auto\"\n                          />\n                        </div>\n                      </div>\n                      \n                      <div className=\"space-y-2\">\n                        <Label className=\"text-sm\">Stop dinÃ¡mico: empieza a partir de (%)</Label>\n                        <Input\n                          type=\"number\"\n                          step=\"0.1\"\n                          value={config.sgTrailStartPct}\n                          onChange={(e) => updateMutation.mutate({ sgTrailStartPct: e.target.value })}\n                          className=\"font-mono bg-background/50\"\n                          data-testid=\"input-sg-trail-start\"\n                        />\n                        <p className=\"text-xs text-muted-foreground\" data-testid=\"text-sg-trail-start-desc\">El trailing stop se activa cuando la ganancia alcanza este %.</p>\n                      </div>\n                      \n                      <div className=\"space-y-2\">\n                        <Label className=\"text-sm\">Stop dinÃ¡mico: distancia (%)</Label>\n                        <Input\n                          type=\"number\"\n                          step=\"0.1\"\n                          value={config.sgTrailDistancePct}\n                          onChange={(e) => updateMutation.mutate({ sgTrailDistancePct: e.target.value })}\n                          className=\"font-mono bg-background/50\"\n                          data-testid=\"input-sg-trail-distance\"\n                        />\n                        <p className=\"text-xs text-muted-foreground\" data-testid=\"text-sg-trail-distance-desc\">Distancia del stop respecto al precio mÃ¡ximo alcanzado.</p>\n                      </div>\n                      \n                      <div className=\"space-y-2\">\n                        <Label className=\"text-sm\">Stop dinÃ¡mico: paso mÃ­nimo (%)</Label>\n                        <Input\n                          type=\"number\"\n                          step=\"0.05\"\n                          value={config.sgTrailStepPct}\n                          onChange={(e) => updateMutation.mutate({ sgTrailStepPct: e.target.value })}\n                          className=\"font-mono bg-background/50\"\n                          data-testid=\"input-sg-trail-step\"\n                        />\n                        <p className=\"text-xs text-muted-foreground\" data-testid=\"text-sg-trail-step-desc\">El stop sube en escalones de al menos este % para evitar spam.</p>\n                      </div>\n                    </div>\n                    \n                    <div className=\"border-t border-border/50 pt-4 space-y-4\">\n                      <div className=\"flex items-center justify-between\">\n                        <div className=\"space-y-1\">\n                          <Label>Salida por objetivo fijo (opcional)</Label>\n                          <p className=\"text-xs text-muted-foreground\" data-testid=\"text-sg-tp-fixed-desc\">Cerrar toda la posiciÃ³n al alcanzar un % de ganancia fijo.</p>\n                        </div>\n                        <Switch\n                          checked={config.sgTpFixedEnabled}\n                          onCheckedChange={(checked) => updateMutation.mutate({ sgTpFixedEnabled: checked })}\n                          data-testid=\"switch-sg-tp-fixed\"\n                        />\n                      </div>\n                      \n                      {config.sgTpFixedEnabled && (\n                        <div className=\"space-y-2\">\n                          <Label className=\"text-sm\">Take-Profit fijo (%)</Label>\n                          <Input\n                            type=\"number\"\n                            step=\"0.5\"\n                            value={config.sgTpFixedPct}\n                            onChange={(e) => updateMutation.mutate({ sgTpFixedPct: e.target.value })}\n                            className=\"font-mono bg-background/50\"\n                            data-testid=\"input-sg-tp-fixed\"\n                          />\n                        </div>\n                      )}\n                    </div>\n                    \n                    <div className=\"border-t border-border/50 pt-4 space-y-4\">\n                      <div className=\"flex items-center justify-between\">\n                        <div className=\"space-y-1\">\n                          <Label>Salida en 2 pasos (solo si es excepcional)</Label>\n                          <p className=\"text-xs text-muted-foreground\" data-testid=\"text-sg-scale-out-desc\">Vender una parte cuando la seÃ±al es muy fuerte, el resto con trailing.</p>\n                        </div>\n                        <Switch\n                          checked={config.sgScaleOutEnabled}\n                          onCheckedChange={(checked) => updateMutation.mutate({ sgScaleOutEnabled: checked })}\n                          data-testid=\"switch-sg-scale-out\"\n                        />\n                      </div>\n                      \n                      {config.sgScaleOutEnabled && (\n                        <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n                          <div className=\"space-y-2\">\n                            <Label className=\"text-sm\">Porcentaje a vender (%)</Label>\n                            <Input\n                              type=\"number\"\n                              step=\"5\"\n                              value={config.sgScaleOutPct}\n                              onChange={(e) => updateMutation.mutate({ sgScaleOutPct: e.target.value })}\n                              className=\"font-mono bg-background/50\"\n                              data-testid=\"input-sg-scale-out-pct\"\n                            />\n                          </div>\n                          <div className=\"space-y-2\">\n                            <Label className=\"text-sm\">MÃ­nimo parte (USD)</Label>\n                            <Input\n                              type=\"number\"\n                              value={config.sgMinPartUsd}\n                              onChange={(e) => updateMutation.mutate({ sgMinPartUsd: e.target.value })}\n                              className=\"font-mono bg-background/50\"\n                              data-testid=\"input-sg-min-part\"\n                            />\n                          </div>\n                          <div className=\"space-y-2\">\n                            <Label className=\"text-sm\">Confianza mÃ­nima (%)</Label>\n                            <Input\n                              type=\"number\"\n                              value={config.sgScaleOutThreshold}\n                              onChange={(e) => updateMutation.mutate({ sgScaleOutThreshold: e.target.value })}\n                              className=\"font-mono bg-background/50\"\n                              data-testid=\"input-sg-scale-threshold\"\n                            />\n                          </div>\n                        </div>\n                      )}\n                    </div>\n                    \n                    <PairOverridesSection \n                      overrides={config.sgPairOverrides as Record<string, Record<string, unknown>> | null}\n                      onUpdate={(newOverrides) => updateMutation.mutate({ sgPairOverrides: newOverrides })}\n                      activePairs={config.activePairs}\n                    />\n                  </div>\n                )}\n              </CardContent>\n            </Card>\n\n            {/* AI Integration */}\n            <Card className=\"glass-panel border-border/50\">\n              <CardHeader>\n                <div className=\"flex items-center gap-3\">\n                  <div className=\"p-2 bg-primary/20 rounded-lg\">\n                    <Brain className=\"h-6 w-6 text-primary\" />\n                  </div>\n                  <div>\n                    <CardTitle>Motor de Inteligencia Artificial</CardTitle>\n                    <CardDescription>Filtro predictivo basado en Machine Learning.</CardDescription>\n                  </div>\n                </div>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                {aiLoading ? (\n                  <div className=\"flex items-center justify-center py-8\">\n                    <Loader2 className=\"h-6 w-6 animate-spin text-muted-foreground\" />\n                  </div>\n                ) : aiStatus ? (\n                  <>\n                    <div className=\"space-y-2\">\n                      <div className=\"flex items-center justify-between\">\n                        <Label className=\"text-sm\">Trades Cerrados Etiquetados</Label>\n                        <span className=\"text-sm font-mono\">\n                          {aiStatus.completeSamples} / {aiStatus.minSamplesForActivate} trades\n                        </span>\n                      </div>\n                      <Progress \n                        value={(aiStatus.completeSamples / aiStatus.minSamplesForActivate) * 100} \n                        className=\"h-2\"\n                      />\n                      <p className=\"text-xs text-muted-foreground\">\n                        {aiStatus.completeSamples < 300 \n                          ? `Necesitas ${300 - aiStatus.completeSamples} trades cerrados mÃ¡s para entrenar`\n                          : \"Listo para entrenar y activar el filtro AI\"}\n                      </p>\n                    </div>\n                    \n                    {aiDiagnostic && (\n                      <div className=\"p-3 border border-border rounded-lg bg-card/30 space-y-2\">\n                        <div className=\"flex items-center justify-between\">\n                          <Label className=\"text-xs text-muted-foreground\">DiagnÃ³stico de Dataset</Label>\n                          {aiDiagnostic.modelVersion && (\n                            <span className=\"text-xs font-mono text-primary\">{aiDiagnostic.modelVersion}</span>\n                          )}\n                        </div>\n                        <div className=\"grid grid-cols-2 md:grid-cols-4 gap-2 text-xs\">\n                          <div className=\"p-2 bg-background/50 rounded\">\n                            <span className=\"text-muted-foreground\">Operaciones:</span>\n                            <span className=\"ml-1 font-mono\">{aiDiagnostic.operationsCount}</span>\n                          </div>\n                          <div className=\"p-2 bg-background/50 rounded\">\n                            <span className=\"text-muted-foreground\">Cerrados:</span>\n                            <span className=\"ml-1 font-mono\">{aiDiagnostic.closedTradesCount}</span>\n                          </div>\n                          <div className=\"p-2 bg-background/50 rounded\">\n                            <span className=\"text-muted-foreground\">Etiquetados:</span>\n                            <span className=\"ml-1 font-mono\">{aiDiagnostic.labeledTradesCount}</span>\n                          </div>\n                          <div className=\"p-2 bg-background/50 rounded\">\n                            <span className=\"text-muted-foreground\">Win Rate:</span>\n                            <span className=\"ml-1 font-mono\">{aiDiagnostic.winRate ? `${aiDiagnostic.winRate.toFixed(1)}%` : '-'}</span>\n                          </div>\n                        </div>\n                        <div className=\"grid grid-cols-2 gap-2 text-xs\">\n                          <div className=\"p-2 bg-background/50 rounded\">\n                            <span className=\"text-muted-foreground\">Ãšltimo Backfill:</span>\n                            <span className=\"ml-1 font-mono\">\n                              {aiDiagnostic.lastBackfillRun \n                                ? new Date(aiDiagnostic.lastBackfillRun).toLocaleString('es-ES', { dateStyle: 'short', timeStyle: 'short' })\n                                : 'Nunca'}\n                            </span>\n                          </div>\n                          <div className=\"p-2 bg-background/50 rounded\">\n                            <span className=\"text-muted-foreground\">Ãšltimo Entrenamiento:</span>\n                            <span className=\"ml-1 font-mono\">\n                              {aiDiagnostic.lastTrainRun \n                                ? new Date(aiDiagnostic.lastTrainRun).toLocaleString('es-ES', { dateStyle: 'short', timeStyle: 'short' })\n                                : 'Nunca'}\n                            </span>\n                          </div>\n                        </div>\n                        {aiDiagnostic.lastBackfillError && (\n                          <div className=\"text-xs text-red-500 p-2 bg-red-500/10 rounded\">\n                            Error Backfill: {aiDiagnostic.lastBackfillError}\n                          </div>\n                        )}\n                        {aiDiagnostic.lastTrainError && (\n                          <div className=\"text-xs text-red-500 p-2 bg-red-500/10 rounded\">\n                            Error Entrenamiento: {aiDiagnostic.lastTrainError}\n                          </div>\n                        )}\n                        {Object.keys(aiDiagnostic.discardReasonsDataset || {}).length > 0 && (\n                          <div className=\"space-y-2 p-3 bg-yellow-500/10 rounded-lg border border-yellow-500/20\">\n                            <div className=\"flex items-center gap-2 text-yellow-500 text-xs font-medium\">\n                              <span>âš ï¸ Trades Excluidos del Entrenamiento</span>\n                            </div>\n                            <div className=\"grid grid-cols-1 gap-1.5 text-xs\">\n                              {Object.entries(aiDiagnostic.discardReasonsDataset || {}).map(([k, v]) => {\n                                const discardInfo: Record<string, { label: string; desc: string }> = {\n                                  'sin_fecha_ejecucion': { \n                                    label: 'Sin fecha', \n                                    desc: 'El trade no tiene timestamp de ejecuciÃ³n' \n                                  },\n                                  'datos_invalidos': { \n                                    label: 'Datos invÃ¡lidos', \n                                    desc: 'Precio o cantidad <= 0' \n                                  },\n                                  'venta_sin_compra_previa': { \n                                    label: 'Venta huÃ©rfana', \n                                    desc: 'SELL sin BUY correspondiente (inventario pre-bot)' \n                                  },\n                                  'venta_excede_lotes': { \n                                    label: 'Venta excede stock', \n                                    desc: 'La cantidad vendida supera los lotes abiertos' \n                                  },\n                                  'comisiones_anormales': { \n                                    label: 'Comisiones raras', \n                                    desc: 'Fees fuera del rango 0.1%-2.5%' \n                                  },\n                                  'pnl_atipico': { \n                                    label: 'PnL extremo', \n                                    desc: 'Ganancia/pÃ©rdida > 100% (outlier estadÃ­stico)' \n                                  },\n                                  'hold_excesivo': { \n                                    label: 'Hold muy largo', \n                                    desc: 'PosiciÃ³n mantenida > 30 dÃ­as' \n                                  },\n                                  'timestamps_invalidos': { \n                                    label: 'Fechas errÃ³neas', \n                                    desc: 'Exit timestamp antes de entry timestamp' \n                                  },\n                                };\n                                const info = discardInfo[k] || { label: k, desc: 'Sin descripciÃ³n disponible' };\n                                return (\n                                  <div key={k} className=\"flex items-center justify-between p-1.5 bg-background/50 rounded\" title={info.desc}>\n                                    <span className=\"text-muted-foreground\">{info.label}</span>\n                                    <span className=\"font-mono text-yellow-500\">{v as number}</span>\n                                  </div>\n                                );\n                              })}\n                            </div>\n                            <div className=\"text-[10px] text-muted-foreground mt-1\">\n                              ğŸ’¡ Estos trades se excluyen para evitar sesgos en el modelo ML\n                            </div>\n                          </div>\n                        )}\n                        <Button \n                          size=\"sm\" \n                          variant=\"outline\"\n                          className=\"w-full\"\n                          disabled={backfillMutation.isPending}\n                          onClick={() => backfillMutation.mutate()}\n                          data-testid=\"button-backfill\"\n                        >\n                          {backfillMutation.isPending ? (\n                            <><Loader2 className=\"mr-2 h-4 w-4 animate-spin\" /> Procesando...</>\n                          ) : \"Ejecutar Backfill (Regenerar Dataset)\"}\n                        </Button>\n                      </div>\n                    )}\n                    \n                    <div className=\"p-4 border border-border rounded-lg bg-card/30\">\n                      <div className=\"flex items-center justify-between\">\n                        <div className=\"flex items-center gap-2\">\n                          <span className={`h-3 w-3 rounded-full ${\n                            aiStatus.phase === \"green\" ? \"bg-green-500\" : \n                            aiStatus.phase === \"yellow\" ? \"bg-yellow-500\" : \"bg-red-500\"\n                          } ${aiStatus.phase !== \"red\" ? \"animate-pulse\" : \"\"}`}></span>\n                          <span className=\"font-mono text-sm\">{aiStatus.phaseLabel}</span>\n                        </div>\n                        <Button \n                          size=\"sm\" \n                          variant=\"secondary\"\n                          disabled={!aiStatus.canTrain || trainMutation.isPending}\n                          onClick={() => trainMutation.mutate()}\n                          data-testid=\"button-train-ai\"\n                        >\n                          {trainMutation.isPending ? (\n                            <><Loader2 className=\"mr-2 h-4 w-4 animate-spin\" /> Entrenando...</>\n                          ) : \"Entrenar Modelo\"}\n                        </Button>\n                      </div>\n                      {aiStatus.metrics && (\n                        <div className=\"mt-3 grid grid-cols-2 gap-2 text-xs\">\n                          <div className=\"p-2 bg-background/50 rounded\">\n                            <span className=\"text-muted-foreground\">Accuracy:</span>\n                            <span className=\"ml-2 font-mono\">{((aiStatus.metrics.accuracy ?? 0) * 100).toFixed(1)}%</span>\n                          </div>\n                          <div className=\"p-2 bg-background/50 rounded\">\n                            <span className=\"text-muted-foreground\">Precision:</span>\n                            <span className=\"ml-2 font-mono\">{((aiStatus.metrics.precision ?? 0) * 100).toFixed(1)}%</span>\n                          </div>\n                        </div>\n                      )}\n                    </div>\n                    \n                    <div className=\"space-y-3\">\n                      <div className=\"flex items-center justify-between p-3 border border-border rounded-lg bg-card/30\">\n                        <div className=\"space-y-0.5\">\n                          <Label>Shadow Mode</Label>\n                          <p className=\"text-xs text-muted-foreground\">Registra predicciones sin bloquear trades</p>\n                        </div>\n                        <Switch \n                          checked={aiStatus.shadowEnabled}\n                          onCheckedChange={(checked) => toggleAiMutation.mutate({ shadowEnabled: checked })}\n                          data-testid=\"switch-ai-shadow\"\n                        />\n                      </div>\n                      <div className=\"flex items-center justify-between p-3 border border-border rounded-lg bg-card/30\">\n                        <div className=\"space-y-0.5\">\n                          <Label>Filtro Activo</Label>\n                          <p className=\"text-xs text-muted-foreground\">Bloquea trades con baja probabilidad de Ã©xito</p>\n                        </div>\n                        <Switch \n                          checked={aiStatus.filterEnabled}\n                          disabled={!aiStatus.canActivate}\n                          onCheckedChange={(checked) => toggleAiMutation.mutate({ filterEnabled: checked })}\n                          data-testid=\"switch-ai-filter\"\n                        />\n                      </div>\n                    </div>\n                  </>\n                ) : (\n                  <p className=\"text-sm text-muted-foreground\">Error cargando estado de IA</p>\n                )}\n              </CardContent>\n            </Card>\n\n            {/* NAS Deployment */}\n            <Card className=\"glass-panel border-border/50\">\n              <CardHeader>\n                <div className=\"flex items-center gap-3\">\n                  <div className=\"p-2 bg-orange-500/20 rounded-lg\">\n                    <HardDrive className=\"h-6 w-6 text-orange-400\" />\n                  </div>\n                  <div>\n                    <CardTitle>Despliegue QNAP NAS</CardTitle>\n                    <CardDescription>ConfiguraciÃ³n para Container Station y Docker.</CardDescription>\n                  </div>\n                </div>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-4\">\n                  <div className=\"grid gap-2\">\n                    <Label className=\"text-sm\">DirecciÃ³n IP del NAS</Label>\n                    <Input placeholder=\"192.168.1.104\" defaultValue=\"192.168.1.104\" className=\"font-mono bg-background/50\" />\n                  </div>\n                  <div className=\"grid gap-2\">\n                    <Label>Puerto</Label>\n                    <Input placeholder=\"3000\" defaultValue=\"3000\" className=\"font-mono bg-background/50\" />\n                  </div>\n                </div>\n                <div className=\"flex items-center justify-between p-4 border border-border rounded-lg bg-card/30\">\n                  <div className=\"space-y-0.5\">\n                    <Label>Auto-Reinicio en Fallo</Label>\n                    <p className=\"text-sm text-muted-foreground\">PolÃ­tica de reinicio de Docker (--restart unless-stopped)</p>\n                  </div>\n                  <Switch defaultChecked />\n                </div>\n                <div className=\"flex items-center justify-between p-4 border border-border rounded-lg bg-card/30\">\n                  <div className=\"space-y-0.5\">\n                    <Label>Auto-ActualizaciÃ³n</Label>\n                    <p className=\"text-sm text-muted-foreground\">Actualiza automÃ¡ticamente desde Git cada hora</p>\n                  </div>\n                  <Switch defaultChecked />\n                </div>\n                <Button \n                  className=\"w-full bg-orange-600 hover:bg-orange-700 text-white\" \n                  onClick={() => {\n                    const link = document.createElement('a');\n                    link.href = '/docker-compose.yml';\n                    link.download = 'docker-compose.yml';\n                    link.click();\n                  }}\n                  data-testid=\"button-download-docker\"\n                >\n                  <Server className=\"mr-2 h-4 w-4\" /> Descargar docker-compose.yml\n                </Button>\n              </CardContent>\n            </Card>\n\n            {/* System Info */}\n            <Card className=\"glass-panel border-border/50\">\n              <CardHeader>\n                <div className=\"flex items-center gap-3\">\n                  <div className=\"p-2 bg-cyan-500/20 rounded-lg\">\n                    <Cog className=\"h-6 w-6 text-cyan-400\" />\n                  </div>\n                  <div>\n                    <CardTitle>InformaciÃ³n del Sistema</CardTitle>\n                    <CardDescription>VersiÃ³n y estado del bot.</CardDescription>\n                  </div>\n                </div>\n              </CardHeader>\n              <CardContent>\n                <div className=\"grid grid-cols-2 gap-3 md:gap-4 text-xs md:text-sm\">\n                  <div className=\"p-2 md:p-3 border border-border rounded-lg bg-card/30\">\n                    <p className=\"text-muted-foreground\">VersiÃ³n</p>\n                    <p className=\"font-mono font-medium\">1.0.0</p>\n                  </div>\n                  <div className=\"p-2 md:p-3 border border-border rounded-lg bg-card/30\">\n                    <p className=\"text-muted-foreground\">Entorno</p>\n                    <p className=\"font-mono font-medium\">ProducciÃ³n</p>\n                  </div>\n                  <div className=\"p-2 md:p-3 border border-border rounded-lg bg-card/30\">\n                    <p className=\"text-muted-foreground\">Base de datos</p>\n                    <p className=\"font-mono font-medium text-green-500\">Conectada</p>\n                  </div>\n                  <div className=\"p-2 md:p-3 border border-border rounded-lg bg-card/30\">\n                    <p className=\"text-muted-foreground\">Ãšltima actualizaciÃ³n</p>\n                    <p className=\"font-mono font-medium\">{new Date().toLocaleDateString(\"es-ES\")}</p>\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n\n          </div>\n        </main>\n      </div>\n    </div>\n  );\n}\n\ninterface PairOverridesSectionProps {\n  overrides: Record<string, Record<string, unknown>> | null;\n  onUpdate: (newOverrides: Record<string, Record<string, unknown>> | null) => void;\n  activePairs: string[];\n}\n\nfunction PairOverridesSection({ overrides, onUpdate, activePairs }: PairOverridesSectionProps) {\n  const [expandedPair, setExpandedPair] = useState<string | null>(null);\n  const [newPair, setNewPair] = useState<string>(\"\");\n  \n  const currentOverrides = overrides || {};\n  const pairsWithOverrides = Object.keys(currentOverrides);\n  const availablePairs = activePairs.filter(p => !pairsWithOverrides.includes(p));\n\n  const handleAddPair = () => {\n    if (!newPair || pairsWithOverrides.includes(newPair)) return;\n    onUpdate({\n      ...currentOverrides,\n      [newPair]: {}\n    });\n    setExpandedPair(newPair);\n    setNewPair(\"\");\n  };\n\n  const handleRemovePair = (pair: string) => {\n    const updated = { ...currentOverrides };\n    delete updated[pair];\n    onUpdate(Object.keys(updated).length > 0 ? updated : null);\n    if (expandedPair === pair) setExpandedPair(null);\n  };\n\n  const handleUpdatePairValue = (pair: string, key: string, value: string | boolean) => {\n    const updated = {\n      ...currentOverrides,\n      [pair]: {\n        ...currentOverrides[pair],\n        [key]: value\n      }\n    };\n    onUpdate(updated);\n  };\n\n  const handleRemovePairValue = (pair: string, key: string) => {\n    const pairData = { ...currentOverrides[pair] };\n    delete pairData[key];\n    const updated = {\n      ...currentOverrides,\n      [pair]: pairData\n    };\n    if (Object.keys(pairData).length === 0) {\n      delete updated[pair];\n    }\n    onUpdate(Object.keys(updated).length > 0 ? updated : null);\n  };\n\n  return (\n    <div className=\"border-t border-blue-500/30 pt-4 mt-4\">\n      <div className=\"flex items-center justify-between mb-3\">\n        <h5 className=\"text-sm font-medium text-blue-300\" data-testid=\"text-pair-overrides-title\">\n          Ajustes por Par\n        </h5>\n        <span className=\"text-xs text-muted-foreground\">\n          {pairsWithOverrides.length} par(es) configurado(s)\n        </span>\n      </div>\n      \n      <p className=\"text-xs text-muted-foreground mb-3\">\n        Configura parÃ¡metros especÃ­ficos para cada par. Los valores aquÃ­ sobreescriben la configuraciÃ³n global.\n      </p>\n\n      {pairsWithOverrides.length > 0 && (\n        <div className=\"space-y-2 mb-3\">\n          {pairsWithOverrides.map((pair) => (\n            <div key={pair} className=\"border border-border rounded-lg bg-background/30\">\n              <div \n                className=\"flex items-center justify-between p-2 cursor-pointer hover:bg-muted/20\"\n                onClick={() => setExpandedPair(expandedPair === pair ? null : pair)}\n              >\n                <div className=\"flex items-center gap-2\">\n                  <ChevronRight className={cn(\"h-4 w-4 transition-transform\", expandedPair === pair && \"rotate-90\")} />\n                  <span className=\"font-mono text-sm\">{pair}</span>\n                  <Badge variant=\"secondary\" className=\"text-xs\">\n                    {Object.keys(currentOverrides[pair]).length} override(s)\n                  </Badge>\n                </div>\n                <Button\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  className=\"h-6 w-6 p-0 text-red-400 hover:text-red-300\"\n                  onClick={(e) => {\n                    e.stopPropagation();\n                    handleRemovePair(pair);\n                  }}\n                  data-testid={`btn-remove-override-${pair.replace(\"/\", \"-\")}`}\n                >\n                  <Trash2 className=\"h-3 w-3\" />\n                </Button>\n              </div>\n              \n              {expandedPair === pair && (\n                <div className=\"p-3 border-t border-border space-y-3\">\n                  <PairOverrideFields\n                    pairData={currentOverrides[pair]}\n                    onUpdateValue={(key, value) => handleUpdatePairValue(pair, key, value)}\n                    onRemoveValue={(key) => handleRemovePairValue(pair, key)}\n                  />\n                </div>\n              )}\n            </div>\n          ))}\n        </div>\n      )}\n\n      {availablePairs.length > 0 && (\n        <div className=\"flex gap-2\">\n          <Select value={newPair} onValueChange={setNewPair}>\n            <SelectTrigger className=\"w-[180px] bg-background/50\" data-testid=\"select-new-pair\">\n              <SelectValue placeholder=\"Seleccionar par...\" />\n            </SelectTrigger>\n            <SelectContent>\n              {availablePairs.map((pair) => (\n                <SelectItem key={pair} value={pair}>{pair}</SelectItem>\n              ))}\n            </SelectContent>\n          </Select>\n          <Button \n            variant=\"outline\" \n            size=\"sm\" \n            onClick={handleAddPair}\n            disabled={!newPair}\n            data-testid=\"btn-add-pair-override\"\n          >\n            <Plus className=\"h-4 w-4 mr-1\" />\n            Agregar\n          </Button>\n        </div>\n      )}\n    </div>\n  );\n}\n\ninterface PairOverrideFieldsProps {\n  pairData: Record<string, unknown>;\n  onUpdateValue: (key: string, value: string | boolean) => void;\n  onRemoveValue: (key: string) => void;\n}\n\nconst OVERRIDE_FIELDS = [\n  { key: \"sgMinEntryUsd\", label: \"MÃ­nimo entrada (USD)\", type: \"number\" },\n  { key: \"sgAllowUnderMin\", label: \"Permitir bajo mÃ­nimo\", type: \"boolean\" },\n  { key: \"sgBeAtPct\", label: \"Break-Even (%)\", type: \"number\" },\n  { key: \"sgFeeCushionPct\", label: \"ColchÃ³n comisiones (%)\", type: \"number\" },\n  { key: \"sgTrailStartPct\", label: \"Trail inicio (%)\", type: \"number\" },\n  { key: \"sgTrailDistancePct\", label: \"Trail distancia (%)\", type: \"number\" },\n  { key: \"sgTrailStepPct\", label: \"Trail paso (%)\", type: \"number\" },\n  { key: \"sgTpFixedEnabled\", label: \"TP fijo habilitado\", type: \"boolean\" },\n  { key: \"sgTpFixedPct\", label: \"TP fijo (%)\", type: \"number\" },\n  { key: \"sgScaleOutEnabled\", label: \"Scale-Out habilitado\", type: \"boolean\" },\n  { key: \"sgScaleOutPct\", label: \"Scale-Out (%)\", type: \"number\" },\n  { key: \"sgScaleOutThreshold\", label: \"Scale-Out confianza (%)\", type: \"number\" },\n  { key: \"sgMinPartUsd\", label: \"MÃ­nimo parte (USD)\", type: \"number\" },\n];\n\nfunction PairOverrideFields({ pairData, onUpdateValue, onRemoveValue }: PairOverrideFieldsProps) {\n  const activeKeys = Object.keys(pairData);\n  const availableFields = OVERRIDE_FIELDS.filter(f => !activeKeys.includes(f.key));\n  const [newFieldKey, setNewFieldKey] = useState<string>(\"\");\n\n  const handleAddField = () => {\n    if (!newFieldKey) return;\n    const field = OVERRIDE_FIELDS.find(f => f.key === newFieldKey);\n    if (field) {\n      onUpdateValue(newFieldKey, field.type === \"boolean\" ? false : \"\");\n      setNewFieldKey(\"\");\n    }\n  };\n\n  return (\n    <div className=\"space-y-2\">\n      {activeKeys.map((key) => {\n        const field = OVERRIDE_FIELDS.find(f => f.key === key);\n        if (!field) return null;\n        \n        return (\n          <div key={key} className=\"flex items-center gap-2\">\n            <Label className=\"text-xs w-32 flex-shrink-0\">{field.label}</Label>\n            {field.type === \"boolean\" ? (\n              <Switch\n                checked={!!pairData[key]}\n                onCheckedChange={(val) => onUpdateValue(key, val)}\n                data-testid={`switch-override-${key}`}\n              />\n            ) : (\n              <Input\n                type=\"number\"\n                value={String(pairData[key] || \"\")}\n                onChange={(e) => onUpdateValue(key, e.target.value)}\n                className=\"h-7 text-xs font-mono flex-1\"\n                data-testid={`input-override-${key}`}\n              />\n            )}\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              className=\"h-6 w-6 p-0 text-muted-foreground hover:text-red-400\"\n              onClick={() => onRemoveValue(key)}\n            >\n              <X className=\"h-3 w-3\" />\n            </Button>\n          </div>\n        );\n      })}\n      \n      {availableFields.length > 0 && (\n        <div className=\"flex gap-2 pt-2 border-t border-border/50\">\n          <Select value={newFieldKey} onValueChange={setNewFieldKey}>\n            <SelectTrigger className=\"w-[200px] h-7 text-xs\" data-testid=\"select-new-field\">\n              <SelectValue placeholder=\"Agregar campo...\" />\n            </SelectTrigger>\n            <SelectContent>\n              {availableFields.map((f) => (\n                <SelectItem key={f.key} value={f.key}>{f.label}</SelectItem>\n              ))}\n            </SelectContent>\n          </Select>\n          <Button \n            variant=\"outline\" \n            size=\"sm\" \n            className=\"h-7 text-xs\"\n            onClick={handleAddField}\n            disabled={!newFieldKey}\n          >\n            <Plus className=\"h-3 w-3\" />\n          </Button>\n        </div>\n      )}\n    </div>\n  );\n}\n","path":null,"size_bytes":62139,"size_tokens":null},"client/src/components/ui/resizable.tsx":{"content":"\"use client\"\n\nimport { GripVertical } from \"lucide-react\"\nimport * as ResizablePrimitive from \"react-resizable-panels\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ResizablePanelGroup = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (\n  <ResizablePrimitive.PanelGroup\n    className={cn(\n      \"flex h-full w-full data-[panel-group-direction=vertical]:flex-col\",\n      className\n    )}\n    {...props}\n  />\n)\n\nconst ResizablePanel = ResizablePrimitive.Panel\n\nconst ResizableHandle = ({\n  withHandle,\n  className,\n  ...props\n}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {\n  withHandle?: boolean\n}) => (\n  <ResizablePrimitive.PanelResizeHandle\n    className={cn(\n      \"relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90\",\n      className\n    )}\n    {...props}\n  >\n    {withHandle && (\n      <div className=\"z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border\">\n        <GripVertical className=\"h-2.5 w-2.5\" />\n      </div>\n    )}\n  </ResizablePrimitive.PanelResizeHandle>\n)\n\nexport { ResizablePanelGroup, ResizablePanel, ResizableHandle }\n","path":null,"size_bytes":1723,"size_tokens":null},"client/src/components/ui/select.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as SelectPrimitive from \"@radix-ui/react-select\"\nimport { Check, ChevronDown, ChevronUp } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Select = SelectPrimitive.Root\n\nconst SelectGroup = SelectPrimitive.Group\n\nconst SelectValue = SelectPrimitive.Value\n\nconst SelectTrigger = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <SelectPrimitive.Icon asChild>\n      <ChevronDown className=\"h-4 w-4 opacity-50\" />\n    </SelectPrimitive.Icon>\n  </SelectPrimitive.Trigger>\n))\nSelectTrigger.displayName = SelectPrimitive.Trigger.displayName\n\nconst SelectScrollUpButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollUpButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronUp className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollUpButton>\n))\nSelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName\n\nconst SelectScrollDownButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollDownButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronDown className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollDownButton>\n))\nSelectScrollDownButton.displayName =\n  SelectPrimitive.ScrollDownButton.displayName\n\nconst SelectContent = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>\n>(({ className, children, position = \"popper\", ...props }, ref) => (\n  <SelectPrimitive.Portal>\n    <SelectPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]\",\n        position === \"popper\" &&\n          \"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\",\n        className\n      )}\n      position={position}\n      {...props}\n    >\n      <SelectScrollUpButton />\n      <SelectPrimitive.Viewport\n        className={cn(\n          \"p-1\",\n          position === \"popper\" &&\n            \"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]\"\n        )}\n      >\n        {children}\n      </SelectPrimitive.Viewport>\n      <SelectScrollDownButton />\n    </SelectPrimitive.Content>\n  </SelectPrimitive.Portal>\n))\nSelectContent.displayName = SelectPrimitive.Content.displayName\n\nconst SelectLabel = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Label\n    ref={ref}\n    className={cn(\"px-2 py-1.5 text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nSelectLabel.displayName = SelectPrimitive.Label.displayName\n\nconst SelectItem = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute right-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <SelectPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </SelectPrimitive.ItemIndicator>\n    </span>\n    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\n  </SelectPrimitive.Item>\n))\nSelectItem.displayName = SelectPrimitive.Item.displayName\n\nconst SelectSeparator = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nSelectSeparator.displayName = SelectPrimitive.Separator.displayName\n\nexport {\n  Select,\n  SelectGroup,\n  SelectValue,\n  SelectTrigger,\n  SelectContent,\n  SelectLabel,\n  SelectItem,\n  SelectSeparator,\n  SelectScrollUpButton,\n  SelectScrollDownButton,\n}\n","path":null,"size_bytes":5745,"size_tokens":null},"client/src/components/ui/input-otp.tsx":{"content":"import * as React from \"react\"\nimport { OTPInput, OTPInputContext } from \"input-otp\"\nimport { Minus } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst InputOTP = React.forwardRef<\n  React.ElementRef<typeof OTPInput>,\n  React.ComponentPropsWithoutRef<typeof OTPInput>\n>(({ className, containerClassName, ...props }, ref) => (\n  <OTPInput\n    ref={ref}\n    containerClassName={cn(\n      \"flex items-center gap-2 has-[:disabled]:opacity-50\",\n      containerClassName\n    )}\n    className={cn(\"disabled:cursor-not-allowed\", className)}\n    {...props}\n  />\n))\nInputOTP.displayName = \"InputOTP\"\n\nconst InputOTPGroup = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\">\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"flex items-center\", className)} {...props} />\n))\nInputOTPGroup.displayName = \"InputOTPGroup\"\n\nconst InputOTPSlot = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\"> & { index: number }\n>(({ index, className, ...props }, ref) => {\n  const inputOTPContext = React.useContext(OTPInputContext)\n  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]\n\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        \"relative flex h-9 w-9 items-center justify-center border-y border-r border-input text-sm shadow-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md\",\n        isActive && \"z-10 ring-1 ring-ring\",\n        className\n      )}\n      {...props}\n    >\n      {char}\n      {hasFakeCaret && (\n        <div className=\"pointer-events-none absolute inset-0 flex items-center justify-center\">\n          <div className=\"h-4 w-px animate-caret-blink bg-foreground duration-1000\" />\n        </div>\n      )}\n    </div>\n  )\n})\nInputOTPSlot.displayName = \"InputOTPSlot\"\n\nconst InputOTPSeparator = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\">\n>(({ ...props }, ref) => (\n  <div ref={ref} role=\"separator\" {...props}>\n    <Minus />\n  </div>\n))\nInputOTPSeparator.displayName = \"InputOTPSeparator\"\n\nexport { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }\n","path":null,"size_bytes":2143,"size_tokens":null},"client/src/components/ui/pagination.tsx":{"content":"import * as React from \"react\"\nimport { ChevronLeft, ChevronRight, MoreHorizontal } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { ButtonProps, buttonVariants } from \"@/components/ui/button\"\n\nconst Pagination = ({ className, ...props }: React.ComponentProps<\"nav\">) => (\n  <nav\n    role=\"navigation\"\n    aria-label=\"pagination\"\n    className={cn(\"mx-auto flex w-full justify-center\", className)}\n    {...props}\n  />\n)\nPagination.displayName = \"Pagination\"\n\nconst PaginationContent = React.forwardRef<\n  HTMLUListElement,\n  React.ComponentProps<\"ul\">\n>(({ className, ...props }, ref) => (\n  <ul\n    ref={ref}\n    className={cn(\"flex flex-row items-center gap-1\", className)}\n    {...props}\n  />\n))\nPaginationContent.displayName = \"PaginationContent\"\n\nconst PaginationItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentProps<\"li\">\n>(({ className, ...props }, ref) => (\n  <li ref={ref} className={cn(\"\", className)} {...props} />\n))\nPaginationItem.displayName = \"PaginationItem\"\n\ntype PaginationLinkProps = {\n  isActive?: boolean\n} & Pick<ButtonProps, \"size\"> &\n  React.ComponentProps<\"a\">\n\nconst PaginationLink = ({\n  className,\n  isActive,\n  size = \"icon\",\n  ...props\n}: PaginationLinkProps) => (\n  <a\n    aria-current={isActive ? \"page\" : undefined}\n    className={cn(\n      buttonVariants({\n        variant: isActive ? \"outline\" : \"ghost\",\n        size,\n      }),\n      className\n    )}\n    {...props}\n  />\n)\nPaginationLink.displayName = \"PaginationLink\"\n\nconst PaginationPrevious = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof PaginationLink>) => (\n  <PaginationLink\n    aria-label=\"Go to previous page\"\n    size=\"default\"\n    className={cn(\"gap-1 pl-2.5\", className)}\n    {...props}\n  >\n    <ChevronLeft className=\"h-4 w-4\" />\n    <span>Previous</span>\n  </PaginationLink>\n)\nPaginationPrevious.displayName = \"PaginationPrevious\"\n\nconst PaginationNext = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof PaginationLink>) => (\n  <PaginationLink\n    aria-label=\"Go to next page\"\n    size=\"default\"\n    className={cn(\"gap-1 pr-2.5\", className)}\n    {...props}\n  >\n    <span>Next</span>\n    <ChevronRight className=\"h-4 w-4\" />\n  </PaginationLink>\n)\nPaginationNext.displayName = \"PaginationNext\"\n\nconst PaginationEllipsis = ({\n  className,\n  ...props\n}: React.ComponentProps<\"span\">) => (\n  <span\n    aria-hidden\n    className={cn(\"flex h-9 w-9 items-center justify-center\", className)}\n    {...props}\n  >\n    <MoreHorizontal className=\"h-4 w-4\" />\n    <span className=\"sr-only\">More pages</span>\n  </span>\n)\nPaginationEllipsis.displayName = \"PaginationEllipsis\"\n\nexport {\n  Pagination,\n  PaginationContent,\n  PaginationLink,\n  PaginationItem,\n  PaginationPrevious,\n  PaginationNext,\n  PaginationEllipsis,\n}\n","path":null,"size_bytes":2751,"size_tokens":null},"client/src/components/ui/item.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Separator } from \"@/components/ui/separator\"\n\nfunction ItemGroup({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      role=\"list\"\n      data-slot=\"item-group\"\n      className={cn(\"group/item-group flex flex-col\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction ItemSeparator({\n  className,\n  ...props\n}: React.ComponentProps<typeof Separator>) {\n  return (\n    <Separator\n      data-slot=\"item-separator\"\n      orientation=\"horizontal\"\n      className={cn(\"my-0\", className)}\n      {...props}\n    />\n  )\n}\n\nconst itemVariants = cva(\n  \"group/item [a]:hover:bg-accent/50 focus-visible:border-ring focus-visible:ring-ring/50 [a]:transition-colors flex flex-wrap items-center rounded-md border border-transparent text-sm outline-none transition-colors duration-100 focus-visible:ring-[3px]\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-transparent\",\n        outline: \"border-border\",\n        muted: \"bg-muted/50\",\n      },\n      size: {\n        default: \"gap-4 p-4 \",\n        sm: \"gap-2.5 px-4 py-3\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nfunction Item({\n  className,\n  variant = \"default\",\n  size = \"default\",\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"div\"> &\n  VariantProps<typeof itemVariants> & { asChild?: boolean }) {\n  const Comp = asChild ? Slot : \"div\"\n  return (\n    <Comp\n      data-slot=\"item\"\n      data-variant={variant}\n      data-size={size}\n      className={cn(itemVariants({ variant, size, className }))}\n      {...props}\n    />\n  )\n}\n\nconst itemMediaVariants = cva(\n  \"flex shrink-0 items-center justify-center gap-2 group-has-[[data-slot=item-description]]/item:translate-y-0.5 group-has-[[data-slot=item-description]]/item:self-start [&_svg]:pointer-events-none\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-transparent\",\n        icon: \"bg-muted size-8 rounded-sm border [&_svg:not([class*='size-'])]:size-4\",\n        image:\n          \"size-10 overflow-hidden rounded-sm [&_img]:size-full [&_img]:object-cover\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nfunction ItemMedia({\n  className,\n  variant = \"default\",\n  ...props\n}: React.ComponentProps<\"div\"> & VariantProps<typeof itemMediaVariants>) {\n  return (\n    <div\n      data-slot=\"item-media\"\n      data-variant={variant}\n      className={cn(itemMediaVariants({ variant, className }))}\n      {...props}\n    />\n  )\n}\n\nfunction ItemContent({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"item-content\"\n      className={cn(\n        \"flex flex-1 flex-col gap-1 [&+[data-slot=item-content]]:flex-none\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction ItemTitle({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"item-title\"\n      className={cn(\n        \"flex w-fit items-center gap-2 text-sm font-medium leading-snug\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction ItemDescription({ className, ...props }: React.ComponentProps<\"p\">) {\n  return (\n    <p\n      data-slot=\"item-description\"\n      className={cn(\n        \"text-muted-foreground line-clamp-2 text-balance text-sm font-normal leading-normal\",\n        \"[&>a:hover]:text-primary [&>a]:underline [&>a]:underline-offset-4\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction ItemActions({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"item-actions\"\n      className={cn(\"flex items-center gap-2\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction ItemHeader({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"item-header\"\n      className={cn(\n        \"flex basis-full items-center justify-between gap-2\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction ItemFooter({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"item-footer\"\n      className={cn(\n        \"flex basis-full items-center justify-between gap-2\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport {\n  Item,\n  ItemMedia,\n  ItemContent,\n  ItemActions,\n  ItemGroup,\n  ItemSeparator,\n  ItemTitle,\n  ItemDescription,\n  ItemHeader,\n  ItemFooter,\n}\n","path":null,"size_bytes":4494,"size_tokens":null},"client/src/lib/utils.ts":{"content":"import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n","path":null,"size_bytes":166,"size_tokens":null},"client/src/components/dashboard/TradeLog.tsx":{"content":"import { useQuery } from \"@tanstack/react-query\";\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from \"@/components/ui/table\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { RefreshCw, Clock } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\n\ninterface Trade {\n  id: string;\n  krakenOrderId?: string;\n  pair: string;\n  type: string;\n  price: string;\n  amount: string;\n  time: string;\n  status: string;\n}\n\nexport function TradeLog() {\n  const { data: krakenTrades, isLoading, refetch, isFetching } = useQuery<Trade[]>({\n    queryKey: [\"krakenTrades\"],\n    queryFn: async () => {\n      const res = await fetch(\"/api/kraken/trades\");\n      if (!res.ok) {\n        const dbRes = await fetch(\"/api/trades?limit=10\");\n        if (!dbRes.ok) return [];\n        return dbRes.json();\n      }\n      return res.json();\n    },\n    refetchInterval: 60000,\n  });\n\n  const formatTime = (timeStr: string) => {\n    const date = new Date(timeStr);\n    return date.toLocaleTimeString(\"es-ES\", {\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n    });\n  };\n\n  const formatPrice = (price: string) => {\n    const num = parseFloat(price);\n    return num.toLocaleString(\"en-US\", { minimumFractionDigits: 2, maximumFractionDigits: 2 });\n  };\n\n  const formatAmount = (amount: string, pair: string) => {\n    const num = parseFloat(amount);\n    const asset = pair.split(\"/\")[0];\n    return `${num.toFixed(6)} ${asset}`;\n  };\n\n  return (\n    <div className=\"rounded-md border border-border bg-card/50\">\n      <div className=\"p-3 md:p-4 border-b border-border bg-muted/20 flex items-center justify-between gap-2\">\n        <h3 className=\"font-semibold font-mono text-xs md:text-sm tracking-wider text-primary\">REGISTRO DE OPERACIONES</h3>\n        <Button \n          variant=\"ghost\" \n          size=\"sm\" \n          onClick={() => refetch()}\n          disabled={isFetching}\n          className=\"text-muted-foreground hover:text-primary text-xs md:text-sm\"\n          data-testid=\"button-refresh-trades\"\n        >\n          <RefreshCw className={`h-4 w-4 ${isFetching ? 'animate-spin' : ''}`} />\n          <span className=\"hidden sm:inline ml-2\">Actualizar</span>\n        </Button>\n      </div>\n      <div className=\"overflow-x-auto\">\n        <Table>\n          <TableHeader>\n            <TableRow className=\"hover:bg-transparent border-border\">\n              <TableHead className=\"w-[80px] font-mono text-xs\">ID</TableHead>\n              <TableHead className=\"font-mono text-xs\">PAR</TableHead>\n              <TableHead className=\"font-mono text-xs\">TIPO</TableHead>\n              <TableHead className=\"font-mono text-xs text-right\">PRECIO</TableHead>\n              <TableHead className=\"font-mono text-xs text-right hidden sm:table-cell\">CANTIDAD</TableHead>\n              <TableHead className=\"font-mono text-xs text-right hidden md:table-cell\">HORA</TableHead>\n              <TableHead className=\"font-mono text-xs text-right\">ESTADO</TableHead>\n            </TableRow>\n          </TableHeader>\n          <TableBody>\n            {isLoading ? (\n              <TableRow>\n                <TableCell colSpan={7} className=\"text-center py-8\">\n                  <div className=\"flex items-center justify-center gap-2 text-muted-foreground\">\n                    <RefreshCw className=\"h-4 w-4 animate-spin\" />\n                    Cargando operaciones...\n                  </div>\n                </TableCell>\n              </TableRow>\n            ) : krakenTrades && krakenTrades.length > 0 ? (\n              krakenTrades.slice(0, 10).map((trade) => (\n                <TableRow key={trade.id || trade.krakenOrderId} className=\"hover:bg-muted/50 border-border font-mono text-xs\" data-testid={`trade-row-${trade.id}`}>\n                  <TableCell className=\"font-medium text-muted-foreground text-xs\">{trade.id}</TableCell>\n                  <TableCell className=\"text-foreground text-xs\">{trade.pair}</TableCell>\n                  <TableCell>\n                    <Badge variant=\"outline\" className={`text-xs ${trade.type === \"buy\" ? \"text-green-500 border-green-500/50 bg-green-500/10\" : \"text-red-500 border-red-500/50 bg-red-500/10\"}`}>\n                      {trade.type === \"buy\" ? \"COMPRA\" : \"VENTA\"}\n                    </Badge>\n                  </TableCell>\n                  <TableCell className=\"text-right text-xs\">{formatPrice(trade.price)}</TableCell>\n                  <TableCell className=\"text-right text-muted-foreground text-xs hidden sm:table-cell\">{formatAmount(trade.amount, trade.pair)}</TableCell>\n                  <TableCell className=\"text-right text-muted-foreground text-xs hidden md:table-cell\">{formatTime(trade.time)}</TableCell>\n                  <TableCell className=\"text-right text-primary text-xs\">{trade.status === \"filled\" ? \"OK\" : trade.status}</TableCell>\n                </TableRow>\n              ))\n            ) : (\n              <TableRow>\n                <TableCell colSpan={7} className=\"text-center py-8\">\n                  <div className=\"flex flex-col items-center gap-2 text-muted-foreground\">\n                    <Clock className=\"h-8 w-8 opacity-50\" />\n                    <p>No hay operaciones registradas</p>\n                    <p className=\"text-xs\">Las operaciones aparecerÃ¡n aquÃ­ cuando se ejecuten trades.</p>\n                  </div>\n                </TableCell>\n              </TableRow>\n            )}\n          </TableBody>\n        </Table>\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":5488,"size_tokens":null},"GUIA_INSTALACION.md":{"content":"# ğŸ¤– GUÃA COMPLETA: KrakenBot en tu QNAP NAS\n\n**Bot de Trading AutÃ³nomo para Kraken Exchange**\n\nEsta guÃ­a te lleva paso a paso desde cero hasta tener el bot funcionando.\n\n---\n\n# ğŸ“‹ ANTES DE EMPEZAR\n\n## Lo que vas a necesitar:\n\n| Cosa | Para quÃ© |\n|------|----------|\n| NAS QNAP | Donde correrÃ¡ el bot 24/7 |\n| Cuenta Kraken | Para hacer trading |\n| Cuenta Telegram | Para recibir notificaciones |\n| 30 minutos | Tiempo aproximado de instalaciÃ³n |\n\n---\n\n# PASO 1: PREPARAR TU NAS\n\n## 1.1 Instalar Container Station\n\n1. Abre la interfaz web de tu NAS: `http://TU_IP_NAS:8080`\n2. Inicia sesiÃ³n con tu usuario administrador\n3. Abre el **App Center** (icono de bolsa de compras)\n4. Busca: `Container Station`\n5. Haz clic en **Instalar**\n6. Espera 5-10 minutos a que termine\n\n## 1.2 Crear la carpeta del proyecto\n\n1. Abre **File Station** en tu NAS\n2. Navega a: `Container`\n3. Crea una nueva carpeta llamada: `krakenbot`\n4. Ruta final: `/share/Container/krakenbot/`\n\n---\n\n# PASO 2: DESCARGAR Y COPIAR EL PROYECTO\n\n## 2.1 Descargar el proyecto\n\n1. En Replit, haz clic en los **tres puntos (â‹®)** arriba del explorador de archivos\n2. Selecciona **\"Download as zip\"**\n3. Guarda el archivo ZIP en tu ordenador\n\n## 2.2 Copiar al NAS\n\n1. Descomprime el ZIP en tu ordenador\n2. Abre **File Station** en tu NAS\n3. Navega a: `/share/Container/krakenbot/`\n4. Arrastra y suelta TODOS los archivos dentro\n\n### Estructura final:\n```\n/share/Container/krakenbot/\nâ”œâ”€â”€ ğŸ“ client/\nâ”œâ”€â”€ ğŸ“ server/\nâ”œâ”€â”€ ğŸ“ shared/\nâ”œâ”€â”€ ğŸ“„ docker-compose.yml\nâ”œâ”€â”€ ğŸ“„ Dockerfile\nâ”œâ”€â”€ ğŸ“„ package.json\nâ””â”€â”€ ğŸ“„ ... (resto de archivos)\n```\n\n---\n\n# PASO 3: OBTENER API KEYS DE KRAKEN\n\n## 3.1 Crear cuenta en Kraken (si no tienes)\n\n1. Ve a: **https://www.kraken.com**\n2. Haz clic en **Crear cuenta**\n3. Completa el registro\n4. **Importante:** Verifica tu identidad (KYC)\n\n## 3.2 Generar las API Keys\n\n1. Inicia sesiÃ³n en Kraken\n2. Haz clic en tu nombre (arriba a la derecha)\n3. Ve a: **Seguridad** â†’ **API**\n4. Haz clic en **Crear clave API**\n\n## 3.3 Configurar permisos\n\nMarca SOLO estas opciones:\n- âœ… Query Funds\n- âœ… Query Open Orders & Trades\n- âœ… Query Closed Orders & Trades\n- âœ… Create & Modify Orders\n\n**âš ï¸ NUNCA marques:**\n- âŒ Withdraw Funds (Retirar fondos)\n\n## 3.4 Guardar las claves\n\nHaz clic en **Generar clave** y copia:\n\n| Dato | Ejemplo | GuÃ¡rdalo en un lugar seguro |\n|------|---------|----------------------------|\n| API Key | `xAbCdEfGhIjK...` | âœ… |\n| Private Key (Secret) | `aBcDeFgHiJkL...` | âœ… |\n\n**âš ï¸ El Secret solo se muestra UNA VEZ. Si lo pierdes, crea una nueva API Key.**\n\n---\n\n# PASO 4: CREAR BOT DE TELEGRAM\n\n## 4.1 Crear el Bot\n\n1. Abre **Telegram** en tu mÃ³vil o PC\n2. Busca: `@BotFather`\n3. Escribe: `/newbot`\n4. Nombre del bot: `KrakenBot Alertas`\n5. Username: `MiKrakenBot_bot` (debe terminar en `bot`)\n6. **Copia el Token** que te da:\n   ```\n   7123456789:AAHdqTcvCH1vGWJxfSeofSAs0K5PALDsaw\n   ```\n\n## 4.2 Obtener tu Chat ID\n\n1. En Telegram, busca: `@userinfobot`\n2. EnvÃ­ale cualquier mensaje\n3. **Copia el nÃºmero de \"Id\"**: `123456789`\n\n## 4.3 Resumen de datos de Telegram\n\n| Dato | Ejemplo |\n|------|---------|\n| Bot Token | `7123456789:AAHdqTcvCH1vGWJxfSeofSAs0K5PALDsaw` |\n| Chat ID | `123456789` |\n\n---\n\n# PASO 5: CONFIGURAR LA CONTRASEÃ‘A\n\n## 5.1 Editar docker-compose.yml\n\n1. En File Station, navega a: `/share/Container/krakenbot/`\n2. Haz clic derecho en `docker-compose.yml`\n3. Selecciona **Abrir con editor de texto**\n4. Busca estas dos lÃ­neas:\n   ```yaml\n   POSTGRES_PASSWORD: TuPasswordSegura123!\n   ```\n   y\n   ```yaml\n   DATABASE_URL: postgres://krakenbot:TuPasswordSegura123!@postgres:5432/krakenbot\n   ```\n5. Cambia `TuPasswordSegura123!` por tu propia contraseÃ±a **en ambas lÃ­neas**\n6. Guarda el archivo\n\n---\n\n# PASO 6: INICIAR EL BOT\n\n## OpciÃ³n A: Desde Container Station (Recomendado)\n\n1. Abre **Container Station** en tu NAS\n2. Ve a **Aplicaciones** (o \"Applications\")\n3. Haz clic en **Crear** (o \"Create\")\n4. Nombre: `krakenbot`\n5. En \"Ruta YAML\" selecciona: `/share/Container/krakenbot/docker-compose.yml`\n6. Haz clic en **Crear**\n7. Espera 3-5 minutos mientras se instala todo\n\n## OpciÃ³n B: Desde terminal/SSH\n\n### En Windows:\n1. Abre **PowerShell**\n2. Escribe:\n   ```\n   ssh admin@192.168.1.XXX\n   ```\n   (cambia XXX por la IP de tu NAS)\n3. Introduce tu contraseÃ±a del NAS\n4. Ejecuta:\n   ```bash\n   cd /share/Container/krakenbot\n   docker-compose up -d\n   ```\n\n### En Mac/Linux:\n1. Abre **Terminal**\n2. Escribe:\n   ```bash\n   ssh admin@192.168.1.XXX\n   cd /share/Container/krakenbot\n   docker-compose up -d\n   ```\n\n## Ver el progreso de instalaciÃ³n:\n```bash\ndocker-compose logs -f app\n```\n\nVerÃ¡s algo como:\n```\nğŸš€ Instalando dependencias...\nğŸ”¨ Compilando aplicacion...\nğŸ“¦ Sincronizando base de datos...\nâœ… Iniciando KrakenBot...\n```\n\n---\n\n# PASO 7: CONFIGURAR EL BOT DESDE LA WEB\n\n## 7.1 Acceder al Panel de Control\n\n1. Abre tu navegador\n2. Ve a: `http://TU_IP_NAS:3000`\n   - Ejemplo: `http://192.168.1.100:3000`\n3. VerÃ¡s el dashboard del bot\n\n## 7.2 Ir a Ajustes\n\n1. En el menÃº superior, haz clic en **AJUSTES**\n\n## 7.3 Conectar Kraken\n\n1. En la secciÃ³n **\"API de Kraken\"**:\n   - **API Key:** Pega tu API Key de Kraken\n   - **API Secret:** Pega tu Private Key/Secret\n2. Haz clic en **Conectar a Kraken**\n3. Debe aparecer: âœ… **CONECTADO**\n\n## 7.4 Conectar Telegram\n\n1. En la secciÃ³n **\"Notificaciones Telegram\"**:\n   - **Bot Token:** Pega el token que te dio BotFather\n   - **Chat ID:** Pega tu nÃºmero de ID\n2. Haz clic en **Probar ConexiÃ³n**\n3. **Revisa Telegram** - deberÃ­as recibir un mensaje de prueba\n\n---\n\n# PASO 8: ACTIVAR EL BOT\n\n1. Haz clic en **PANEL** en el menÃº superior\n2. En **\"CONTROL DEL SISTEMA\"**:\n   - Elige una **Estrategia** (empieza con MOMENTUM_ALPHA_V2)\n   - Elige **Nivel de Riesgo** (empieza con BAJO)\n3. Haz clic en el botÃ³n **INICIAR**\n4. El indicador cambiarÃ¡ a ğŸŸ¢ **EN LÃNEA**\n5. RecibirÃ¡s una notificaciÃ³n en Telegram\n\n---\n\n# âœ… Â¡LISTO!\n\nTu bot de trading estÃ¡ funcionando en tu NAS 24/7.\n\n---\n\n# ğŸ“– COMANDOS ÃšTILES\n\nConecta por SSH a tu NAS y usa estos comandos:\n\n| AcciÃ³n | Comando |\n|--------|---------|\n| Ver logs en tiempo real | `docker-compose logs -f app` |\n| Reiniciar el bot | `docker-compose restart app` |\n| Parar el bot | `docker-compose down` |\n| Iniciar el bot | `docker-compose up -d` |\n| Ver estado | `docker-compose ps` |\n\n---\n\n# â“ SOLUCIÃ“N DE PROBLEMAS\n\n## \"No puedo acceder a http://IP:3000\"\n- Verifica que la IP es correcta\n- Espera 5 minutos (la primera instalaciÃ³n tarda)\n- Revisa los logs: `docker-compose logs -f app`\n\n## \"Error al conectar con Kraken\"\n- Revisa que copiaste bien la API Key y el Secret\n- Verifica que la API Key tiene los permisos correctos\n- AsegÃºrate que tu cuenta Kraken estÃ¡ verificada\n\n## \"No recibo notificaciones en Telegram\"\n- EnvÃ­a un mensaje a tu bot primero (cualquier cosa)\n- Verifica que el Chat ID es correcto\n- Comprueba que el Token es correcto\n\n## \"El contenedor no arranca\"\n- Revisa los logs: `docker-compose logs app`\n- Verifica que la contraseÃ±a es igual en las dos lÃ­neas del docker-compose.yml\n- AsegÃºrate que hay espacio en disco\n\n---\n\n# ğŸ”’ SEGURIDAD\n\n1. **NUNCA** compartas tus API Keys\n2. **NUNCA** actives permisos de retiro en Kraken\n3. Usa contraseÃ±as seguras\n4. El bot solo tiene acceso a tu red local\n5. Empieza con cantidades pequeÃ±as\n\n---\n\n# ğŸ“Š RESUMEN DE DATOS\n\nGuarda esta tabla en un lugar seguro:\n\n| Dato | Valor | DÃ³nde se usa |\n|------|-------|--------------|\n| IP del NAS | `192.168.1.___` | Acceder al panel |\n| URL del Panel | `http://IP:3000` | Navegador |\n| Kraken API Key | `____________` | Ajustes â†’ Kraken |\n| Kraken Secret | `____________` | Ajustes â†’ Kraken |\n| Telegram Token | `____________` | Ajustes â†’ Telegram |\n| Telegram Chat ID | `____________` | Ajustes â†’ Telegram |\n| Password BD | `____________` | docker-compose.yml |\n\n---\n\n# âš ï¸ ADVERTENCIA LEGAL\n\n- Este bot opera con **dinero real**\n- Los mercados de criptomonedas son **muy volÃ¡tiles**\n- **Nunca inviertas** mÃ¡s de lo que puedas perder\n- El bot es una herramienta, **no garantiza ganancias**\n- TÃº eres el Ãºnico responsable de tus operaciones\n\n---\n\n**Â¡Buena suerte con tu trading!** ğŸš€\n","path":null,"size_bytes":8243,"size_tokens":null},"vite.config.ts":{"content":"import { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport tailwindcss from \"@tailwindcss/vite\";\nimport path from \"path\";\nimport runtimeErrorOverlay from \"@replit/vite-plugin-runtime-error-modal\";\nimport { metaImagesPlugin } from \"./vite-plugin-meta-images\";\n\nexport default defineConfig({\n  plugins: [\n    react(),\n    runtimeErrorOverlay(),\n    tailwindcss(),\n    metaImagesPlugin(),\n    ...(process.env.NODE_ENV !== \"production\" &&\n    process.env.REPL_ID !== undefined\n      ? [\n          await import(\"@replit/vite-plugin-cartographer\").then((m) =>\n            m.cartographer(),\n          ),\n          await import(\"@replit/vite-plugin-dev-banner\").then((m) =>\n            m.devBanner(),\n          ),\n        ]\n      : []),\n  ],\n  resolve: {\n    alias: {\n      \"@\": path.resolve(import.meta.dirname, \"client\", \"src\"),\n      \"@shared\": path.resolve(import.meta.dirname, \"shared\"),\n      \"@assets\": path.resolve(import.meta.dirname, \"attached_assets\"),\n    },\n  },\n  css: {\n    postcss: {\n      plugins: [],\n    },\n  },\n  root: path.resolve(import.meta.dirname, \"client\"),\n  build: {\n    outDir: path.resolve(import.meta.dirname, \"dist/public\"),\n    emptyOutDir: true,\n  },\n  server: {\n    host: \"0.0.0.0\",\n    allowedHosts: true,\n    fs: {\n      strict: true,\n      deny: [\"**/.*\"],\n    },\n  },\n});\n","path":null,"size_bytes":1330,"size_tokens":null},"client/src/index.css":{"content":"@import \"tailwindcss\";\n@import \"tw-animate-css\";\n\n@custom-variant dark (&:is(.dark *));\n\n@theme inline {\n  --radius-sm: 2px;\n  --radius-md: 4px;\n  --radius-lg: 6px;\n  --radius-xl: 8px;\n\n  /* Dark Future Palette */\n  --color-background: hsl(222 47% 6%); /* Deep almost black blue */\n  --color-foreground: hsl(210 40% 98%);\n\n  --color-card: hsl(222 47% 10%);\n  --color-card-foreground: hsl(210 40% 98%);\n\n  --color-popover: hsl(222 47% 10%);\n  --color-popover-foreground: hsl(210 40% 98%);\n\n  --color-primary: hsl(180 100% 50%); /* Cyan Neon */\n  --color-primary-foreground: hsl(222 47% 11%);\n\n  --color-secondary: hsl(217 33% 17%);\n  --color-secondary-foreground: hsl(210 40% 98%);\n\n  --color-muted: hsl(217 33% 17%);\n  --color-muted-foreground: hsl(215 20% 65%);\n\n  --color-accent: hsl(180 100% 50%);\n  --color-accent-foreground: hsl(222 47% 11%);\n\n  --color-destructive: hsl(0 84% 60%); /* Red Neon */\n  --color-destructive-foreground: hsl(210 40% 98%);\n\n  --color-border: hsl(217 33% 20%);\n  --color-input: hsl(217 33% 20%);\n  --color-ring: hsl(180 100% 50%);\n\n  --color-chart-1: hsl(180 100% 50%); /* Cyan */\n  --color-chart-2: hsl(280 100% 70%); /* Purple */\n  --color-chart-3: hsl(120 100% 50%); /* Green */\n  --color-chart-4: hsl(60 100% 50%);  /* Yellow */\n  --color-chart-5: hsl(0 100% 65%);   /* Red */\n\n  --color-sidebar: hsl(222 47% 8%);\n  --color-sidebar-foreground: hsl(210 40% 98%);\n  --color-sidebar-primary: hsl(180 100% 50%);\n  --color-sidebar-primary-foreground: hsl(222 47% 11%);\n  --color-sidebar-accent: hsl(217 33% 15%);\n  --color-sidebar-accent-foreground: hsl(210 40% 98%);\n  --color-sidebar-border: hsl(217 33% 20%);\n  --color-sidebar-ring: hsl(180 100% 50%);\n\n  --font-sans: 'Space Grotesk', sans-serif;\n  --font-mono: 'JetBrains Mono', monospace;\n  \n  --radius: 0.25rem;\n\n  --animate-infinite-scroll: infinite-scroll 25s linear infinite;\n\n  @keyframes infinite-scroll {\n    from { transform: translateX(0); }\n    to { transform: translateX(-100%); }\n  }\n\n  @keyframes ticker-scroll {\n    from { transform: translateX(0); }\n    to { transform: translateX(-50%); }\n  }\n}\n\n@layer base {\n  * {\n    @apply border-border;\n  }\n  body {\n    @apply font-sans antialiased bg-background text-foreground;\n    background-image: \n      radial-gradient(circle at 50% 0%, hsl(222 47% 15% / 0.5), transparent 70%),\n      linear-gradient(to bottom, transparent, hsl(222 47% 6%));\n  }\n}\n\n/* Custom Scrollbar for that terminal feel */\n::-webkit-scrollbar {\n  width: 8px;\n  height: 8px;\n}\n::-webkit-scrollbar-track {\n  background: hsl(222 47% 8%);\n}\n::-webkit-scrollbar-thumb {\n  background: hsl(217 33% 30%);\n  border-radius: 4px;\n}\n::-webkit-scrollbar-thumb:hover {\n  background: hsl(180 100% 50% / 0.5);\n}\n\n.glow-text {\n  text-shadow: 0 0 10px hsl(180 100% 50% / 0.5);\n}\n\n.glass-panel {\n  background: hsl(222 47% 10% / 0.7);\n  backdrop-filter: blur(12px);\n  border: 1px solid hsl(217 33% 25%);\n}\n\n.animate-ticker {\n  animation: ticker-scroll 60s linear infinite;\n}\n","path":null,"size_bytes":2974,"size_tokens":null},"client/src/components/ui/field.tsx":{"content":"\"use client\"\n\nimport { useMemo } from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Label } from \"@/components/ui/label\"\nimport { Separator } from \"@/components/ui/separator\"\n\nfunction FieldSet({ className, ...props }: React.ComponentProps<\"fieldset\">) {\n  return (\n    <fieldset\n      data-slot=\"field-set\"\n      className={cn(\n        \"flex flex-col gap-6\",\n        \"has-[>[data-slot=checkbox-group]]:gap-3 has-[>[data-slot=radio-group]]:gap-3\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction FieldLegend({\n  className,\n  variant = \"legend\",\n  ...props\n}: React.ComponentProps<\"legend\"> & { variant?: \"legend\" | \"label\" }) {\n  return (\n    <legend\n      data-slot=\"field-legend\"\n      data-variant={variant}\n      className={cn(\n        \"mb-3 font-medium\",\n        \"data-[variant=legend]:text-base\",\n        \"data-[variant=label]:text-sm\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction FieldGroup({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"field-group\"\n      className={cn(\n        \"group/field-group @container/field-group flex w-full flex-col gap-7 data-[slot=checkbox-group]:gap-3 [&>[data-slot=field-group]]:gap-4\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nconst fieldVariants = cva(\n  \"group/field data-[invalid=true]:text-destructive flex w-full gap-3\",\n  {\n    variants: {\n      orientation: {\n        vertical: [\"flex-col [&>*]:w-full [&>.sr-only]:w-auto\"],\n        horizontal: [\n          \"flex-row items-center\",\n          \"[&>[data-slot=field-label]]:flex-auto\",\n          \"has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px has-[>[data-slot=field-content]]:items-start\",\n        ],\n        responsive: [\n          \"@md/field-group:flex-row @md/field-group:items-center @md/field-group:[&>*]:w-auto flex-col [&>*]:w-full [&>.sr-only]:w-auto\",\n          \"@md/field-group:[&>[data-slot=field-label]]:flex-auto\",\n          \"@md/field-group:has-[>[data-slot=field-content]]:items-start @md/field-group:has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px\",\n        ],\n      },\n    },\n    defaultVariants: {\n      orientation: \"vertical\",\n    },\n  }\n)\n\nfunction Field({\n  className,\n  orientation = \"vertical\",\n  ...props\n}: React.ComponentProps<\"div\"> & VariantProps<typeof fieldVariants>) {\n  return (\n    <div\n      role=\"group\"\n      data-slot=\"field\"\n      data-orientation={orientation}\n      className={cn(fieldVariants({ orientation }), className)}\n      {...props}\n    />\n  )\n}\n\nfunction FieldContent({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"field-content\"\n      className={cn(\n        \"group/field-content flex flex-1 flex-col gap-1.5 leading-snug\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction FieldLabel({\n  className,\n  ...props\n}: React.ComponentProps<typeof Label>) {\n  return (\n    <Label\n      data-slot=\"field-label\"\n      className={cn(\n        \"group/field-label peer/field-label flex w-fit gap-2 leading-snug group-data-[disabled=true]/field:opacity-50\",\n        \"has-[>[data-slot=field]]:w-full has-[>[data-slot=field]]:flex-col has-[>[data-slot=field]]:rounded-md has-[>[data-slot=field]]:border [&>[data-slot=field]]:p-4\",\n        \"has-data-[state=checked]:bg-primary/5 has-data-[state=checked]:border-primary dark:has-data-[state=checked]:bg-primary/10\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction FieldTitle({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"field-label\"\n      className={cn(\n        \"flex w-fit items-center gap-2 text-sm font-medium leading-snug group-data-[disabled=true]/field:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction FieldDescription({ className, ...props }: React.ComponentProps<\"p\">) {\n  return (\n    <p\n      data-slot=\"field-description\"\n      className={cn(\n        \"text-muted-foreground text-sm font-normal leading-normal group-has-[[data-orientation=horizontal]]/field:text-balance\",\n        \"nth-last-2:-mt-1 last:mt-0 [[data-variant=legend]+&]:-mt-1.5\",\n        \"[&>a:hover]:text-primary [&>a]:underline [&>a]:underline-offset-4\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction FieldSeparator({\n  children,\n  className,\n  ...props\n}: React.ComponentProps<\"div\"> & {\n  children?: React.ReactNode\n}) {\n  return (\n    <div\n      data-slot=\"field-separator\"\n      data-content={!!children}\n      className={cn(\n        \"relative -my-2 h-5 text-sm group-data-[variant=outline]/field-group:-mb-2\",\n        className\n      )}\n      {...props}\n    >\n      <Separator className=\"absolute inset-0 top-1/2\" />\n      {children && (\n        <span\n          className=\"bg-background text-muted-foreground relative mx-auto block w-fit px-2\"\n          data-slot=\"field-separator-content\"\n        >\n          {children}\n        </span>\n      )}\n    </div>\n  )\n}\n\nfunction FieldError({\n  className,\n  children,\n  errors,\n  ...props\n}: React.ComponentProps<\"div\"> & {\n  errors?: Array<{ message?: string } | undefined>\n}) {\n  const content = useMemo(() => {\n    if (children) {\n      return children\n    }\n\n    if (!errors) {\n      return null\n    }\n\n    if (errors?.length === 1 && errors[0]?.message) {\n      return errors[0].message\n    }\n\n    return (\n      <ul className=\"ml-4 flex list-disc flex-col gap-1\">\n        {errors.map(\n          (error, index) =>\n            error?.message && <li key={index}>{error.message}</li>\n        )}\n      </ul>\n    )\n  }, [children, errors])\n\n  if (!content) {\n    return null\n  }\n\n  return (\n    <div\n      role=\"alert\"\n      data-slot=\"field-error\"\n      className={cn(\"text-destructive text-sm font-normal\", className)}\n      {...props}\n    >\n      {content}\n    </div>\n  )\n}\n\nexport {\n  Field,\n  FieldLabel,\n  FieldDescription,\n  FieldError,\n  FieldGroup,\n  FieldLegend,\n  FieldSeparator,\n  FieldSet,\n  FieldContent,\n  FieldTitle,\n}\n","path":null,"size_bytes":6044,"size_tokens":null},"client/src/hooks/use-mobile.tsx":{"content":"import * as React from \"react\"\n\nconst MOBILE_BREAKPOINT = 768\n\nexport function useIsMobile() {\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)\n\n  React.useEffect(() => {\n    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)\n    const onChange = () => {\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    }\n    mql.addEventListener(\"change\", onChange)\n    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    return () => mql.removeEventListener(\"change\", onChange)\n  }, [])\n\n  return !!isMobile\n}\n","path":null,"size_bytes":565,"size_tokens":null},"client/src/lib/queryClient.ts":{"content":"import { QueryClient, QueryFunction } from \"@tanstack/react-query\";\n\nasync function throwIfResNotOk(res: Response) {\n  if (!res.ok) {\n    const text = (await res.text()) || res.statusText;\n    throw new Error(`${res.status}: ${text}`);\n  }\n}\n\nexport async function apiRequest(\n  method: string,\n  url: string,\n  data?: unknown | undefined,\n): Promise<Response> {\n  const res = await fetch(url, {\n    method,\n    headers: data ? { \"Content-Type\": \"application/json\" } : {},\n    body: data ? JSON.stringify(data) : undefined,\n    credentials: \"include\",\n  });\n\n  await throwIfResNotOk(res);\n  return res;\n}\n\ntype UnauthorizedBehavior = \"returnNull\" | \"throw\";\nexport const getQueryFn: <T>(options: {\n  on401: UnauthorizedBehavior;\n}) => QueryFunction<T> =\n  ({ on401: unauthorizedBehavior }) =>\n  async ({ queryKey }) => {\n    const res = await fetch(queryKey.join(\"/\") as string, {\n      credentials: \"include\",\n    });\n\n    if (unauthorizedBehavior === \"returnNull\" && res.status === 401) {\n      return null;\n    }\n\n    await throwIfResNotOk(res);\n    return await res.json();\n  };\n\nexport const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      queryFn: getQueryFn({ on401: \"throw\" }),\n      refetchInterval: false,\n      refetchOnWindowFocus: false,\n      staleTime: Infinity,\n      retry: false,\n    },\n    mutations: {\n      retry: false,\n    },\n  },\n});\n","path":null,"size_bytes":1383,"size_tokens":null},"scripts/update-nas.sh":{"content":"#!/bin/bash\n\n# Script de actualizaciÃ³n para KrakenBot en QNAP NAS\n# Uso: ./update-nas.sh\n\nset -e\n\n# ConfiguraciÃ³n - Ajusta segÃºn tu entorno\nNAS_PATH=\"/share/ZFS37_DATA/share/Container/krakenbot\"\nCONTAINER_NAME=\"krakenbot\"\nBACKUP_DIR=\"/share/ZFS37_DATA/share/Container/krakenbot_backups\"\n\necho \"================================================\"\necho \"  KRAKENBOT - Script de ActualizaciÃ³n para NAS\"\necho \"================================================\"\necho \"\"\n\n# Crear directorio de backups si no existe\nmkdir -p \"$BACKUP_DIR\"\n\n# Backup de la versiÃ³n actual\nBACKUP_NAME=\"krakenbot_backup_$(date +%Y%m%d_%H%M%S)\"\necho \"[1/5] Creando backup de la versiÃ³n actual...\"\nif [ -d \"$NAS_PATH\" ]; then\n    cp -r \"$NAS_PATH\" \"$BACKUP_DIR/$BACKUP_NAME\"\n    echo \"      Backup guardado en: $BACKUP_DIR/$BACKUP_NAME\"\nelse\n    echo \"      No se encontrÃ³ instalaciÃ³n previa, saltando backup...\"\nfi\n\n# Detener el contenedor actual\necho \"\"\necho \"[2/5] Deteniendo contenedor actual...\"\ndocker stop \"$CONTAINER_NAME\" 2>/dev/null || echo \"      Contenedor no estaba corriendo\"\n\n# Actualizar archivos (asume que los nuevos archivos estÃ¡n en el directorio actual)\necho \"\"\necho \"[3/5] Actualizando archivos...\"\n# Preservar el .env y la base de datos\nif [ -f \"$NAS_PATH/.env\" ]; then\n    cp \"$NAS_PATH/.env\" /tmp/krakenbot_env_backup\nfi\n\n# Copiar nuevos archivos (ajusta la ruta origen segÃºn necesites)\n# rsync -av --exclude='.env' --exclude='node_modules' --exclude='.git' ./ \"$NAS_PATH/\"\n\necho \"      Archivos actualizados\"\n\n# Restaurar .env\nif [ -f \"/tmp/krakenbot_env_backup\" ]; then\n    cp /tmp/krakenbot_env_backup \"$NAS_PATH/.env\"\n    echo \"      Archivo .env restaurado\"\nfi\n\n# Reconstruir imagen Docker\necho \"\"\necho \"[4/5] Reconstruyendo imagen Docker...\"\ncd \"$NAS_PATH\"\ndocker-compose build --no-cache\n\n# Reiniciar contenedor\necho \"\"\necho \"[5/5] Iniciando contenedor actualizado...\"\ndocker-compose up -d\n\necho \"\"\necho \"================================================\"\necho \"  Â¡ActualizaciÃ³n completada!\"\necho \"================================================\"\necho \"\"\necho \"  El bot estÃ¡ disponible en: http://192.168.1.104:3000\"\necho \"\"\necho \"  Para ver los logs:\"\necho \"    docker logs -f $CONTAINER_NAME\"\necho \"\"\necho \"  En caso de problemas, restaurar backup:\"\necho \"    docker-compose down\"\necho \"    rm -rf $NAS_PATH/*\"\necho \"    cp -r $BACKUP_DIR/$BACKUP_NAME/* $NAS_PATH/\"\necho \"    docker-compose up -d\"\necho \"\"\n","path":null,"size_bytes":2421,"size_tokens":null},"client/src/pages/Wallet.tsx":{"content":"import { useQuery } from \"@tanstack/react-query\";\nimport { Nav } from \"@/components/dashboard/Nav\";\nimport { Ticker } from \"@/components/dashboard/Ticker\";\nimport generatedImage from '@assets/generated_images/dark_digital_hex_grid_background.png';\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Progress } from \"@/components/ui/progress\";\nimport { Wallet as WalletIcon, TrendingUp, TrendingDown, PieChart, RefreshCw } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\n\ninterface DashboardData {\n  krakenConnected: boolean;\n  balances: Record<string, string>;\n  prices: Record<string, { price: string; change: string }>;\n}\n\nconst ASSET_INFO: Record<string, { name: string; color: string }> = {\n  \"XXBT\": { name: \"Bitcoin\", color: \"bg-orange-500\" },\n  \"XETH\": { name: \"Ethereum\", color: \"bg-blue-500\" },\n  \"SOL\": { name: \"Solana\", color: \"bg-purple-500\" },\n  \"ZUSD\": { name: \"USD\", color: \"bg-green-500\" },\n  \"XXRP\": { name: \"XRP\", color: \"bg-gray-500\" },\n  \"TON\": { name: \"Toncoin\", color: \"bg-cyan-500\" },\n  \"USDC\": { name: \"USD Coin\", color: \"bg-blue-400\" },\n};\n\nconst PRICE_PAIRS: Record<string, string> = {\n  \"XXBT\": \"XXBTZUSD\",\n  \"XETH\": \"XETHZUSD\",\n  \"SOL\": \"SOLUSD\",\n  \"XXRP\": \"XXRPZUSD\",\n  \"TON\": \"TONUSD\",\n};\n\nexport default function Wallet() {\n  const { data, isLoading, refetch, isFetching } = useQuery<DashboardData>({\n    queryKey: [\"dashboard\"],\n    queryFn: async () => {\n      const res = await fetch(\"/api/dashboard\");\n      if (!res.ok) throw new Error(\"Failed to fetch dashboard\");\n      return res.json();\n    },\n    refetchInterval: 30000,\n  });\n\n  const calculatePortfolio = () => {\n    if (!data?.balances || !data?.prices) return { assets: [], total: 0 };\n\n    const assets: { symbol: string; name: string; balance: number; value: number; color: string; change: number }[] = [];\n    let total = 0;\n\n    for (const [symbol, balanceStr] of Object.entries(data.balances)) {\n      const balance = parseFloat(balanceStr);\n      if (balance <= 0) continue;\n\n      let value = balance;\n      let change = 0;\n\n      if (symbol === \"ZUSD\" || symbol === \"USDC\") {\n        value = balance;\n      } else {\n        const pricePair = PRICE_PAIRS[symbol];\n        if (pricePair && data.prices[pricePair]) {\n          const price = parseFloat(data.prices[pricePair].price);\n          value = balance * price;\n          change = parseFloat(data.prices[pricePair].change);\n        }\n      }\n\n      if (value > 0.001) {\n        assets.push({\n          symbol,\n          name: ASSET_INFO[symbol]?.name || symbol,\n          balance,\n          value,\n          color: ASSET_INFO[symbol]?.color || \"bg-gray-500\",\n          change,\n        });\n        total += value;\n      }\n    }\n\n    return { assets: assets.sort((a, b) => b.value - a.value), total };\n  };\n\n  const { assets, total } = calculatePortfolio();\n\n  return (\n    <div className=\"min-h-screen bg-background flex flex-col relative overflow-hidden\">\n      <div \n        className=\"fixed inset-0 z-0 opacity-20 pointer-events-none\" \n        style={{ \n          backgroundImage: `url(${generatedImage})`, \n          backgroundSize: 'cover',\n          backgroundPosition: 'center',\n          mixBlendMode: 'overlay'\n        }} \n      />\n      \n      <div className=\"relative z-10 flex flex-col min-h-screen\">\n        <Nav />\n        <Ticker />\n        \n        <main className=\"flex-1 p-6 max-w-6xl mx-auto w-full space-y-6\">\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <h1 className=\"text-3xl font-bold font-sans tracking-tight\">Mi Cartera</h1>\n              <p className=\"text-muted-foreground mt-1\">Desglose completo de tus activos en Kraken.</p>\n            </div>\n            <Button \n              variant=\"outline\" \n              onClick={() => refetch()}\n              disabled={isFetching}\n              data-testid=\"button-refresh-wallet\"\n            >\n              <RefreshCw className={`h-4 w-4 mr-2 ${isFetching ? 'animate-spin' : ''}`} />\n              Actualizar\n            </Button>\n          </div>\n\n          <div className=\"grid grid-cols-1 md:grid-cols-3 gap-6\">\n            <Card className=\"glass-panel border-border/50 md:col-span-2\">\n              <CardHeader>\n                <CardTitle className=\"flex items-center gap-2\">\n                  <WalletIcon className=\"h-5 w-5 text-primary\" />\n                  Balance Total\n                </CardTitle>\n              </CardHeader>\n              <CardContent>\n                <div className=\"text-4xl font-bold font-mono tracking-tight text-primary\">\n                  ${total.toLocaleString(\"en-US\", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}\n                </div>\n                <p className=\"text-sm text-muted-foreground mt-2\">\n                  {assets.length} activos en tu cartera\n                </p>\n              </CardContent>\n            </Card>\n\n            <Card className=\"glass-panel border-border/50\">\n              <CardHeader>\n                <CardTitle className=\"flex items-center gap-2\">\n                  <PieChart className=\"h-5 w-5 text-primary\" />\n                  DistribuciÃ³n\n                </CardTitle>\n              </CardHeader>\n              <CardContent>\n                <div className=\"space-y-3\">\n                  {assets.slice(0, 4).map((asset) => {\n                    const percentage = total > 0 ? (asset.value / total) * 100 : 0;\n                    return (\n                      <div key={asset.symbol} className=\"space-y-1\">\n                        <div className=\"flex justify-between text-sm\">\n                          <span className=\"font-mono\">{asset.name}</span>\n                          <span className=\"text-muted-foreground\">{percentage.toFixed(1)}%</span>\n                        </div>\n                        <Progress value={percentage} className=\"h-2\" />\n                      </div>\n                    );\n                  })}\n                </div>\n              </CardContent>\n            </Card>\n          </div>\n\n          <Card className=\"glass-panel border-border/50\">\n            <CardHeader>\n              <CardTitle>Detalle de Activos</CardTitle>\n            </CardHeader>\n            <CardContent>\n              {isLoading ? (\n                <div className=\"flex items-center justify-center py-12\">\n                  <RefreshCw className=\"h-8 w-8 animate-spin text-primary\" />\n                </div>\n              ) : !data?.krakenConnected ? (\n                <div className=\"text-center py-12 text-muted-foreground\">\n                  <WalletIcon className=\"h-12 w-12 mx-auto mb-4 opacity-50\" />\n                  <p>Conecta Kraken en Ajustes para ver tu cartera.</p>\n                </div>\n              ) : assets.length === 0 ? (\n                <div className=\"text-center py-12 text-muted-foreground\">\n                  <WalletIcon className=\"h-12 w-12 mx-auto mb-4 opacity-50\" />\n                  <p>No tienes activos en tu cuenta de Kraken.</p>\n                </div>\n              ) : (\n                <div className=\"space-y-4\">\n                  {assets.map((asset) => {\n                    const percentage = total > 0 ? (asset.value / total) * 100 : 0;\n                    return (\n                      <div\n                        key={asset.symbol}\n                        className=\"flex items-center justify-between p-4 bg-card/50 rounded-lg border border-border/30 hover:border-border/50 transition-colors\"\n                        data-testid={`asset-row-${asset.symbol}`}\n                      >\n                        <div className=\"flex items-center gap-4\">\n                          <div className={`w-10 h-10 rounded-full ${asset.color} flex items-center justify-center text-white font-bold text-sm`}>\n                            {asset.symbol.substring(0, 2)}\n                          </div>\n                          <div>\n                            <div className=\"font-medium\">{asset.name}</div>\n                            <div className=\"text-sm text-muted-foreground font-mono\">\n                              {asset.balance.toFixed(8)} {asset.symbol}\n                            </div>\n                          </div>\n                        </div>\n                        \n                        <div className=\"flex items-center gap-6\">\n                          <div className=\"text-right\">\n                            <div className=\"font-mono font-medium\">\n                              ${asset.value.toLocaleString(\"en-US\", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}\n                            </div>\n                            <div className=\"text-sm text-muted-foreground\">\n                              {percentage.toFixed(1)}% del total\n                            </div>\n                          </div>\n                          {asset.change !== 0 && (\n                            <div className={`flex items-center gap-1 ${asset.change >= 0 ? \"text-green-500\" : \"text-red-500\"}`}>\n                              {asset.change >= 0 ? (\n                                <TrendingUp className=\"h-4 w-4\" />\n                              ) : (\n                                <TrendingDown className=\"h-4 w-4\" />\n                              )}\n                              <span className=\"font-mono text-sm\">\n                                {asset.change >= 0 ? \"+\" : \"\"}{asset.change.toFixed(2)}%\n                              </span>\n                            </div>\n                          )}\n                        </div>\n                      </div>\n                    );\n                  })}\n                </div>\n              )}\n            </CardContent>\n          </Card>\n        </main>\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":9739,"size_tokens":null},"client/src/pages/Strategies.tsx":{"content":"import { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { Nav } from \"@/components/dashboard/Nav\";\nimport { Ticker } from \"@/components/dashboard/Ticker\";\nimport generatedImage from '@assets/generated_images/dark_digital_hex_grid_background.png';\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription } from \"@/components/ui/card\";\nimport { Label } from \"@/components/ui/label\";\nimport { Switch } from \"@/components/ui/switch\";\nimport { Button } from \"@/components/ui/button\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Slider } from \"@/components/ui/slider\";\nimport { Activity, TrendingUp, TrendingDown, Zap, Shield, Target, RefreshCw, AlertTriangle, CircleDollarSign, PieChart, Wallet, Clock, CandlestickChart } from \"lucide-react\";\nimport { toast } from \"sonner\";\n\ninterface BotConfig {\n  id: number;\n  isActive: boolean;\n  strategy: string;\n  signalTimeframe: string;\n  riskLevel: string;\n  activePairs: string[];\n  stopLossPercent: string;\n  takeProfitPercent: string;\n  trailingStopEnabled: boolean;\n  trailingStopPercent: string;\n  maxPairExposurePct: string;\n  maxTotalExposurePct: string;\n  exposureBase: string;\n  riskPerTradePct: string;\n}\n\nconst STRATEGIES = [\n  { id: \"momentum\", name: \"Momentum\", description: \"Sigue tendencias fuertes del mercado\", icon: TrendingUp },\n  { id: \"mean_reversion\", name: \"ReversiÃ³n a la Media\", description: \"Opera cuando el precio se aleja de promedios\", icon: RefreshCw },\n  { id: \"scalping\", name: \"Scalping\", description: \"Operaciones rÃ¡pidas con pequeÃ±as ganancias\", icon: Zap },\n  { id: \"grid\", name: \"Grid Trading\", description: \"Ã“rdenes escalonadas en rangos de precio\", icon: Target },\n];\n\nconst SIGNAL_TIMEFRAMES = [\n  { id: \"cycle\", name: \"Ciclos (30s)\", description: \"EvalÃºa cada ciclo del bot (~30 segundos)\" },\n  { id: \"5m\", name: \"Velas 5 min\", description: \"EvalÃºa solo al cierre de velas de 5 minutos\" },\n  { id: \"15m\", name: \"Velas 15 min\", description: \"EvalÃºa solo al cierre de velas de 15 minutos\" },\n  { id: \"1h\", name: \"Velas 1 hora\", description: \"EvalÃºa solo al cierre de velas de 1 hora\" },\n];\n\nconst RISK_LEVELS = [\n  { id: \"low\", name: \"Bajo\", description: \"Posiciones pequeÃ±as, stops ajustados\", color: \"text-green-500\" },\n  { id: \"medium\", name: \"Medio\", description: \"Balance entre riesgo y rendimiento\", color: \"text-yellow-500\" },\n  { id: \"high\", name: \"Alto\", description: \"Posiciones grandes, mayor volatilidad\", color: \"text-red-500\" },\n];\n\nconst AVAILABLE_PAIRS = [\"BTC/USD\", \"ETH/USD\", \"SOL/USD\", \"ETH/BTC\", \"XRP/USD\", \"TON/USD\"];\n\nexport default function Strategies() {\n  const queryClient = useQueryClient();\n\n  const { data: config, isLoading } = useQuery<BotConfig>({\n    queryKey: [\"botConfig\"],\n    queryFn: async () => {\n      const res = await fetch(\"/api/config\");\n      if (!res.ok) throw new Error(\"Failed to fetch config\");\n      return res.json();\n    },\n  });\n\n  const updateMutation = useMutation({\n    mutationFn: async (updates: Partial<BotConfig>) => {\n      const res = await fetch(\"/api/config\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(updates),\n      });\n      if (!res.ok) throw new Error(\"Failed to update config\");\n      return res.json();\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: [\"botConfig\"] });\n      toast.success(\"ConfiguraciÃ³n actualizada\");\n    },\n    onError: () => {\n      toast.error(\"Error al actualizar configuraciÃ³n\");\n    },\n  });\n\n  const togglePair = (pair: string) => {\n    const currentPairs = config?.activePairs || [];\n    const newPairs = currentPairs.includes(pair)\n      ? currentPairs.filter(p => p !== pair)\n      : [...currentPairs, pair];\n    updateMutation.mutate({ activePairs: newPairs });\n  };\n\n  return (\n    <div className=\"min-h-screen bg-background flex flex-col relative overflow-hidden\">\n      <div \n        className=\"fixed inset-0 z-0 opacity-20 pointer-events-none\" \n        style={{ \n          backgroundImage: `url(${generatedImage})`, \n          backgroundSize: 'cover',\n          backgroundPosition: 'center',\n          mixBlendMode: 'overlay'\n        }} \n      />\n      \n      <div className=\"relative z-10 flex flex-col min-h-screen\">\n        <Nav />\n        <Ticker />\n        \n        <main className=\"flex-1 p-4 md:p-6 max-w-6xl mx-auto w-full space-y-4 md:space-y-6\">\n          <div className=\"flex flex-col sm:flex-row sm:items-center justify-between gap-4\">\n            <div>\n              <h1 className=\"text-2xl md:text-3xl font-bold font-sans tracking-tight\">Estrategias de Trading</h1>\n              <p className=\"text-sm md:text-base text-muted-foreground mt-1\">Configura el comportamiento del bot autÃ³nomo.</p>\n            </div>\n            <div className=\"flex items-center gap-3 md:gap-4\">\n              <span className=\"text-xs md:text-sm text-muted-foreground\">Bot Activo</span>\n              <Switch\n                checked={config?.isActive || false}\n                onCheckedChange={(checked) => updateMutation.mutate({ isActive: checked })}\n                data-testid=\"switch-bot-active\"\n              />\n            </div>\n          </div>\n\n          <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-4 md:gap-6\">\n            <Card className=\"glass-panel border-border/50\">\n              <CardHeader>\n                <CardTitle className=\"flex items-center gap-2 text-base md:text-lg\">\n                  <Activity className=\"h-4 w-4 md:h-5 md:w-5 text-primary\" />\n                  Estrategia Activa\n                </CardTitle>\n                <CardDescription>Selecciona el algoritmo de trading</CardDescription>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                {STRATEGIES.map((strategy) => (\n                  <div\n                    key={strategy.id}\n                    onClick={() => updateMutation.mutate({ strategy: strategy.id })}\n                    className={`p-4 rounded-lg border cursor-pointer transition-all ${\n                      config?.strategy === strategy.id\n                        ? \"border-primary bg-primary/10\"\n                        : \"border-border/50 hover:border-border\"\n                    }`}\n                    data-testid={`strategy-${strategy.id}`}\n                  >\n                    <div className=\"flex items-center gap-3\">\n                      <div className={`p-2 rounded-lg ${config?.strategy === strategy.id ? \"bg-primary/20\" : \"bg-muted\"}`}>\n                        <strategy.icon className={`h-5 w-5 ${config?.strategy === strategy.id ? \"text-primary\" : \"text-muted-foreground\"}`} />\n                      </div>\n                      <div className=\"flex-1\">\n                        <div className=\"font-medium\">{strategy.name}</div>\n                        <div className=\"text-sm text-muted-foreground\">{strategy.description}</div>\n                      </div>\n                      {config?.strategy === strategy.id && (\n                        <Badge variant=\"default\" className=\"font-mono\">ACTIVO</Badge>\n                      )}\n                    </div>\n                  </div>\n                ))}\n              </CardContent>\n            </Card>\n\n            {config?.strategy === \"momentum\" && (\n              <Card className=\"glass-panel border-border/50 border-cyan-500/30\">\n                <CardHeader>\n                  <CardTitle className=\"flex items-center gap-2 text-base md:text-lg\">\n                    <CandlestickChart className=\"h-4 w-4 md:h-5 md:w-5 text-cyan-500\" />\n                    Modo de SeÃ±al (Momentum)\n                  </CardTitle>\n                  <CardDescription>Define cuÃ¡ndo el bot evalÃºa seÃ±ales de trading</CardDescription>\n                </CardHeader>\n                <CardContent className=\"space-y-3\">\n                  {SIGNAL_TIMEFRAMES.map((tf) => (\n                    <div\n                      key={tf.id}\n                      onClick={() => updateMutation.mutate({ signalTimeframe: tf.id } as any)}\n                      className={`p-3 rounded-lg border cursor-pointer transition-all ${\n                        config?.signalTimeframe === tf.id\n                          ? \"border-cyan-500 bg-cyan-500/10\"\n                          : \"border-border/50 hover:border-border\"\n                      }`}\n                      data-testid={`timeframe-${tf.id}`}\n                    >\n                      <div className=\"flex items-center gap-3\">\n                        <div className={`p-2 rounded-lg ${config?.signalTimeframe === tf.id ? \"bg-cyan-500/20\" : \"bg-muted\"}`}>\n                          {tf.id === \"cycle\" ? (\n                            <Clock className={`h-4 w-4 ${config?.signalTimeframe === tf.id ? \"text-cyan-500\" : \"text-muted-foreground\"}`} />\n                          ) : (\n                            <CandlestickChart className={`h-4 w-4 ${config?.signalTimeframe === tf.id ? \"text-cyan-500\" : \"text-muted-foreground\"}`} />\n                          )}\n                        </div>\n                        <div className=\"flex-1\">\n                          <div className=\"font-medium text-sm\">{tf.name}</div>\n                          <div className=\"text-xs text-muted-foreground\">{tf.description}</div>\n                        </div>\n                        {config?.signalTimeframe === tf.id && (\n                          <Badge variant=\"outline\" className=\"font-mono text-cyan-500 border-cyan-500/50\">ACTIVO</Badge>\n                        )}\n                      </div>\n                    </div>\n                  ))}\n                  <div className=\"bg-cyan-500/10 rounded-lg p-3 mt-3 border border-cyan-500/20\">\n                    <p className=\"text-xs text-muted-foreground\">\n                      <strong className=\"text-cyan-500\">Velas:</strong> Usa anÃ¡lisis OHLC (EMA, RSI, MACD, patrones de velas) y solo opera al cierre de cada vela.\n                      <br /><strong className=\"text-cyan-500\">Ciclos:</strong> EvalÃºa precios en tiempo real cada 30 segundos.\n                    </p>\n                  </div>\n                </CardContent>\n              </Card>\n            )}\n\n            <div className=\"space-y-6\">\n              <Card className=\"glass-panel border-border/50\">\n                <CardHeader>\n                  <CardTitle className=\"flex items-center gap-2\">\n                    <Shield className=\"h-5 w-5 text-primary\" />\n                    Nivel de Riesgo\n                  </CardTitle>\n                  <CardDescription>Define el tamaÃ±o de posiciones</CardDescription>\n                </CardHeader>\n                <CardContent>\n                  <Select\n                    value={config?.riskLevel || \"medium\"}\n                    onValueChange={(value) => updateMutation.mutate({ riskLevel: value })}\n                  >\n                    <SelectTrigger data-testid=\"select-risk-level\">\n                      <SelectValue />\n                    </SelectTrigger>\n                    <SelectContent>\n                      {RISK_LEVELS.map((level) => (\n                        <SelectItem key={level.id} value={level.id}>\n                          <div className=\"flex items-center gap-2\">\n                            <span className={level.color}>{level.name}</span>\n                            <span className=\"text-muted-foreground text-xs\">- {level.description}</span>\n                          </div>\n                        </SelectItem>\n                      ))}\n                    </SelectContent>\n                  </Select>\n                </CardContent>\n              </Card>\n\n              <Card className=\"glass-panel border-border/50\">\n                <CardHeader>\n                  <CardTitle className=\"flex items-center gap-2\">\n                    <Target className=\"h-5 w-5 text-primary\" />\n                    Pares de Trading\n                  </CardTitle>\n                  <CardDescription>Activa/desactiva pares para operar</CardDescription>\n                </CardHeader>\n                <CardContent>\n                  <div className=\"flex flex-wrap gap-2\">\n                    {AVAILABLE_PAIRS.map((pair) => {\n                      const isActive = config?.activePairs?.includes(pair);\n                      return (\n                        <Button\n                          key={pair}\n                          variant={isActive ? \"default\" : \"outline\"}\n                          size=\"sm\"\n                          onClick={() => togglePair(pair)}\n                          className=\"font-mono\"\n                          data-testid={`pair-toggle-${pair.replace(\"/\", \"-\")}`}\n                        >\n                          {pair}\n                        </Button>\n                      );\n                    })}\n                  </div>\n                </CardContent>\n              </Card>\n\n              <Card className=\"glass-panel border-border/50 border-yellow-500/30\">\n                <CardContent className=\"pt-6\">\n                  <div className=\"flex items-start gap-3\">\n                    <div className=\"p-2 bg-yellow-500/20 rounded-lg\">\n                      <Zap className=\"h-5 w-5 text-yellow-500\" />\n                    </div>\n                    <div>\n                      <h4 className=\"font-medium text-yellow-500\">Modo REAL Activado</h4>\n                      <p className=\"text-sm text-muted-foreground mt-1\">\n                        Todas las operaciones se ejecutan con dinero real en Kraken. \n                        No hay modo simulaciÃ³n.\n                      </p>\n                    </div>\n                  </div>\n                </CardContent>\n              </Card>\n            </div>\n          </div>\n\n          <Card className=\"glass-panel border-border/50\">\n            <CardHeader>\n              <CardTitle className=\"flex items-center gap-2\">\n                <AlertTriangle className=\"h-5 w-5 text-primary\" />\n                Control de Riesgo AutomÃ¡tico\n              </CardTitle>\n              <CardDescription>Configura stop-loss, take-profit y trailing stop para proteger tu capital</CardDescription>\n            </CardHeader>\n            <CardContent className=\"space-y-6\">\n              <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4 md:gap-6\">\n                <div className=\"space-y-3 md:space-y-4\">\n                  <div className=\"flex items-center justify-between\">\n                    <Label className=\"flex items-center gap-2 text-sm\">\n                      <div className=\"w-2.5 h-2.5 md:w-3 md:h-3 rounded-full bg-red-500\" />\n                      Stop-Loss\n                    </Label>\n                    <span className=\"font-mono text-lg text-red-500\">-{parseFloat(config?.stopLossPercent || \"5\").toFixed(1)}%</span>\n                  </div>\n                  <Slider\n                    value={[parseFloat(config?.stopLossPercent || \"5\")]}\n                    onValueChange={(value) => updateMutation.mutate({ stopLossPercent: value[0].toString() } as any)}\n                    min={1}\n                    max={20}\n                    step={0.5}\n                    className=\"[&>span]:bg-red-500\"\n                    data-testid=\"slider-stop-loss\"\n                  />\n                  <p className=\"text-xs text-muted-foreground\">Vende automÃ¡ticamente si el precio baja este porcentaje desde tu entrada.</p>\n                </div>\n\n                <div className=\"space-y-4\">\n                  <div className=\"flex items-center justify-between\">\n                    <Label className=\"flex items-center gap-2\">\n                      <div className=\"w-3 h-3 rounded-full bg-green-500\" />\n                      Take-Profit\n                    </Label>\n                    <span className=\"font-mono text-lg text-green-500\">+{parseFloat(config?.takeProfitPercent || \"7\").toFixed(1)}%</span>\n                  </div>\n                  <Slider\n                    value={[parseFloat(config?.takeProfitPercent || \"7\")]}\n                    onValueChange={(value) => updateMutation.mutate({ takeProfitPercent: value[0].toString() } as any)}\n                    min={1}\n                    max={30}\n                    step={0.5}\n                    className=\"[&>span]:bg-green-500\"\n                    data-testid=\"slider-take-profit\"\n                  />\n                  <p className=\"text-xs text-muted-foreground\">Vende automÃ¡ticamente cuando alcanzas este porcentaje de ganancia.</p>\n                </div>\n              </div>\n\n              <div className=\"border-t border-border/50 pt-6\">\n                <div className=\"flex items-center justify-between mb-4\">\n                  <div>\n                    <Label className=\"flex items-center gap-2\">\n                      <CircleDollarSign className=\"h-4 w-4 text-cyan-500\" />\n                      Trailing Stop\n                    </Label>\n                    <p className=\"text-xs text-muted-foreground mt-1\">Stop-loss que sube con el precio para asegurar ganancias</p>\n                  </div>\n                  <Switch\n                    checked={config?.trailingStopEnabled || false}\n                    onCheckedChange={(checked) => updateMutation.mutate({ trailingStopEnabled: checked } as any)}\n                    data-testid=\"switch-trailing-stop\"\n                  />\n                </div>\n\n                {config?.trailingStopEnabled && (\n                  <div className=\"space-y-4 animate-in fade-in slide-in-from-top-2\">\n                    <div className=\"flex items-center justify-between\">\n                      <Label>Distancia del Trailing</Label>\n                      <span className=\"font-mono text-lg text-cyan-500\">{parseFloat(config?.trailingStopPercent || \"2\").toFixed(1)}%</span>\n                    </div>\n                    <Slider\n                      value={[parseFloat(config?.trailingStopPercent || \"2\")]}\n                      onValueChange={(value) => updateMutation.mutate({ trailingStopPercent: value[0].toString() } as any)}\n                      min={0.5}\n                      max={10}\n                      step={0.5}\n                      className=\"[&>span]:bg-cyan-500\"\n                      data-testid=\"slider-trailing-stop\"\n                    />\n                    <p className=\"text-xs text-muted-foreground\">\n                      Si el precio sube y luego cae este porcentaje desde el mÃ¡ximo, se vende automÃ¡ticamente (solo si estÃ¡s en ganancia).\n                    </p>\n                  </div>\n                )}\n              </div>\n\n              <div className=\"bg-muted/30 rounded-lg p-4 mt-4\">\n                <h4 className=\"font-medium text-sm mb-2\">Ejemplo con configuraciÃ³n actual:</h4>\n                <p className=\"text-xs text-muted-foreground\">\n                  Si compras BTC a $100,000:\n                  <br />â€¢ <span className=\"text-red-500\">Stop-Loss:</span> Se vende si baja a ${(100000 * (1 - parseFloat(config?.stopLossPercent || \"5\") / 100)).toLocaleString()}\n                  <br />â€¢ <span className=\"text-green-500\">Take-Profit:</span> Se vende si sube a ${(100000 * (1 + parseFloat(config?.takeProfitPercent || \"7\") / 100)).toLocaleString()}\n                  {config?.trailingStopEnabled && (\n                    <>\n                      <br />â€¢ <span className=\"text-cyan-500\">Trailing Stop:</span> Si sube a $105,000 y luego cae {config?.trailingStopPercent}%, se vende a ${(105000 * (1 - parseFloat(config?.trailingStopPercent || \"2\") / 100)).toLocaleString()}\n                    </>\n                  )}\n                </p>\n              </div>\n            </CardContent>\n          </Card>\n\n          <Card className=\"glass-panel border-border/50\">\n            <CardHeader>\n              <CardTitle className=\"flex items-center gap-2\">\n                <Wallet className=\"h-5 w-5 text-primary\" />\n                TamaÃ±o de Trade\n              </CardTitle>\n              <CardDescription>Define quÃ© porcentaje del balance se usa en cada operaciÃ³n</CardDescription>\n            </CardHeader>\n            <CardContent className=\"space-y-6\">\n              <div className=\"space-y-3 md:space-y-4\">\n                <div className=\"flex items-center justify-between\">\n                  <Label className=\"flex items-center gap-2 text-sm\">\n                    <div className=\"w-2.5 h-2.5 md:w-3 md:h-3 rounded-full bg-blue-500\" />\n                    Riesgo por Trade\n                  </Label>\n                  <span className=\"font-mono text-lg text-blue-500\">{parseFloat(config?.riskPerTradePct || \"15\").toFixed(0)}%</span>\n                </div>\n                <Slider\n                  value={[parseFloat(config?.riskPerTradePct || \"15\")]}\n                  onValueChange={(value) => updateMutation.mutate({ riskPerTradePct: value[0].toString() } as any)}\n                  min={5}\n                  max={100}\n                  step={5}\n                  className=\"[&>span]:bg-blue-500\"\n                  data-testid=\"slider-risk-per-trade\"\n                />\n                <p className=\"text-xs text-muted-foreground\">Porcentaje del balance USD que se usarÃ¡ en cada operaciÃ³n de compra.</p>\n              </div>\n\n              <div className=\"bg-muted/30 rounded-lg p-4 mt-4\">\n                <h4 className=\"font-medium text-sm mb-2\">Ejemplo con balance de $100:</h4>\n                <p className=\"text-xs text-muted-foreground\">\n                  â€¢ <span className=\"text-blue-500\">TamaÃ±o del trade:</span> ${parseFloat(config?.riskPerTradePct || \"15\")} por operaciÃ³n\n                  <br />â€¢ Si el mÃ­nimo de Kraken es mayor, se ajustarÃ¡ automÃ¡ticamente.\n                  <br />â€¢ Los lÃ­mites de exposiciÃ³n se verifican antes de ejecutar.\n                </p>\n              </div>\n            </CardContent>\n          </Card>\n\n          <Card className=\"glass-panel border-border/50\">\n            <CardHeader>\n              <CardTitle className=\"flex items-center gap-2\">\n                <PieChart className=\"h-5 w-5 text-primary\" />\n                Control de ExposiciÃ³n\n              </CardTitle>\n              <CardDescription>Limita cuÃ¡nto capital puede estar comprometido en posiciones abiertas</CardDescription>\n            </CardHeader>\n            <CardContent className=\"space-y-6\">\n              <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4 md:gap-6\">\n                <div className=\"space-y-3 md:space-y-4\">\n                  <div className=\"flex items-center justify-between\">\n                    <Label className=\"flex items-center gap-2 text-sm\">\n                      <div className=\"w-2.5 h-2.5 md:w-3 md:h-3 rounded-full bg-orange-500\" />\n                      MÃ¡x. ExposiciÃ³n por Par\n                    </Label>\n                    <span className=\"font-mono text-lg text-orange-500\">{parseFloat(config?.maxPairExposurePct || \"25\").toFixed(0)}%</span>\n                  </div>\n                  <Slider\n                    value={[parseFloat(config?.maxPairExposurePct || \"25\")]}\n                    onValueChange={(value) => updateMutation.mutate({ maxPairExposurePct: value[0].toString() } as any)}\n                    min={5}\n                    max={100}\n                    step={5}\n                    className=\"[&>span]:bg-orange-500\"\n                    data-testid=\"slider-max-pair-exposure\"\n                  />\n                  <p className=\"text-xs text-muted-foreground\">MÃ¡ximo % del balance que puede estar en un solo par (ej: solo BTC/USD).</p>\n                </div>\n\n                <div className=\"space-y-4\">\n                  <div className=\"flex items-center justify-between\">\n                    <Label className=\"flex items-center gap-2\">\n                      <div className=\"w-3 h-3 rounded-full bg-purple-500\" />\n                      MÃ¡x. ExposiciÃ³n Total\n                    </Label>\n                    <span className=\"font-mono text-lg text-purple-500\">{parseFloat(config?.maxTotalExposurePct || \"60\").toFixed(0)}%</span>\n                  </div>\n                  <Slider\n                    value={[parseFloat(config?.maxTotalExposurePct || \"60\")]}\n                    onValueChange={(value) => updateMutation.mutate({ maxTotalExposurePct: value[0].toString() } as any)}\n                    min={10}\n                    max={100}\n                    step={5}\n                    className=\"[&>span]:bg-purple-500\"\n                    data-testid=\"slider-max-total-exposure\"\n                  />\n                  <p className=\"text-xs text-muted-foreground\">MÃ¡ximo % del balance que puede estar en todas las posiciones abiertas.</p>\n                </div>\n              </div>\n\n              <div className=\"space-y-3 mt-4\">\n                <Label className=\"flex items-center gap-2 text-sm\">\n                  <div className=\"w-2.5 h-2.5 rounded-full bg-blue-500\" />\n                  Base de CÃ¡lculo\n                </Label>\n                <div className=\"grid grid-cols-2 gap-2\">\n                  <button\n                    onClick={() => updateMutation.mutate({ exposureBase: \"cash\" } as any)}\n                    className={`p-3 rounded-lg border text-left transition-all ${\n                      config?.exposureBase !== \"portfolio\"\n                        ? \"border-blue-500 bg-blue-500/10\"\n                        : \"border-border hover:border-blue-500/50\"\n                    }`}\n                    data-testid=\"btn-exposure-base-cash\"\n                  >\n                    <div className=\"font-medium text-sm\">Solo Cash</div>\n                    <div className=\"text-xs text-muted-foreground\">% sobre USD disponible</div>\n                  </button>\n                  <button\n                    onClick={() => updateMutation.mutate({ exposureBase: \"portfolio\" } as any)}\n                    className={`p-3 rounded-lg border text-left transition-all ${\n                      config?.exposureBase === \"portfolio\"\n                        ? \"border-blue-500 bg-blue-500/10\"\n                        : \"border-border hover:border-blue-500/50\"\n                    }`}\n                    data-testid=\"btn-exposure-base-portfolio\"\n                  >\n                    <div className=\"font-medium text-sm\">Portfolio Total</div>\n                    <div className=\"text-xs text-muted-foreground\">% sobre cash + posiciones</div>\n                  </button>\n                </div>\n                <p className=\"text-xs text-muted-foreground\">\n                  <strong>Cash:</strong> Los lÃ­mites se calculan sobre el saldo USD disponible.\n                  <br /><strong>Portfolio:</strong> Los lÃ­mites se calculan sobre el valor total (cash + inversiones).\n                </p>\n              </div>\n\n              <div className=\"bg-muted/30 rounded-lg p-4 mt-4\">\n                <h4 className=\"font-medium text-sm mb-2\">Ejemplo con balance de $100:</h4>\n                <p className=\"text-xs text-muted-foreground\">\n                  â€¢ <span className=\"text-orange-500\">Por par:</span> MÃ¡ximo ${parseFloat(config?.maxPairExposurePct || \"25\")} en cada par individual\n                  <br />â€¢ <span className=\"text-purple-500\">Total:</span> MÃ¡ximo ${parseFloat(config?.maxTotalExposurePct || \"60\")} en todas las posiciones combinadas\n                  <br />â€¢ <span className=\"text-blue-500\">Base:</span> {config?.exposureBase === \"portfolio\" ? \"Portfolio total (cash + posiciones)\" : \"Solo cash disponible\"}\n                  <br />â€¢ Si se alcanza algÃºn lÃ­mite, el bot NO abrirÃ¡ nuevas posiciones y te notificarÃ¡.\n                </p>\n              </div>\n            </CardContent>\n          </Card>\n        </main>\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":27622,"size_tokens":null},"scripts/deploy-to-nas.md":{"content":"# GuÃ­a de Despliegue a QNAP NAS\n\n## MÃ©todo 1: ActualizaciÃ³n RÃ¡pida (Recomendado)\n\n### Paso 1: Descargar el proyecto actualizado\n\nEn Replit, descarga el proyecto como ZIP:\n1. Haz clic en los tres puntos (...) en la barra lateral\n2. Selecciona \"Download as zip\"\n\n### Paso 2: Subir al NAS\n\n1. Abre File Station en tu QNAP\n2. Navega a: `/share/ZFS37_DATA/share/Container/krakenbot`\n3. Crea una carpeta de backup: `krakenbot_backup_FECHA`\n4. Copia los archivos actuales a la carpeta de backup\n5. Extrae el ZIP descargado y reemplaza los archivos (excepto `.env`)\n\n### Paso 3: Reconstruir y reiniciar\n\nConecta por SSH a tu NAS y ejecuta:\n\n```bash\ncd /share/ZFS37_DATA/share/Container/krakenbot\n\n# Detener el contenedor actual\ndocker-compose down\n\n# Reconstruir la imagen con los nuevos cambios\ndocker-compose build --no-cache\n\n# Iniciar de nuevo\ndocker-compose up -d\n\n# Ver logs para confirmar que funciona\ndocker logs -f krakenbot\n```\n\n---\n\n## MÃ©todo 2: Git (Automatizado)\n\nSi configuraste Git en el NAS:\n\n```bash\ncd /share/ZFS37_DATA/share/Container/krakenbot\n\n# Guardar cambios locales\ngit stash\n\n# Obtener actualizaciones\ngit pull origin main\n\n# Restaurar cambios locales\ngit stash pop\n\n# Reconstruir y reiniciar\ndocker-compose down\ndocker-compose build --no-cache\ndocker-compose up -d\n```\n\n---\n\n## MÃ©todo 3: Script AutomÃ¡tico\n\n1. Copia el archivo `scripts/update-nas.sh` a tu NAS\n2. Dale permisos de ejecuciÃ³n: `chmod +x update-nas.sh`\n3. Ejecuta: `./update-nas.sh`\n\n---\n\n## Archivos que NO debes sobreescribir\n\n- `.env` - Contiene la configuraciÃ³n de base de datos\n- `data/` - Si tienes datos persistentes fuera de PostgreSQL\n\n## VerificaciÃ³n post-actualizaciÃ³n\n\n1. Abre http://192.168.1.104:3000\n2. Verifica que Kraken estÃ¡ conectado (indicador verde)\n3. Verifica que Telegram estÃ¡ conectado (indicador verde)\n4. Revisa que las pestaÃ±as PANEL, ESTRATEGIAS, HISTORIAL, CARTERA y AJUSTES funcionan\n\n## SoluciÃ³n de problemas\n\n### El contenedor no inicia\n```bash\ndocker logs krakenbot\n```\n\n### Error de base de datos\n```bash\ndocker-compose down\ndocker volume rm krakenbot_postgres_data\ndocker-compose up -d\n```\n(Nota: Esto borrarÃ¡ todos los datos de la base de datos)\n\n### Restaurar backup\n```bash\ndocker-compose down\ncp -r /share/ZFS37_DATA/share/Container/krakenbot_backups/BACKUP_NAME/* .\ndocker-compose up -d\n```\n","path":null,"size_bytes":2330,"size_tokens":null},"replit.md":{"content":"# KrakenBot - Autonomous Trading Bot\n\n## Overview\nKrakenBot is an autonomous cryptocurrency trading bot for the Kraken exchange. It features a web-based dashboard for monitoring, portfolio management (BTC, ETH, SOL, USD), and real-time Telegram notifications. Designed for 24/7 operation, it can be deployed on Replit or self-hosted via Docker. Its core purpose is to automate trading decisions based on predefined strategies and robust risk management, aiming to capitalize on market movements while protecting capital.\n\n## User Preferences\n- Preferred communication style: Simple, everyday language.\n- **Entornos**: NAS es la fuente de verdad (producciÃ³n y dataset IA). Replit solo para desarrollo y pruebas.\n- **SincronizaciÃ³n**: No implementar export/import ni DB remota entre NAS y Replit.\n\n## System Architecture\n\n### Frontend\n- **Framework**: React with TypeScript.\n- **Styling**: Tailwind CSS, utilizing shadcn/ui components (New York style).\n- **State Management**: TanStack React Query for server-side state.\n- **Build**: Vite.\n- **Real-time Events**: WebSocket-based event streaming and terminal logs to the Monitor page.\n\n### Backend\n- **Framework**: Express.js with TypeScript.\n- **Runtime**: Node.js.\n- **API**: RESTful endpoints (`/api/*`).\n- **Services**: KrakenService for exchange interaction, TelegramService for notifications, AiService for ML filter.\n\n### Data Storage\n- **Database**: PostgreSQL with Drizzle ORM.\n- **Schema**: Defined in `shared/schema.ts`.\n- **Key Tables**: `bot_config`, `api_config`, `trades`, `notifications`, `open_positions`, `training_trades`, `ai_config`.\n\n### Trading Engine\n- **Core Loop**: Executes every 10-30 seconds for balance checks, resets, stop-loss/take-profit, and strategy analysis.\n- **Strategies**: Momentum, Mean Reversion, Scalping, Grid Trading.\n- **Multi-Timeframe Analysis (MTF)**: Analyzes 5-min, 1-hour, and 4-hour trends.\n- **Trade Execution**: Market orders, database logging, position updates, Telegram notifications.\n- **Position Modes**: SINGLE (one position per pair), DCA (multiple entries), and SMART_GUARD (intelligent capital protection).\n\n### Risk Management\n- **Filters**: Commission profitability, exposure control (per pair, total, per trade), bid-ask spread, trading hours.\n- **Dynamic Adjustments**: Dynamic position sizing based on signal confidence.\n- **Loss Control**: Stop-Loss/Take-Profit, Trailing Stop, Daily Loss Limit, Cooldown System.\n- **Kraken Compliance**: Adherence to Kraken minimum trade volumes and real balance verification.\n- **Position Persistence**: Open positions are stored in the database.\n- **Configuration Snapshot**: New positions store a snapshot of trading parameters at entry.\n- **Exposure Base**: Configurable via `exposureBase` (\"cash\" or \"portfolio\"):\n  - `cash`: Limits calculated on available USD only (conservative, default).\n  - `portfolio`: Limits calculated on total portfolio value (cash + open positions).\n\n### SMART_GUARD Mode\n- **Purpose**: Intelligent capital protection with strict entry validation.\n- **Signal SELL Blocking (A1/A2)**: SMART_GUARD bloquea ventas por seÃ±al de estrategia. Solo risk exits (SL/TP/trailing) pueden vender. ExcepciÃ³n: orphan cleanup cuando wallet balance > 0 sin posiciÃ³n trackeada.\n- **MTF Entry Filter (B1)**: SeÃ±ales de velas requieren que 2/3 timeframes (5m, 1h, 4h) confirmen tendencia.\n- **Anti-FOMO Filter (B2)**: Bloquea BUY cuando RSI>65 + BollingerB>85 + bodyRatio>0.7 simultÃ¡neamente.\n- **Min Signals Threshold (B3)**: Requiere â‰¥5 seÃ±ales para BUY en SMART_GUARD mode.\n- **sellContext Validation (C1)**: Todas las ventas requieren sellContext para trazabilidad de P&L excepto emergency exits (stop-loss/emergencia).\n- **Sizing v2 (Auto Fallback)**:\n  - `sgMinEntryUsd` es un \"objetivo preferido\", no un bloqueo.\n  - Si `availableUsd >= sgMinEntryUsd` â†’ orden = `sgMinEntryUsd` exacto (no mÃ¡s).\n  - Si `availableUsd < sgMinEntryUsd` â†’ orden = saldo disponible (fallback automÃ¡tico).\n  - `floorUsd = max(minOrderExchangeUsd, $20)` â†’ mÃ­nimo absoluto (hard block).\n  - Si `availableUsd < floorUsd` â†’ trade bloqueado.\n  - **Fee Cushion**: Si `sgFeeCushionPct` o `sgFeeCushionAuto` activo, resta reserva para fees antes de sizing.\n  - **sgAllowUnderMin DEPRECATED**: Ya no afecta el comportamiento (siempre fallback automÃ¡tico).\n- **Reason Codes**:\n  - `SMART_GUARD_ENTRY_USING_CONFIG_MIN`: Saldo suficiente, usa sgMinEntryUsd.\n  - `SMART_GUARD_ENTRY_FALLBACK_TO_AVAILABLE`: Saldo insuficiente, usa saldo disponible.\n  - `SMART_GUARD_BLOCKED_BELOW_EXCHANGE_MIN`: Saldo < floorUsd (hard block).\n  - `SMART_GUARD_BLOCKED_AFTER_FEE_CUSHION`: Fee cushion reduce saldo por debajo de floorUsd.\n- **Break-Even Protection**: Moves stop-loss to entry price + fees when profit reaches sgBeAtPct.\n- **Trailing Stop**: Activates at sgTrailStartPct profit, follows at sgTrailDistancePct, updates at sgTrailStepPct steps.\n- **Fixed Take-Profit**: Optional sgTpFixedPct for guaranteed profit capture.\n- **Scale-Out**: Optional partial profit taking at sgScaleOutPct before fixed TP.\n- **Per-Pair Overrides**: sgPairOverrides allows customizing parameters per trading pair via API and UI.\n- **Diagnostic Endpoint**: GET /api/scan/diagnostic provides scan results with Spanish reasons.\n- **Test Endpoint**: POST /api/test/sg-sizing para simular sizing v2 (solo en dev/dryRun).\n- **Telegram Alerts**: Notifications for key events (Break-Even activation, Trailing Stop activation/updates, Scale-Out execution) with 5-min throttle on trailing updates.\n- **Override API**: GET/PUT/DELETE /api/config/sg-overrides/:pair for managing per-pair parameters.\n- **Event Types**: SG_BREAK_EVEN_ACTIVATED, SG_TRAILING_ACTIVATED, SG_TRAILING_STOP_UPDATED, SG_SCALE_OUT_EXECUTED, CONFIG_OVERRIDE_UPDATED.\n\n### Environment Safety\n- **DRY_RUN Mode**: Prevents real orders from being sent to exchange.\n- **Auto-Detection**: Replit environment (REPLIT_DEPLOYMENT, REPL_ID) forces DRY_RUN automatically.\n- **NAS Control**: On NAS, dryRunMode can be toggled via bot_config.\n- **Simulation**: In DRY_RUN, executeTrade() logs events and sends \"[DRY_RUN] Trade Simulado\" Telegram messages without touching Kraken.\n- **Production Safety**: NAS is the source of truth for production trading; Replit is development/testing only.\n\n### FIFO Position Matching\n- **Purpose**: Automatic position closing with partial fills tracking to eliminate \"phantom positions.\"\n- **Tables**:\n  - `trade_fills`: Individual fills with UNIQUE(txid), matched flag for idempotency.\n  - `lot_matches`: FIFO matching audit trail with UNIQUE(sellFillTxid, lotId).\n  - `open_positions.qtyRemaining/qtyFilled`: Track partial consumption of buy lots.\n- **FIFO Logic**:\n  - Sell fills match against oldest buy lots first (ORDER BY openedAt ASC).\n  - Uses SELECT FOR UPDATE within transaction to prevent concurrent double-consumption.\n  - Pro-rates buy/sell fees based on matched quantity for accurate P&L.\n- **Orphan Handling**: \n  - Fills only marked `matched=true` when fully processed (sellRemaining â‰ˆ 0).\n  - Orphan fills (no matching lots) remain unmatched for future retry.\n- **API Endpoints**:\n  - `POST /api/fifo/init-lots`: Initialize qtyRemaining = amount for existing lots.\n  - `POST /api/fifo/process-sells`: Process all unmatched sell fills.\n  - `POST /api/fifo/ingest-fill`: Ingest a new fill and trigger FIFO matching.\n  - `GET /api/fifo/open-lots`: Get lots with qtyRemaining > 0.\n- **Auto-Integration**: After each real sell execution in `executeTrade()`, the trading engine automatically:\n  1. Creates a TradeFill record with txid, pair, price, amount, and estimated fee\n  2. Triggers `fifoMatcher.processSellFill()` to match against open buy lots\n  3. Logs matching results (lots closed, P&L, orphan qty)\n  4. Only runs for real trades (DRY_RUN mode is safely bypassed with triple guard)\n- **Transaction Safety**: All operations (lot select, match insert, qty update, fill mark) run within same tx handle.\n\n### Confidence Normalization\n- **Convention**: Interno (signals/positions) usa escala 0..1, Display (UI/Telegram/logs) y ML usa 0..100.\n- **Helper**: `server/utils/confidence.ts` con `toConfidencePct()` y `toConfidenceUnit()`.\n- **DB Loading**: Posiciones cargadas con `toConfidenceUnit()` para normalizar valores histÃ³ricos.\n- **Scale-Out**: ComparaciÃ³n y logs usan `toConfidencePct()` para mostrar \"78%\" no \"0.78%\".\n- **AI Dataset**: Features siempre en 0..100 para consistencia del modelo.\n\n### Strategy Meta Inheritance (SELL Labeling)\n- **Purpose**: SELL trades inherit strategy metadata from the original position to ensure consistent labeling.\n- **Autocompletion**: If `strategyMeta` is missing or incomplete in `executeTrade()`, it's auto-populated from the open position.\n- **Multi-Lot Support**: Uses `getPositionsByPair()` and selects the oldest position (FIFO) for metadata.\n- **Fields Inherited**: `entryStrategyId`, `entrySignalTf`, `signalConfidence` from the position.\n- **Result**: SELL labeled as \"Momentum (Velas 15m)\" matches the BUY origin, not generic \"Ciclos\".\n\n### P&L Tracking (Immediate SELL)\n- **Purpose**: Every automatic SELL trade stores P&L at execution time, not just after sync.\n- **executeTrade()**: Calculates and stores entryPrice, realizedPnlUsd, realizedPnlPct when sellContext.entryPrice is available.\n- **Orphan Handling**: Emergency/orphan SELLs (no entryPrice) allowed but marked with `SELL_NO_ENTRYPRICE` and P&L fields = NULL.\n- **Sync Upsert**: `/api/trades/sync` uses UPSERT by kraken_order_id:\n  - If trade exists â†’ UPDATE (preserving existing P&L, never overwriting)\n  - If not exists â†’ INSERT\n- **Anti-Duplicates**: UNIQUE partial index on `trades.kraken_order_id WHERE NOT NULL`.\n\n### AI Filter Module\n- **Purpose**: Machine learning filter to approve/reject trade signals based on historical performance.\n- **Phases**: Red (data collection), Yellow (ready to train), Green (filter active).\n- **Training Data**: `training_trades` table stores BUY/SELL pairs with PnL labels. Backfill reconstructs data.\n- **Discard Reasons**: Excludes invalid or anomalous trades from training data.\n- **Diagnostic Metrics**: Provides aggregated counts of discard reasons and open trades/lots.\n\n### Telegram Integration\n- **Functionality**: Sends notifications for bot status, trade executions, risk management triggers, and errors.\n- **Commands (Docker/NAS)**: `/estado`, `/pausar`, `/reanudar`, `/balance`, `/config`, `/exposicion`, `/uptime`, `/ultimas`, `/ayuda`, `/menu`, `/channels`.\n- **Modes**: Polling for Docker/NAS deployments (commands), disabled for Replit (notifications only).\n- **Features**: Rate limiting, multi-chat support, inline keyboard buttons.\n- **Menu (/menu)**: Interactive buttons for Estado, Balance, ExposiciÃ³n, Sync, Pausar/Reanudar, Canales, Reporte diario, Ayuda.\n- **Channel Management (/channels)**: Toggle alerts per chat (Trades, System, Errors, Balance, Heartbeat).\n- **Daily Report**: Scheduled at 14:00 Europe/Madrid with system metrics (CPU/Mem/Disk/Uptime) and bot status.\n- **HTML Formatting**: All messages use HTML parse_mode with `<b>`, `<i>`, `<code>` tags instead of Markdown.\n- **Security**: `escapeHtml()` helper prevents markup injection from dynamic data (pairs, prices, errors).\n- **Templates**: Centralized `buildXxxHTML()` functions in `server/services/telegram.ts` for consistent formatting.\n\n### Quote Currency Validation\n- **Purpose**: Block trades on non-USD pairs to prevent accidental cross-pair operations.\n- **Allowed Quotes**: Only \"USD\" pairs are allowed (e.g., BTC/USD, ETH/USD).\n- **Blocked**: Pairs like ETH/BTC, XRP/EUR are rejected with log `PAIR_NOT_ALLOWED_QUOTE`.\n- **Location**: Validation in `executeTrade()` before any order execution.\n\n## External Dependencies\n\n- **Kraken Exchange API**:\n    - **Package**: `node-kraken-api`.\n    - **Purpose**: Trading operations (execute, fetch balances, market data).\n    - **Configuration**: API key/secret stored in `api_config` table.\n\n- **Telegram Bot API**:\n    - **Package**: `node-telegram-bot-api`.\n    - **Purpose**: Send notifications and receive commands.\n    - **Configuration**: Bot token and chat ID stored in `api_config` table.\n\n- **PostgreSQL Database**:\n    - **ORM**: Drizzle ORM.\n    - **Connection**: Via `DATABASE_URL` environment variable.\n    - **Driver**: `pg`.","path":null,"size_bytes":12280,"size_tokens":null},"server/services/tradingEngine.ts":{"content":"import { KrakenService } from \"./kraken\";\nimport { TelegramService } from \"./telegram\";\nimport { botLogger } from \"./botLogger\";\nimport { storage } from \"../storage\";\nimport { log } from \"../index\";\nimport { aiService, AiFeatures } from \"./aiService\";\nimport { environment } from \"./environment\";\nimport { fifoMatcher } from \"./fifoMatcher\";\nimport { toConfidencePct, toConfidenceUnit } from \"../utils/confidence\";\n\ninterface PriceData {\n  price: number;\n  timestamp: number;\n  high: number;\n  low: number;\n  volume: number;\n}\n\ninterface TradeSignal {\n  action: \"buy\" | \"sell\" | \"hold\";\n  pair: string;\n  confidence: number;\n  reason: string;\n}\n\ninterface RiskConfig {\n  maxTradeUSD: number;\n}\n\nconst RISK_LEVELS: Record<string, RiskConfig> = {\n  low: {\n    maxTradeUSD: 20,\n  },\n  medium: {\n    maxTradeUSD: 50,\n  },\n  high: {\n    maxTradeUSD: 100,\n  },\n};\n\nconst DUST_THRESHOLD_USD = 5; // Minimum USD value to attempt selling\n\nconst SMALL_ACCOUNT_FACTOR = 0.95;\n\n// Kraken fee structure (taker fees for market orders)\nconst KRAKEN_FEE_PCT = 0.26; // 0.26% per trade\nconst ROUND_TRIP_FEE_PCT = KRAKEN_FEE_PCT * 2; // ~0.52% for buy + sell\nconst MIN_PROFIT_MULTIPLIER = 2; // Take-profit debe ser al menos 2x las fees\n\n// Defensive improvements\nconst MAX_SPREAD_PCT = 0.5; // No comprar si spread > 0.5%\nconst TRADING_HOURS_START = 8; // UTC - inicio de horario de trading\nconst TRADING_HOURS_END = 22; // UTC - fin de horario de trading\nconst POST_STOPLOSS_COOLDOWN_MS = 30 * 60 * 1000; // 30 min cooldown tras stop-loss\nconst CONFIDENCE_SIZING_THRESHOLDS = {\n  high: { min: 0.8, factor: 1.0 },    // 100% del monto\n  medium: { min: 0.7, factor: 0.75 }, // 75% del monto\n  low: { min: 0.6, factor: 0.5 },     // 50% del monto\n};\n\n// SMART_GUARD: umbral absoluto mÃ­nimo para evitar comisiones absurdas\nconst SG_ABSOLUTE_MIN_USD = 20;\n\n// === VALIDACIÃ“N CENTRALIZADA DE MÃNIMOS (fuente Ãºnica de verdad) ===\n// Reason codes para SMART_GUARD sizing\ntype SmartGuardReasonCode = \n  | \"SMART_GUARD_BLOCKED_BELOW_EXCHANGE_MIN\"   // saldo < floorUsd (hard block)\n  | \"SMART_GUARD_BLOCKED_AFTER_FEE_CUSHION\"    // availableAfterCushion < floorUsd\n  | \"SMART_GUARD_ENTRY_USING_CONFIG_MIN\"       // saldo >= sgMinEntryUsd, usando sgMinEntryUsd\n  | \"SMART_GUARD_ENTRY_FALLBACK_TO_AVAILABLE\"; // saldo < sgMinEntryUsd, usando saldo disponible\n\ninterface MinimumValidationParams {\n  positionMode: string;\n  orderUsdFinal: number;\n  orderUsdProposed: number;\n  usdDisponible: number;\n  exposureAvailable: number;\n  pair: string;\n  sgMinEntryUsd?: number;\n  sgAllowUnderMin?: boolean; // DEPRECATED - se ignora (siempre auto fallback)\n  dryRun?: boolean;\n  env?: string;\n  floorUsd?: number;\n  availableAfterCushion?: number;\n}\n\ninterface MinimumValidationResult {\n  valid: boolean;\n  skipReason?: SmartGuardReasonCode | \"MIN_ORDER_ABSOLUTE\" | \"MIN_ORDER_USD\";\n  reasonCode?: SmartGuardReasonCode;\n  message?: string;\n  meta?: Record<string, any>;\n}\n\nfunction validateMinimumsOrSkip(params: MinimumValidationParams): MinimumValidationResult {\n  const {\n    positionMode,\n    orderUsdFinal,\n    orderUsdProposed,\n    usdDisponible,\n    exposureAvailable,\n    pair,\n    sgMinEntryUsd = 100,\n    sgAllowUnderMin = true, // DEPRECATED - ignorado\n    dryRun = false,\n    env = \"UNKNOWN\",\n    floorUsd,\n    availableAfterCushion,\n  } = params;\n\n  const effectiveFloor = floorUsd ?? SG_ABSOLUTE_MIN_USD;\n\n  const meta = {\n    pair,\n    usdDisponible,\n    orderUsdProposed,\n    orderUsdFinal,\n    sgMinEntryUsd,\n    sgAllowUnderMin_DEPRECATED: sgAllowUnderMin,\n    exposureAvailable,\n    env,\n    dryRun,\n    absoluteMinUsd: SG_ABSOLUTE_MIN_USD,\n    floorUsd: effectiveFloor,\n    availableAfterCushion,\n  };\n\n  // REGLA 1: Hard block - si orderUsdFinal < floorUsd (exchange min + absoluto)\n  if (orderUsdFinal < effectiveFloor) {\n    return {\n      valid: false,\n      skipReason: \"SMART_GUARD_BLOCKED_BELOW_EXCHANGE_MIN\",\n      reasonCode: \"SMART_GUARD_BLOCKED_BELOW_EXCHANGE_MIN\",\n      message: `Trade bloqueado: orderUsdFinal $${orderUsdFinal.toFixed(2)} < floorUsd $${effectiveFloor.toFixed(2)} (mÃ­n exchange + absoluto)`,\n      meta,\n    };\n  }\n\n  // REGLA 2: Hard block - si availableAfterCushion < floorUsd (fee cushion applied)\n  if (availableAfterCushion !== undefined && availableAfterCushion < effectiveFloor) {\n    return {\n      valid: false,\n      skipReason: \"SMART_GUARD_BLOCKED_AFTER_FEE_CUSHION\",\n      reasonCode: \"SMART_GUARD_BLOCKED_AFTER_FEE_CUSHION\",\n      message: `Trade bloqueado: availableAfterCushion $${availableAfterCushion.toFixed(2)} < floorUsd $${effectiveFloor.toFixed(2)}`,\n      meta,\n    };\n  }\n\n  // Fallback para modos no-SMART_GUARD\n  if (orderUsdFinal < SG_ABSOLUTE_MIN_USD) {\n    return {\n      valid: false,\n      skipReason: \"MIN_ORDER_ABSOLUTE\",\n      message: `Trade bloqueado: orderUsdFinal $${orderUsdFinal.toFixed(2)} < mÃ­nimo absoluto $${SG_ABSOLUTE_MIN_USD}`,\n      meta,\n    };\n  }\n\n  return { valid: true };\n}\n\ninterface ConfigSnapshot {\n  stopLossPercent: number;\n  takeProfitPercent: number;\n  trailingStopEnabled: boolean;\n  trailingStopPercent: number;\n  positionMode: string;\n  // SMART_GUARD specific fields (only populated when positionMode === \"SMART_GUARD\")\n  sgMinEntryUsd?: number;\n  sgAllowUnderMin?: boolean;\n  sgBeAtPct?: number;\n  sgFeeCushionPct?: number;\n  sgFeeCushionAuto?: boolean;\n  sgTrailStartPct?: number;\n  sgTrailDistancePct?: number;\n  sgTrailStepPct?: number;\n  sgTpFixedEnabled?: boolean;\n  sgTpFixedPct?: number;\n  sgScaleOutEnabled?: boolean;\n  sgScaleOutPct?: number;\n  sgMinPartUsd?: number;\n  sgScaleOutThreshold?: number;\n}\n\ninterface OpenPosition {\n  lotId: string; // Unique identifier for this lot (multi-lot support)\n  pair: string; // Pair for this position\n  amount: number;\n  entryPrice: number;\n  highestPrice: number;\n  openedAt: number;\n  entryStrategyId: string;\n  entrySignalTf: string;\n  signalConfidence?: number;\n  signalReason?: string;\n  aiSampleId?: number;\n  entryMode?: string;\n  configSnapshot?: ConfigSnapshot;\n  // SMART_GUARD dynamic state\n  sgBreakEvenActivated?: boolean;\n  sgCurrentStopPrice?: number;\n  sgTrailingActivated?: boolean;\n  sgScaleOutDone?: boolean;\n}\n\nfunction generateLotId(pair: string): string {\n  const timestamp = Date.now();\n  const random = Math.random().toString(36).substring(2, 8);\n  return `LOT-${pair.replace(\"/\", \"\")}-${timestamp}-${random}`;\n}\n\ninterface CandleTrackingState {\n  lastEvaluatedCandleTs: number;\n  lastEvaluatedPair: string;\n}\n\ninterface OHLCCandle {\n  time: number;\n  open: number;\n  high: number;\n  low: number;\n  close: number;\n  volume: number;\n}\n\ninterface MultiTimeframeData {\n  tf5m: OHLCCandle[];\n  tf1h: OHLCCandle[];\n  tf4h: OHLCCandle[];\n  lastUpdate: number;\n}\n\ninterface TrendAnalysis {\n  shortTerm: \"bullish\" | \"bearish\" | \"neutral\";\n  mediumTerm: \"bullish\" | \"bearish\" | \"neutral\";\n  longTerm: \"bullish\" | \"bearish\" | \"neutral\";\n  alignment: number;\n  confidence: number;\n  summary: string;\n}\n\nexport class TradingEngine {\n  private krakenService: KrakenService;\n  private telegramService: TelegramService;\n  private isRunning: boolean = false;\n  private intervalId: NodeJS.Timeout | null = null;\n  private priceHistory: Map<string, PriceData[]> = new Map();\n  private lastTradeTime: Map<string, number> = new Map();\n  private openPositions: Map<string, OpenPosition> = new Map(); // Key is lotId for multi-lot support\n  private currentUsdBalance: number = 0;\n  private mtfCache: Map<string, MultiTimeframeData> = new Map();\n  private readonly PRICE_HISTORY_LENGTH = 50;\n  private readonly MIN_TRADE_INTERVAL_MS = 60000;\n  private readonly MTF_CACHE_TTL = 300000;\n  \n  private dailyPnL: number = 0;\n  private dailyStartBalance: number = 0;\n  private lastDayReset: string = \"\";\n  private isDailyLimitReached: boolean = false;\n  \n  private pairCooldowns: Map<string, number> = new Map();\n  private lastExposureAlert: Map<string, number> = new Map();\n  private stopLossCooldowns: Map<string, number> = new Map();\n  private spreadFilterEnabled: boolean = true;\n  private readonly COOLDOWN_DURATION_MS = 15 * 60 * 1000;\n  private readonly EXPOSURE_ALERT_INTERVAL_MS = 30 * 60 * 1000;\n  \n  // Tracking para Momentum (Velas) - Ãºltima vela evaluada por par+timeframe\n  private lastEvaluatedCandle: Map<string, number> = new Map();\n  \n  // Fallback minimums (only used if Kraken API fails)\n  private readonly FALLBACK_MINIMUMS: Record<string, number> = {\n    \"BTC/USD\": 0.0001,\n    \"ETH/USD\": 0.01,\n    \"SOL/USD\": 0.02,\n    \"XRP/USD\": 1.65,\n    \"TON/USD\": 1,\n    \"ETH/BTC\": 0.01,\n  };\n\n  private normalizeVolume(pair: string, volume: number): number {\n    const stepSize = this.krakenService.getStepSize(pair);\n    if (stepSize === null) {\n      log(`[WARNING] No step size for ${pair}, using 8 decimal fallback`, \"trading\");\n      const fallbackDecimals = 8;\n      return Math.floor(volume * Math.pow(10, fallbackDecimals)) / Math.pow(10, fallbackDecimals);\n    }\n    const decimals = Math.abs(Math.log10(stepSize));\n    return Math.floor(volume * Math.pow(10, decimals)) / Math.pow(10, decimals);\n  }\n\n  private getOrderMin(pair: string): number {\n    const orderMin = this.krakenService.getOrderMin(pair);\n    if (orderMin === null) {\n      log(`[WARNING] No orderMin for ${pair}, using fallback`, \"trading\");\n      return this.FALLBACK_MINIMUMS[pair] || 0.01;\n    }\n    return orderMin;\n  }\n\n  private hasPairMetadata(pair: string): boolean {\n    return this.krakenService.hasMetadata(pair);\n  }\n  \n  // Timeframe en segundos para calcular cierre de vela\n  private readonly TIMEFRAME_SECONDS: Record<string, number> = {\n    \"5m\": 5 * 60,\n    \"15m\": 15 * 60,\n    \"1h\": 60 * 60,\n  };\n\n  // Engine tick tracking (heartbeat cada 60s)\n  private tickIntervalId: NodeJS.Timeout | null = null;\n  private lastTickTime: number = 0;\n  private lastScanTime: number = 0;\n  private readonly TICK_INTERVAL_MS = 60 * 1000; // 60 seconds\n  private lastScanResults: Map<string, { signal: string; reason: string; cooldownSec?: number; exposureAvailable?: number }> = new Map();\n  \n  // SMART_GUARD alert throttle: key = \"lotId:eventType\", value = timestamp\n  private sgAlertThrottle: Map<string, number> = new Map();\n  private readonly SG_TRAIL_UPDATE_THROTTLE_MS = 5 * 60 * 1000; // 5 minutes between trailing stop updates\n  \n  // DRY_RUN mode: audit without sending real orders\n  private dryRunMode: boolean = false;\n  private readonly isReplitEnvironment: boolean = !!process.env.REPLIT_DEPLOYMENT || !!process.env.REPL_ID;\n\n  constructor(krakenService: KrakenService, telegramService: TelegramService) {\n    this.krakenService = krakenService;\n    this.telegramService = telegramService;\n    \n    // Auto-enable dry run on Replit to prevent accidental real trades\n    if (this.isReplitEnvironment) {\n      this.dryRunMode = true;\n      log(\"[SAFETY] Entorno Replit detectado - DRY_RUN activado automÃ¡ticamente\", \"trading\");\n    }\n  }\n\n  // === MULTI-LOT HELPERS ===\n  private getPositionsByPair(pair: string): OpenPosition[] {\n    const positions: OpenPosition[] = [];\n    this.openPositions.forEach((position) => {\n      if (position.pair === pair) {\n        positions.push(position);\n      }\n    });\n    return positions;\n  }\n\n  private getFirstPositionByPair(pair: string): OpenPosition | undefined {\n    for (const position of this.openPositions.values()) {\n      if (position.pair === pair) {\n        return position;\n      }\n    }\n    return undefined;\n  }\n\n  private countLotsForPair(pair: string): number {\n    let count = 0;\n    this.openPositions.forEach((position) => {\n      if (position.pair === pair) {\n        count++;\n      }\n    });\n    return count;\n  }\n\n  // === SMART_GUARD ALERT HELPERS ===\n  private shouldSendSgAlert(lotId: string, eventType: string, throttleMs?: number): boolean {\n    const key = `${lotId}:${eventType}`;\n    const lastAlert = this.sgAlertThrottle.get(key);\n    const now = Date.now();\n    const cooldown = throttleMs ?? 0;\n    \n    if (lastAlert && now - lastAlert < cooldown) {\n      return false;\n    }\n    this.sgAlertThrottle.set(key, now);\n    return true;\n  }\n\n  private async sendSgEventAlert(\n    eventType: \"SG_BREAK_EVEN_ACTIVATED\" | \"SG_TRAILING_ACTIVATED\" | \"SG_TRAILING_STOP_UPDATED\" | \"SG_SCALE_OUT_EXECUTED\",\n    position: OpenPosition,\n    currentPrice: number,\n    extra: { stopPrice?: number; profitPct: number; reason: string }\n  ) {\n    const { lotId, pair, entryPrice } = position;\n    const shortLotId = lotId.substring(0, 12);\n    const envPrefix = environment.getMessagePrefix(this.dryRunMode);\n    const envInfo = environment.getInfo();\n\n    // Emit event for /api/events\n    await botLogger.info(eventType, `${eventType} en ${pair}`, {\n      pair,\n      lotId,\n      entryPrice,\n      currentPrice,\n      stopPrice: extra.stopPrice,\n      profitPct: extra.profitPct,\n      env: envInfo.env,\n      instanceId: envInfo.instanceId,\n      reason: extra.reason,\n    });\n\n    // Send Telegram notification\n    if (this.telegramService.isInitialized()) {\n      let emoji = \"\";\n      let title = \"\";\n      \n      switch (eventType) {\n        case \"SG_BREAK_EVEN_ACTIVATED\":\n          emoji = \"âš–ï¸\";\n          title = \"Break-Even Activado\";\n          break;\n        case \"SG_TRAILING_ACTIVATED\":\n          emoji = \"ğŸ“ˆ\";\n          title = \"Trailing Stop Activado\";\n          break;\n        case \"SG_TRAILING_STOP_UPDATED\":\n          emoji = \"ğŸ”¼\";\n          title = \"Stop Actualizado\";\n          break;\n        case \"SG_SCALE_OUT_EXECUTED\":\n          emoji = \"ğŸ“Š\";\n          title = \"Scale-Out Ejecutado\";\n          break;\n      }\n\n      const stopLine = extra.stopPrice ? `   â€¢ Nuevo Stop: <code>$${extra.stopPrice.toFixed(4)}</code>` : '';\n      const profitEmoji = extra.profitPct >= 0 ? \"ğŸ“ˆ\" : \"ğŸ“‰\";\n      \n      const message = `ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n${emoji} <b>${title}</b>\n\nğŸ“¦ <b>Detalles:</b>\n   â€¢ Par: <code>${pair}</code>\n   â€¢ Lote: <code>${shortLotId}</code>\n   â€¢ Entry: <code>$${entryPrice.toFixed(2)}</code>\n   â€¢ Actual: <code>$${currentPrice.toFixed(2)}</code>\n   â€¢ Profit: <code>${extra.profitPct >= 0 ? '+' : ''}${extra.profitPct.toFixed(2)}%</code>\n${stopLine}\n\nâ„¹ï¸ ${extra.reason}\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`;\n\n      await this.telegramService.sendAlertToMultipleChats(message, \"status\");\n    }\n  }\n\n  private getUniquePairs(): string[] {\n    const pairs = new Set<string>();\n    this.openPositions.forEach((position) => {\n      pairs.add(position.pair);\n    });\n    return Array.from(pairs);\n  }\n\n  private calculatePairExposure(pair: string): number {\n    let total = 0;\n    this.openPositions.forEach((position) => {\n      if (position.pair === pair) {\n        total += position.amount * position.entryPrice;\n      }\n    });\n    return total;\n  }\n\n  private calculateTotalExposure(): number {\n    let total = 0;\n    this.openPositions.forEach((position) => {\n      total += position.amount * position.entryPrice;\n    });\n    return total;\n  }\n\n  private getAvailableExposure(pair: string, config: any, freshUsdBalance?: number): { \n    maxPairAvailable: number; \n    maxTotalAvailable: number; \n    maxAllowed: number;\n    exposureBaseUsed: string;\n    baseValueUsd: number;\n  } {\n    const maxPairExposurePct = parseFloat(config.maxPairExposurePct?.toString() || \"25\");\n    const maxTotalExposurePct = parseFloat(config.maxTotalExposurePct?.toString() || \"60\");\n    const exposureBase = config.exposureBase || \"cash\";\n\n    const currentPairExposure = this.calculatePairExposure(pair);\n    const currentTotalExposure = this.calculateTotalExposure();\n\n    const usdBalance = freshUsdBalance ?? this.currentUsdBalance;\n    \n    // Calculate base value depending on exposureBase setting\n    // \"cash\" = solo USD disponible, \"portfolio\" = cash + posiciones abiertas\n    const baseValueUsd = exposureBase === \"portfolio\" \n      ? usdBalance + currentTotalExposure \n      : usdBalance;\n    \n    const maxPairExposureUsd = baseValueUsd * (maxPairExposurePct / 100);\n    const maxTotalExposureUsd = baseValueUsd * (maxTotalExposurePct / 100);\n\n    const maxPairAvailable = Math.max(0, maxPairExposureUsd - currentPairExposure);\n    const maxTotalAvailable = Math.max(0, maxTotalExposureUsd - currentTotalExposure);\n    \n    return {\n      maxPairAvailable,\n      maxTotalAvailable,\n      maxAllowed: Math.min(maxPairAvailable, maxTotalAvailable),\n      exposureBaseUsed: exposureBase,\n      baseValueUsd,\n    };\n  }\n\n  // === SMART_GUARD: Obtener parÃ¡metros con overrides por par ===\n  private getSmartGuardParams(pair: string, config: any): {\n    sgMinEntryUsd: number;\n    sgAllowUnderMin: boolean;\n    sgBeAtPct: number;\n    sgFeeCushionPct: number;\n    sgFeeCushionAuto: boolean;\n    sgTrailStartPct: number;\n    sgTrailDistancePct: number;\n    sgTrailStepPct: number;\n    sgTpFixedEnabled: boolean;\n    sgTpFixedPct: number;\n    sgScaleOutEnabled: boolean;\n    sgScaleOutPct: number;\n    sgMinPartUsd: number;\n    sgScaleOutThreshold: number;\n  } {\n    // Valores base de config global\n    const base = {\n      sgMinEntryUsd: parseFloat(config?.sgMinEntryUsd?.toString() || \"100\"),\n      sgAllowUnderMin: config?.sgAllowUnderMin ?? true,\n      sgBeAtPct: parseFloat(config?.sgBeAtPct?.toString() || \"1.5\"),\n      sgFeeCushionPct: parseFloat(config?.sgFeeCushionPct?.toString() || \"0.45\"),\n      sgFeeCushionAuto: config?.sgFeeCushionAuto ?? true,\n      sgTrailStartPct: parseFloat(config?.sgTrailStartPct?.toString() || \"2\"),\n      sgTrailDistancePct: parseFloat(config?.sgTrailDistancePct?.toString() || \"1.5\"),\n      sgTrailStepPct: parseFloat(config?.sgTrailStepPct?.toString() || \"0.25\"),\n      sgTpFixedEnabled: config?.sgTpFixedEnabled ?? false,\n      sgTpFixedPct: parseFloat(config?.sgTpFixedPct?.toString() || \"10\"),\n      sgScaleOutEnabled: config?.sgScaleOutEnabled ?? false,\n      sgScaleOutPct: parseFloat(config?.sgScaleOutPct?.toString() || \"35\"),\n      sgMinPartUsd: parseFloat(config?.sgMinPartUsd?.toString() || \"50\"),\n      sgScaleOutThreshold: parseFloat(config?.sgScaleOutThreshold?.toString() || \"80\"),\n    };\n\n    // Aplicar overrides por par si existen\n    const overrides = config?.sgPairOverrides?.[pair];\n    if (overrides) {\n      const merged = { ...base };\n      // Floats\n      if (overrides.sgMinEntryUsd !== undefined) merged.sgMinEntryUsd = parseFloat(overrides.sgMinEntryUsd.toString());\n      if (overrides.sgBeAtPct !== undefined) merged.sgBeAtPct = parseFloat(overrides.sgBeAtPct.toString());\n      if (overrides.sgFeeCushionPct !== undefined) merged.sgFeeCushionPct = parseFloat(overrides.sgFeeCushionPct.toString());\n      if (overrides.sgTrailStartPct !== undefined) merged.sgTrailStartPct = parseFloat(overrides.sgTrailStartPct.toString());\n      if (overrides.sgTrailDistancePct !== undefined) merged.sgTrailDistancePct = parseFloat(overrides.sgTrailDistancePct.toString());\n      if (overrides.sgTrailStepPct !== undefined) merged.sgTrailStepPct = parseFloat(overrides.sgTrailStepPct.toString());\n      if (overrides.sgTpFixedPct !== undefined) merged.sgTpFixedPct = parseFloat(overrides.sgTpFixedPct.toString());\n      if (overrides.sgMinPartUsd !== undefined) merged.sgMinPartUsd = parseFloat(overrides.sgMinPartUsd.toString());\n      if (overrides.sgScaleOutPct !== undefined) merged.sgScaleOutPct = parseFloat(overrides.sgScaleOutPct.toString());\n      if (overrides.sgScaleOutThreshold !== undefined) merged.sgScaleOutThreshold = parseFloat(overrides.sgScaleOutThreshold.toString());\n      // Booleans\n      if (overrides.sgAllowUnderMin !== undefined) merged.sgAllowUnderMin = !!overrides.sgAllowUnderMin;\n      if (overrides.sgFeeCushionAuto !== undefined) merged.sgFeeCushionAuto = !!overrides.sgFeeCushionAuto;\n      if (overrides.sgTpFixedEnabled !== undefined) merged.sgTpFixedEnabled = !!overrides.sgTpFixedEnabled;\n      if (overrides.sgScaleOutEnabled !== undefined) merged.sgScaleOutEnabled = !!overrides.sgScaleOutEnabled;\n      return merged;\n    }\n\n    return base;\n  }\n\n  private isPairInCooldown(pair: string): boolean {\n    const cooldownUntil = this.pairCooldowns.get(pair);\n    if (!cooldownUntil) return false;\n    \n    if (Date.now() >= cooldownUntil) {\n      this.pairCooldowns.delete(pair);\n      return false;\n    }\n    return true;\n  }\n\n  private setPairCooldown(pair: string): void {\n    const cooldownUntil = Date.now() + this.COOLDOWN_DURATION_MS;\n    this.pairCooldowns.set(pair, cooldownUntil);\n    log(`${pair} en cooldown por ${this.COOLDOWN_DURATION_MS / 60000} minutos`, \"trading\");\n  }\n\n  private shouldSendExposureAlert(pair: string): boolean {\n    const lastAlert = this.lastExposureAlert.get(pair) || 0;\n    if (Date.now() - lastAlert < this.EXPOSURE_ALERT_INTERVAL_MS) {\n      return false;\n    }\n    this.lastExposureAlert.set(pair, Date.now());\n    return true;\n  }\n\n  // === MEJORA 1: Filtro de Spread ===\n  private calculateSpreadPct(bid: number, ask: number): number {\n    if (bid <= 0 || ask <= 0) return 0;\n    const midPrice = (bid + ask) / 2;\n    return ((ask - bid) / midPrice) * 100;\n  }\n\n  private isSpreadAcceptable(tickerData: any): { acceptable: boolean; spreadPct: number } {\n    if (!this.spreadFilterEnabled) {\n      return { acceptable: true, spreadPct: 0 };\n    }\n    \n    const bid = parseFloat(tickerData.b?.[0] || \"0\");\n    const ask = parseFloat(tickerData.a?.[0] || \"0\");\n    const spreadPct = this.calculateSpreadPct(bid, ask);\n    \n    return {\n      acceptable: spreadPct <= MAX_SPREAD_PCT,\n      spreadPct,\n    };\n  }\n\n  // === MEJORA 2: Horarios de Trading ===\n  private isWithinTradingHours(config: any): { withinHours: boolean; hourUTC: number; start: number; end: number } {\n    const tradingHoursEnabled = config.tradingHoursEnabled ?? true;\n    const start = parseInt(config.tradingHoursStart?.toString() || \"8\");\n    const end = parseInt(config.tradingHoursEnd?.toString() || \"22\");\n    \n    if (!tradingHoursEnabled) {\n      return { withinHours: true, hourUTC: new Date().getUTCHours(), start, end };\n    }\n    \n    const now = new Date();\n    const hourUTC = now.getUTCHours();\n    \n    return { withinHours: hourUTC >= start && hourUTC < end, hourUTC, start, end };\n  }\n\n  // === MEJORA 3: Position Sizing DinÃ¡mico ===\n  private getConfidenceSizingFactor(confidence: number): number {\n    if (confidence >= CONFIDENCE_SIZING_THRESHOLDS.high.min) {\n      return CONFIDENCE_SIZING_THRESHOLDS.high.factor;\n    } else if (confidence >= CONFIDENCE_SIZING_THRESHOLDS.medium.min) {\n      return CONFIDENCE_SIZING_THRESHOLDS.medium.factor;\n    } else if (confidence >= CONFIDENCE_SIZING_THRESHOLDS.low.min) {\n      return CONFIDENCE_SIZING_THRESHOLDS.low.factor;\n    }\n    return 0; // No trade if confidence < 0.6\n  }\n\n  // === ENGINE TICK: Heartbeat cada 60s ===\n  private async emitEngineTick(): Promise<void> {\n    if (!this.isRunning) return;\n\n    try {\n      const config = await storage.getBotConfig();\n      const now = Date.now();\n      const loopLatencyMs = this.lastScanTime > 0 ? now - this.lastScanTime : 0;\n      \n      const openPositionsPairs = Array.from(this.openPositions.keys());\n      \n      await botLogger.info(\"ENGINE_TICK\", \"Motor activo - escaneo en curso\", {\n        activePairs: config?.activePairs || [],\n        openPositionsCount: this.openPositions.size,\n        openPositionsPairs,\n        lastScanAt: this.lastScanTime > 0 ? new Date(this.lastScanTime).toISOString() : null,\n        loopLatencyMs,\n        balanceUsd: this.currentUsdBalance,\n        isDailyLimitReached: this.isDailyLimitReached,\n        dailyPnL: this.dailyPnL,\n      });\n\n      this.lastTickTime = now;\n\n      // Emitir MARKET_SCAN_SUMMARY si hay resultados\n      if (this.lastScanResults.size > 0) {\n        const scanSummary: Record<string, any> = {};\n        this.lastScanResults.forEach((result, pair) => {\n          scanSummary[pair] = result;\n        });\n\n        await botLogger.info(\"MARKET_SCAN_SUMMARY\", \"Resumen de escaneo de mercado\", {\n          pairs: scanSummary,\n          scanTime: new Date(this.lastScanTime).toISOString(),\n        });\n      }\n    } catch (error: any) {\n      log(`Error emitiendo ENGINE_TICK: ${error.message}`, \"trading\");\n    }\n  }\n\n  // Helper to get cooldown remaining seconds\n  private getCooldownRemainingSec(pair: string): number | undefined {\n    const cooldownUntil = this.pairCooldowns.get(pair);\n    if (!cooldownUntil) return undefined;\n    const remaining = Math.max(0, Math.floor((cooldownUntil - Date.now()) / 1000));\n    return remaining > 0 ? remaining : undefined;\n  }\n\n  private getStopLossCooldownRemainingSec(pair: string): number | undefined {\n    const cooldownUntil = this.stopLossCooldowns.get(pair);\n    if (!cooldownUntil) return undefined;\n    const remaining = Math.max(0, Math.floor((cooldownUntil - Date.now()) / 1000));\n    return remaining > 0 ? remaining : undefined;\n  }\n\n  // === MEJORA 4: Cooldown Post Stop-Loss ===\n  private isPairInStopLossCooldown(pair: string): boolean {\n    const cooldownUntil = this.stopLossCooldowns.get(pair);\n    if (!cooldownUntil) return false;\n    \n    if (Date.now() >= cooldownUntil) {\n      this.stopLossCooldowns.delete(pair);\n      return false;\n    }\n    return true;\n  }\n\n  private setStopLossCooldown(pair: string): void {\n    const cooldownUntil = Date.now() + POST_STOPLOSS_COOLDOWN_MS;\n    this.stopLossCooldowns.set(pair, cooldownUntil);\n    log(`${pair} en cooldown post-SL por ${POST_STOPLOSS_COOLDOWN_MS / 60000} minutos`, \"trading\");\n  }\n\n  private isProfitableAfterFees(takeProfitPct: number): { \n    isProfitable: boolean; \n    minProfitRequired: number; \n    roundTripFees: number;\n    netExpectedProfit: number;\n  } {\n    const roundTripFees = ROUND_TRIP_FEE_PCT;\n    const minProfitRequired = roundTripFees * MIN_PROFIT_MULTIPLIER;\n    const netExpectedProfit = takeProfitPct - roundTripFees;\n    \n    return {\n      isProfitable: takeProfitPct >= minProfitRequired,\n      minProfitRequired,\n      roundTripFees,\n      netExpectedProfit,\n    };\n  }\n\n  // === MOMENTUM (VELAS) - Helpers ===\n  private getTimeframeIntervalMinutes(timeframe: string): number {\n    switch (timeframe) {\n      case \"5m\": return 5;\n      case \"15m\": return 15;\n      case \"1h\": return 60;\n      default: return 5;\n    }\n  }\n\n  private async getLastClosedCandle(pair: string, timeframe: string): Promise<OHLCCandle | null> {\n    try {\n      const intervalMinutes = this.getTimeframeIntervalMinutes(timeframe);\n      const candles = await this.krakenService.getOHLC(pair, intervalMinutes);\n      if (!candles || candles.length < 2) return null;\n      return candles[candles.length - 2];\n    } catch (error: any) {\n      log(`Error obteniendo vela cerrada ${pair}/${timeframe}: ${error.message}`, \"trading\");\n      return null;\n    }\n  }\n\n  private isNewCandleClosed(pair: string, timeframe: string, candleTime: number): boolean {\n    const key = `${pair}:${timeframe}`;\n    const lastTs = this.lastEvaluatedCandle.get(key) || 0;\n    if (candleTime > lastTs) {\n      this.lastEvaluatedCandle.set(key, candleTime);\n      return true;\n    }\n    return false;\n  }\n\n  private async analyzeWithCandleStrategy(\n    pair: string,\n    timeframe: string,\n    candle: OHLCCandle\n  ): Promise<TradeSignal> {\n    const intervalMinutes = this.getTimeframeIntervalMinutes(timeframe);\n    const candles = await this.krakenService.getOHLC(pair, intervalMinutes);\n    if (!candles || candles.length < 20) {\n      return { action: \"hold\", pair, confidence: 0, reason: \"Datos insuficientes para anÃ¡lisis de velas\" };\n    }\n    \n    const closedCandles = candles.slice(0, -1);\n    \n    // B1: Aplicar filtro MTF a Momentum Velas (igual que en ciclos)\n    const mtfData = await this.getMultiTimeframeData(pair);\n    const mtfAnalysis = mtfData ? this.analyzeMultiTimeframe(mtfData) : null;\n    \n    let signal = this.momentumCandlesStrategy(pair, closedCandles, candle.close);\n    \n    // Aplicar filtro MTF si hay seÃ±al activa\n    if (mtfAnalysis && signal.action !== \"hold\") {\n      const mtfBoost = this.applyMTFFilter(signal, mtfAnalysis);\n      if (mtfBoost.filtered) {\n        return { action: \"hold\", pair, confidence: 0.3, reason: `SeÃ±al filtrada por MTF: ${mtfBoost.reason}` };\n      }\n      signal.confidence = Math.min(0.95, signal.confidence + mtfBoost.confidenceBoost);\n      if (mtfBoost.confidenceBoost > 0) {\n        signal.reason += ` | ${mtfBoost.reason}`;\n      }\n    }\n    \n    return signal;\n  }\n\n  private momentumCandlesStrategy(pair: string, candles: OHLCCandle[], currentPrice: number): TradeSignal {\n    if (candles.length < 20) {\n      return { action: \"hold\", pair, confidence: 0, reason: \"Historial de velas insuficiente\" };\n    }\n    \n    const closes = candles.map(c => c.close);\n    const shortEMA = this.calculateEMA(closes.slice(-10), 10);\n    const longEMA = this.calculateEMA(closes.slice(-20), 20);\n    const rsi = this.calculateRSI(closes.slice(-14));\n    const macd = this.calculateMACD(closes);\n    const bollinger = this.calculateBollingerBands(closes);\n    \n    const lastCandle = candles[candles.length - 1];\n    const prevCandle = candles[candles.length - 2];\n    const isBullishCandle = lastCandle.close > lastCandle.open;\n    const isBearishCandle = lastCandle.close < lastCandle.open;\n    const candleBody = Math.abs(lastCandle.close - lastCandle.open);\n    const candleRange = lastCandle.high - lastCandle.low;\n    const bodyRatio = candleRange > 0 ? candleBody / candleRange : 0;\n    \n    const avgVolume = candles.slice(-10).reduce((sum, c) => sum + c.volume, 0) / 10;\n    const volumeRatio = avgVolume > 0 ? lastCandle.volume / avgVolume : 1;\n    const isHighVolume = volumeRatio > 1.5;\n    \n    let buySignals = 0;\n    let sellSignals = 0;\n    const reasons: string[] = [];\n\n    if (shortEMA > longEMA) buySignals++;\n    else if (shortEMA < longEMA) sellSignals++;\n\n    if (rsi < 30) { buySignals += 2; reasons.push(`RSI sobrevendido (${rsi.toFixed(0)})`); }\n    else if (rsi < 45) { buySignals++; }\n    else if (rsi > 70) { sellSignals += 2; reasons.push(`RSI sobrecomprado (${rsi.toFixed(0)})`); }\n    else if (rsi > 55) { sellSignals++; }\n\n    if (macd.histogram > 0 && macd.macd > macd.signal) { buySignals++; reasons.push(\"MACD alcista\"); }\n    else if (macd.histogram < 0 && macd.macd < macd.signal) { sellSignals++; reasons.push(\"MACD bajista\"); }\n\n    if (bollinger.percentB < 20) { buySignals++; reasons.push(\"Precio en Bollinger inferior\"); }\n    else if (bollinger.percentB > 80) { sellSignals++; reasons.push(\"Precio en Bollinger superior\"); }\n\n    if (isBullishCandle && bodyRatio > 0.6) {\n      buySignals++;\n      reasons.push(\"Vela alcista fuerte\");\n    } else if (isBearishCandle && bodyRatio > 0.6) {\n      sellSignals++;\n      reasons.push(\"Vela bajista fuerte\");\n    }\n\n    if (isHighVolume) {\n      if (isBullishCandle) { buySignals++; reasons.push(`Volumen alto alcista (${volumeRatio.toFixed(1)}x)`); }\n      else if (isBearishCandle) { sellSignals++; reasons.push(`Volumen alto bajista (${volumeRatio.toFixed(1)}x)`); }\n    }\n\n    if (isBullishCandle && prevCandle && prevCandle.close < prevCandle.open) {\n      if (lastCandle.close > prevCandle.open) {\n        buySignals++;\n        reasons.push(\"Engulfing alcista\");\n      }\n    }\n    if (isBearishCandle && prevCandle && prevCandle.close > prevCandle.open) {\n      if (lastCandle.close < prevCandle.open) {\n        sellSignals++;\n        reasons.push(\"Engulfing bajista\");\n      }\n    }\n\n    const confidence = Math.min(0.95, 0.5 + (Math.max(buySignals, sellSignals) * 0.07));\n    \n    // B2: Filtro anti-FOMO - bloquear BUY en condiciones de entrada tardÃ­a\n    const isAntifomoTriggered = rsi > 65 && bollinger.percentB > 85 && bodyRatio > 0.7;\n    \n    if (buySignals >= 4 && buySignals > sellSignals && rsi < 70) {\n      // B2: Verificar anti-FOMO antes de emitir seÃ±al BUY\n      if (isAntifomoTriggered) {\n        return {\n          action: \"hold\",\n          pair,\n          confidence: 0.4,\n          reason: `Anti-FOMO: RSI=${rsi.toFixed(0)} BB%=${bollinger.percentB.toFixed(0)} bodyRatio=${bodyRatio.toFixed(2)} | SeÃ±ales: ${buySignals}/${sellSignals}`,\n        };\n      }\n      return {\n        action: \"buy\",\n        pair,\n        confidence,\n        reason: `Momentum Velas COMPRA: ${reasons.join(\", \")} | SeÃ±ales: ${buySignals}/${sellSignals}`,\n      };\n    }\n    \n    if (sellSignals >= 4 && sellSignals > buySignals && rsi > 30) {\n      return {\n        action: \"sell\",\n        pair,\n        confidence,\n        reason: `Momentum Velas VENTA: ${reasons.join(\", \")} | SeÃ±ales: ${sellSignals}/${buySignals}`,\n      };\n    }\n\n    return { action: \"hold\", pair, confidence: 0.3, reason: `Sin seÃ±al clara velas (${buySignals}/${sellSignals})` };\n  }\n\n  async start() {\n    if (this.isRunning) return;\n    \n    const config = await storage.getBotConfig();\n    if (!config?.isActive) {\n      log(\"Bot no estÃ¡ activo, no se inicia el motor de trading\", \"trading\");\n      return;\n    }\n\n    if (!this.krakenService.isInitialized()) {\n      log(\"Kraken no estÃ¡ configurado, no se puede iniciar el trading\", \"trading\");\n      return;\n    }\n\n    // Load dynamic pair metadata from Kraken API (step sizes, order minimums)\n    const activePairs = config.activePairs || [\"BTC/USD\", \"ETH/USD\", \"SOL/USD\", \"XRP/USD\"];\n    try {\n      await this.krakenService.loadPairMetadata(activePairs);\n      // Verify all active pairs have metadata\n      const missingPairs = activePairs.filter(p => !this.krakenService.hasMetadata(p));\n      if (missingPairs.length > 0) {\n        log(`[CRITICAL] Missing metadata for pairs: ${missingPairs.join(\", \")}. Using fallback values.`, \"trading\");\n      }\n      this.krakenService.startMetadataRefresh(activePairs);\n    } catch (error: any) {\n      log(`[CRITICAL] Failed to load pair metadata: ${error.message}. Trading will use fallback values.`, \"trading\");\n      // Continue with fallbacks - don't block trading entirely for API failures\n    }\n\n    if (!this.telegramService.isInitialized()) {\n      log(\"Telegram no estÃ¡ configurado, continuando sin notificaciones\", \"trading\");\n    }\n    \n    // Load dryRunMode from config (Replit always forces dry run regardless of DB setting)\n    const dbDryRun = (config as any).dryRunMode ?? false;\n    if (this.isReplitEnvironment) {\n      this.dryRunMode = true;\n      log(\"[SAFETY] Modo DRY_RUN forzado en Replit - no se enviarÃ¡n Ã³rdenes reales\", \"trading\");\n    } else {\n      this.dryRunMode = dbDryRun;\n      if (this.dryRunMode) {\n        log(\"[INFO] Modo DRY_RUN activado desde configuraciÃ³n\", \"trading\");\n      }\n    }\n\n    try {\n      const balances = await this.krakenService.getBalance();\n      this.currentUsdBalance = parseFloat(balances?.ZUSD || balances?.USD || \"0\");\n      log(`Balance inicial USD: $${this.currentUsdBalance.toFixed(2)}`, \"trading\");\n    } catch (error: any) {\n      log(`Error obteniendo balance inicial: ${error.message}`, \"trading\");\n      return;\n    }\n\n    this.isRunning = true;\n    log(\"Motor de trading iniciado\", \"trading\");\n    \n    await this.loadOpenPositionsFromDB();\n    \n    const modeLabel = this.dryRunMode ? \"DRY_RUN (simulaciÃ³n)\" : \"LIVE (Ã³rdenes reales)\";\n    \n    await botLogger.info(\"BOT_STARTED\", \"Motor de trading iniciado\", {\n      strategy: config.strategy,\n      riskLevel: config.riskLevel,\n      activePairs: config.activePairs,\n      balanceUsd: this.currentUsdBalance,\n      openPositions: this.openPositions.size,\n      dryRunMode: this.dryRunMode,\n      isReplitEnvironment: this.isReplitEnvironment,\n    });\n    \n    if (this.telegramService.isInitialized()) {\n      const modeText = this.dryRunMode ? \"DRY_RUN (simulaciÃ³n)\" : \"LIVE\";\n      await this.telegramService.sendMessage(`ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâœ… <b>Bot Iniciado</b>\n\nğŸ“Š <b>ConfiguraciÃ³n:</b>\n   â€¢ Estrategia: <code>${config.strategy}</code>\n   â€¢ Riesgo: <code>${config.riskLevel}</code>\n   â€¢ Pares: <code>${config.activePairs.join(\", \")}</code>\n\nğŸ’° <b>Estado:</b>\n   â€¢ Balance: <code>$${this.currentUsdBalance.toFixed(2)}</code>\n   â€¢ Posiciones: <code>${this.openPositions.size}</code>\n\nâš™ï¸ <b>Modo:</b> <code>${modeText}</code>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);\n    }\n    \n    const intervalMs = this.getIntervalForStrategy(config.strategy);\n    this.intervalId = setInterval(() => this.runTradingCycle(), intervalMs);\n    \n    // Iniciar tick interval para ENGINE_TICK cada 60s\n    this.tickIntervalId = setInterval(() => this.emitEngineTick(), this.TICK_INTERVAL_MS);\n    \n    this.runTradingCycle();\n  }\n\n  async stop() {\n    if (!this.isRunning) return;\n    \n    this.isRunning = false;\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n    if (this.tickIntervalId) {\n      clearInterval(this.tickIntervalId);\n      this.tickIntervalId = null;\n    }\n    \n    log(\"Motor de trading detenido\", \"trading\");\n    \n    await botLogger.info(\"BOT_STOPPED\", \"Motor de trading detenido\");\n    \n    if (this.telegramService.isInitialized()) {\n      await this.telegramService.sendMessage(`ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ›‘ <b>Bot Detenido</b>\n\nEl motor de trading ha sido desactivado.\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);\n    }\n  }\n\n  private getIntervalForStrategy(strategy: string): number {\n    switch (strategy) {\n      case \"scalping\": return 10000;\n      case \"grid\": return 15000;\n      case \"momentum\": return 30000;\n      case \"mean_reversion\": return 30000;\n      default: return 30000;\n    }\n  }\n\n  private async loadOpenPositionsFromDB() {\n    try {\n      const positions = await storage.getOpenPositions();\n      this.openPositions.clear();\n      \n      for (const pos of positions) {\n        const hasSnapshot = pos.configSnapshotJson && pos.entryMode;\n        const configSnapshot = hasSnapshot ? (pos.configSnapshotJson as ConfigSnapshot) : undefined;\n        \n        // Use existing lotId or generate one for legacy positions\n        const lotId = pos.lotId || generateLotId(pos.pair);\n        \n        this.openPositions.set(lotId, {\n          lotId,\n          pair: pos.pair,\n          amount: parseFloat(pos.amount),\n          entryPrice: parseFloat(pos.entryPrice),\n          highestPrice: parseFloat(pos.highestPrice),\n          openedAt: new Date(pos.openedAt).getTime(),\n          entryStrategyId: pos.entryStrategyId || \"momentum_cycle\",\n          entrySignalTf: pos.entrySignalTf || \"cycle\",\n          signalConfidence: pos.signalConfidence ? toConfidenceUnit(pos.signalConfidence) : undefined,\n          signalReason: pos.signalReason || undefined,\n          entryMode: pos.entryMode || undefined,\n          configSnapshot,\n          // SMART_GUARD state\n          sgBreakEvenActivated: pos.sgBreakEvenActivated ?? false,\n          sgCurrentStopPrice: pos.sgCurrentStopPrice ? parseFloat(pos.sgCurrentStopPrice) : undefined,\n          sgTrailingActivated: pos.sgTrailingActivated ?? false,\n          sgScaleOutDone: pos.sgScaleOutDone ?? false,\n        });\n        \n        // If position lacked lotId, update DB\n        if (!pos.lotId) {\n          await storage.updateOpenPositionLotId(pos.id, lotId);\n          log(`Migrated legacy position ${pos.pair} -> lotId: ${lotId}`, \"trading\");\n        }\n        \n        const snapshotInfo = hasSnapshot ? `[snapshot: ${pos.entryMode}]` : \"[legacy: uses current config]\";\n        log(`PosiciÃ³n recuperada: ${pos.pair} (${lotId}) - ${pos.amount} @ $${pos.entryPrice} (${pos.entryStrategyId}/${pos.entrySignalTf}) ${snapshotInfo}`, \"trading\");\n      }\n      \n      if (positions.length > 0) {\n        log(`${positions.length} posiciones abiertas (${this.openPositions.size} lotes) cargadas desde la base de datos`, \"trading\");\n        if (this.telegramService.isInitialized()) {\n          const positionsList = positions.map(p => {\n            const hasSnap = p.configSnapshotJson && p.entryMode;\n            const snapEmoji = hasSnap ? \"ğŸ“¸\" : \"âš™ï¸\";\n            return `   ${snapEmoji} ${p.pair}: <code>${p.amount} @ $${parseFloat(p.entryPrice).toFixed(2)}</code>`;\n          }).join(\"\\n\");\n          await this.telegramService.sendMessage(`ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ“‚ <b>Posiciones Abiertas</b>\n\n${positionsList}\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);\n        }\n      }\n    } catch (error: any) {\n      log(`Error cargando posiciones: ${error.message}`, \"trading\");\n    }\n  }\n\n  private async savePositionToDB(pair: string, position: OpenPosition) {\n    try {\n      await storage.saveOpenPositionByLotId({\n        lotId: position.lotId,\n        pair,\n        entryPrice: position.entryPrice.toString(),\n        amount: position.amount.toString(),\n        highestPrice: position.highestPrice.toString(),\n        entryStrategyId: position.entryStrategyId,\n        entrySignalTf: position.entrySignalTf,\n        signalConfidence: position.signalConfidence?.toString(),\n        signalReason: position.signalReason,\n        entryMode: position.entryMode,\n        configSnapshotJson: position.configSnapshot,\n        // SMART_GUARD state\n        sgBreakEvenActivated: position.sgBreakEvenActivated,\n        sgCurrentStopPrice: position.sgCurrentStopPrice?.toString(),\n        sgTrailingActivated: position.sgTrailingActivated,\n        sgScaleOutDone: position.sgScaleOutDone,\n      });\n    } catch (error: any) {\n      log(`Error guardando posiciÃ³n ${pair} (${position.lotId}): ${error.message}`, \"trading\");\n    }\n  }\n\n  private async deletePositionFromDBByLotId(lotId: string) {\n    try {\n      await storage.deleteOpenPositionByLotId(lotId);\n    } catch (error: any) {\n      log(`Error eliminando posiciÃ³n ${lotId}: ${error.message}`, \"trading\");\n    }\n  }\n\n  private async updatePositionHighestPriceByLotId(lotId: string, highestPrice: number) {\n    try {\n      await storage.updateOpenPositionByLotId(lotId, {\n        highestPrice: highestPrice.toString(),\n      });\n    } catch (error: any) {\n      log(`Error actualizando highestPrice ${lotId}: ${error.message}`, \"trading\");\n    }\n  }\n\n  private async runTradingCycle() {\n    try {\n      const config = await storage.getBotConfig();\n      if (!config?.isActive) {\n        await this.stop();\n        return;\n      }\n\n      // Actualizar tiempo de escaneo y limpiar resultados anteriores\n      this.lastScanTime = Date.now();\n      this.lastScanResults.clear();\n\n      const balances = await this.krakenService.getBalance();\n      this.currentUsdBalance = parseFloat(balances?.ZUSD || balances?.USD || \"0\");\n      \n      // Reset diario del P&L\n      const today = new Date().toISOString().split(\"T\")[0];\n      if (this.lastDayReset !== today) {\n        const previousDayPnL = this.dailyPnL;\n        this.dailyPnL = 0;\n        this.dailyStartBalance = this.currentUsdBalance;\n        this.lastDayReset = today;\n        this.isDailyLimitReached = false;\n        log(`Nuevo dÃ­a de trading: ${today}. Balance inicial: $${this.dailyStartBalance.toFixed(2)}`, \"trading\");\n        \n        await botLogger.info(\"DAILY_LIMIT_RESET\", `Nuevo dÃ­a de trading: ${today}`, {\n          date: today,\n          previousDayPnL,\n          startBalance: this.dailyStartBalance,\n        });\n      }\n\n      // Verificar lÃ­mite de pÃ©rdida diaria\n      const dailyLossLimitEnabled = config.dailyLossLimitEnabled ?? true;\n      const dailyLossLimitPercent = parseFloat(config.dailyLossLimitPercent?.toString() || \"10\");\n      \n      if (dailyLossLimitEnabled && this.dailyStartBalance > 0) {\n        const currentLossPercent = (this.dailyPnL / this.dailyStartBalance) * 100;\n        \n        if (currentLossPercent <= -dailyLossLimitPercent && !this.isDailyLimitReached) {\n          this.isDailyLimitReached = true;\n          log(`ğŸ›‘ LÃMITE DE PÃ‰RDIDA DIARIA ALCANZADO: ${currentLossPercent.toFixed(2)}% (lÃ­mite: -${dailyLossLimitPercent}%)`, \"trading\");\n          \n          await botLogger.warn(\"DAILY_LIMIT_HIT\", \"LÃ­mite de pÃ©rdida diaria alcanzado. Bot pausado para nuevas compras.\", {\n            dailyPnL: this.dailyPnL,\n            dailyPnLPercent: currentLossPercent,\n            limitPercent: dailyLossLimitPercent,\n            startBalance: this.dailyStartBalance,\n          });\n          \n          if (this.telegramService.isInitialized()) {\n            await this.telegramService.sendMessage(`ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ›‘ <b>LÃ­mite de PÃ©rdida Diaria Alcanzado</b>\n\nEl bot ha pausado las operaciones de COMPRA.\n\nğŸ“Š <b>Resumen:</b>\n   â€¢ P&L del dÃ­a: <code>${currentLossPercent.toFixed(2)}%</code>\n   â€¢ PÃ©rdida: <code>$${Math.abs(this.dailyPnL).toFixed(2)}</code>\n   â€¢ LÃ­mite configurado: <code>-${dailyLossLimitPercent}%</code>\n\nâ„¹ï¸ Las operaciones de cierre (SL/TP) siguen activas.\nâ° El trading normal se reanudarÃ¡ maÃ±ana.\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);\n          }\n        }\n      }\n      \n      const riskConfig = RISK_LEVELS[config.riskLevel] || RISK_LEVELS.medium;\n\n      const stopLossPercent = parseFloat(config.stopLossPercent?.toString() || \"5\");\n      const takeProfitPercent = parseFloat(config.takeProfitPercent?.toString() || \"7\");\n      const trailingStopEnabled = config.trailingStopEnabled ?? false;\n      const trailingStopPercent = parseFloat(config.trailingStopPercent?.toString() || \"2\");\n\n      // Stop-Loss y Take-Profit siempre se verifican (incluso con lÃ­mite alcanzado)\n      for (const pair of config.activePairs) {\n        await this.checkStopLossTakeProfit(pair, stopLossPercent, takeProfitPercent, trailingStopEnabled, trailingStopPercent, balances);\n      }\n\n      // No abrir nuevas posiciones si se alcanzÃ³ el lÃ­mite diario\n      if (this.isDailyLimitReached) {\n        return;\n      }\n\n      if (this.currentUsdBalance < 5) {\n        log(`Saldo USD insuficiente: $${this.currentUsdBalance.toFixed(2)}`, \"trading\");\n        return;\n      }\n\n      // MEJORA 2: Verificar horarios de trading\n      const tradingHoursCheck = this.isWithinTradingHours(config);\n      if (!tradingHoursCheck.withinHours) {\n        log(`Fuera de horario de trading (${tradingHoursCheck.hourUTC}h UTC). Horario: ${tradingHoursCheck.start}h-${tradingHoursCheck.end}h UTC`, \"trading\");\n        return;\n      }\n\n      const signalTimeframe = config.signalTimeframe || \"cycle\";\n      const isCandleMode = signalTimeframe !== \"cycle\" && config.strategy === \"momentum\";\n\n      for (const pair of config.activePairs) {\n        // Inicializar entrada por defecto para diagnÃ³stico (se sobrescribe si hay seÃ±al)\n        if (!this.lastScanResults.has(pair)) {\n          const expDefault = this.getAvailableExposure(pair, config, this.currentUsdBalance);\n          this.lastScanResults.set(pair, {\n            signal: \"NONE\",\n            reason: \"Sin seÃ±al en este ciclo\",\n            exposureAvailable: expDefault.maxAllowed,\n          });\n        }\n        \n        if (isCandleMode) {\n          const candle = await this.getLastClosedCandle(pair, signalTimeframe);\n          if (!candle) continue;\n          \n          if (this.isNewCandleClosed(pair, signalTimeframe, candle.time)) {\n            log(`Nueva vela cerrada ${pair}/${signalTimeframe} @ ${new Date(candle.time * 1000).toISOString()}`, \"trading\");\n            await this.analyzePairAndTradeWithCandles(pair, signalTimeframe, candle, riskConfig, balances);\n          }\n        } else {\n          await this.analyzePairAndTrade(pair, config.strategy, riskConfig, balances);\n        }\n      }\n    } catch (error: any) {\n      log(`Error en ciclo de trading: ${error.message}`, \"trading\");\n    }\n  }\n\n  private async checkStopLossTakeProfit(\n    pair: string,\n    stopLossPercent: number,\n    takeProfitPercent: number,\n    trailingStopEnabled: boolean,\n    trailingStopPercent: number,\n    balances: any\n  ) {\n    // Get all positions for this pair (multi-lot support)\n    const positions = this.getPositionsByPair(pair);\n    if (positions.length === 0) return;\n\n    try {\n      const krakenPair = this.formatKrakenPair(pair);\n      const ticker = await this.krakenService.getTicker(krakenPair);\n      const tickerData: any = Object.values(ticker)[0];\n      if (!tickerData) return;\n\n      const currentPrice = parseFloat(tickerData.c?.[0] || \"0\");\n\n      // Process each position for this pair independently\n      for (const position of positions) {\n        if (position.amount <= 0) continue;\n        \n        await this.checkSinglePositionSLTP(\n          pair, position, currentPrice, stopLossPercent, takeProfitPercent,\n          trailingStopEnabled, trailingStopPercent, balances\n        );\n      }\n    } catch (error: any) {\n      log(`Error verificando SL/TP para ${pair}: ${error.message}`, \"trading\");\n    }\n  }\n\n  private async checkSinglePositionSLTP(\n    pair: string,\n    position: OpenPosition,\n    currentPrice: number,\n    stopLossPercent: number,\n    takeProfitPercent: number,\n    trailingStopEnabled: boolean,\n    trailingStopPercent: number,\n    balances: any\n  ) {\n    const lotId = position.lotId;\n    const priceChange = ((currentPrice - position.entryPrice) / position.entryPrice) * 100;\n\n    if (currentPrice > position.highestPrice) {\n      position.highestPrice = currentPrice;\n      this.openPositions.set(lotId, position);\n      await this.updatePositionHighestPriceByLotId(lotId, currentPrice);\n    }\n\n    // Check if this is a SMART_GUARD position - use dedicated logic\n    if (position.entryMode === \"SMART_GUARD\" && position.configSnapshot) {\n      await this.checkSmartGuardExit(pair, position, currentPrice, priceChange);\n      return;\n    }\n\n    // Use snapshot params if available (new positions), else use current config (legacy)\n    let effectiveSL: number;\n    let effectiveTP: number;\n    let effectiveTrailingEnabled: boolean;\n    let effectiveTrailingPct: number;\n    let paramsSource: string;\n\n    if (position.configSnapshot) {\n      effectiveSL = position.configSnapshot.stopLossPercent;\n      effectiveTP = position.configSnapshot.takeProfitPercent;\n      effectiveTrailingEnabled = position.configSnapshot.trailingStopEnabled;\n      effectiveTrailingPct = position.configSnapshot.trailingStopPercent;\n      paramsSource = `snapshot (${position.entryMode})`;\n    } else {\n      effectiveSL = stopLossPercent;\n      effectiveTP = takeProfitPercent;\n      effectiveTrailingEnabled = trailingStopEnabled;\n      effectiveTrailingPct = trailingStopPercent;\n      paramsSource = \"current config (legacy)\";\n    }\n\n    let shouldSell = false;\n    let reason = \"\";\n    let emoji = \"\";\n\n    if (priceChange <= -effectiveSL) {\n      shouldSell = true;\n      reason = `Stop-Loss activado (${priceChange.toFixed(2)}% < -${effectiveSL}%) [${paramsSource}]`;\n      emoji = \"ğŸ›‘\";\n      this.setStopLossCooldown(pair);\n      await botLogger.warn(\"STOP_LOSS_HIT\", `Stop-Loss activado en ${pair}`, {\n        pair,\n        lotId,\n        entryPrice: position.entryPrice,\n        currentPrice,\n        priceChange,\n        stopLossPercent: effectiveSL,\n        paramsSource,\n        cooldownMinutes: POST_STOPLOSS_COOLDOWN_MS / 60000,\n      });\n    }\n    else if (priceChange >= effectiveTP) {\n      shouldSell = true;\n      reason = `Take-Profit activado (${priceChange.toFixed(2)}% > ${effectiveTP}%) [${paramsSource}]`;\n      emoji = \"ğŸ¯\";\n      await botLogger.info(\"TAKE_PROFIT_HIT\", `Take-Profit alcanzado en ${pair}`, {\n        pair,\n        lotId,\n        entryPrice: position.entryPrice,\n        currentPrice,\n        priceChange,\n        takeProfitPercent: effectiveTP,\n        paramsSource,\n      });\n    }\n    else if (effectiveTrailingEnabled && position.highestPrice > position.entryPrice) {\n      const dropFromHigh = ((position.highestPrice - currentPrice) / position.highestPrice) * 100;\n      if (dropFromHigh >= effectiveTrailingPct && priceChange > 0) {\n        shouldSell = true;\n        reason = `Trailing Stop activado (cayÃ³ ${dropFromHigh.toFixed(2)}% desde mÃ¡ximo $${position.highestPrice.toFixed(2)}) [${paramsSource}]`;\n        emoji = \"ğŸ“‰\";\n        await botLogger.info(\"TRAILING_STOP_HIT\", `Trailing Stop activado en ${pair}`, {\n          pair,\n          lotId,\n          entryPrice: position.entryPrice,\n          highestPrice: position.highestPrice,\n          currentPrice,\n          dropFromHigh,\n          trailingStopPercent: effectiveTrailingPct,\n          paramsSource,\n        });\n      }\n    }\n\n    if (shouldSell) {\n      const minVolume = this.getOrderMin(pair);\n      const sellAmount = position.amount;\n\n      if (sellAmount < minVolume) {\n        log(`Cantidad a vender (${sellAmount}) menor al mÃ­nimo de Kraken (${minVolume}) para ${pair} (${lotId})`, \"trading\");\n        return;\n      }\n\n      // VERIFICACIÃ“N DE BALANCE REAL: Evitar \"EOrder:Insufficient funds\"\n      const freshBalances = await this.krakenService.getBalance();\n      const realAssetBalance = this.getAssetBalance(pair, freshBalances);\n      \n      // Si el balance real es menor al 99.5% del esperado (tolerancia para fees ~0.26%)\n      if (realAssetBalance < sellAmount * 0.995) {\n        log(`âš ï¸ Discrepancia de balance en ${pair} (${lotId}): Registrado ${sellAmount}, Real ${realAssetBalance}`, \"trading\");\n        \n        // Si balance real es prÃ¡cticamente cero (< mÃ­nimo de Kraken), eliminar posiciÃ³n\n        if (realAssetBalance < minVolume) {\n          log(`PosiciÃ³n huÃ©rfana eliminada en ${pair} (${lotId}): balance real (${realAssetBalance}) < mÃ­nimo (${minVolume})`, \"trading\");\n          \n          // NO modificar dailyPnL: si fue vendida manualmente, el usuario ya tiene el USD\n          // Pero SÃ debemos reconciliar exposure y cooldowns\n          \n          // Refrescar balance USD para tener mÃ©tricas consistentes\n          this.currentUsdBalance = parseFloat(freshBalances?.ZUSD || freshBalances?.USD || \"0\");\n          \n          this.openPositions.delete(lotId);\n          await this.deletePositionFromDBByLotId(lotId);\n          \n          // Limpiar cooldowns obsoletos y establecer uno nuevo (15 min)\n          this.stopLossCooldowns.delete(pair);\n          this.lastExposureAlert.delete(pair);\n          this.setPairCooldown(pair);\n          this.lastTradeTime.set(pair, Date.now());\n          \n          if (this.telegramService.isInitialized()) {\n            await this.telegramService.sendMessage(`ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ”„ <b>PosiciÃ³n HuÃ©rfana Eliminada</b>\n\nğŸ“¦ <b>Detalles:</b>\n   â€¢ Par: <code>${pair}</code>\n   â€¢ Lot: <code>${lotId}</code>\n   â€¢ Registrada: <code>${sellAmount.toFixed(8)}</code>\n   â€¢ Real en Kraken: <code>${realAssetBalance.toFixed(8)}</code>\n\nâš ï¸ La posiciÃ³n no existe en Kraken y fue eliminada.\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);\n          }\n          \n          await botLogger.warn(\"ORPHAN_POSITION_CLEANED\", `PosiciÃ³n huÃ©rfana eliminada en ${pair}`, {\n            pair,\n            lotId,\n            registeredAmount: sellAmount,\n            realBalance: realAssetBalance,\n            newUsdBalance: this.currentUsdBalance,\n          });\n          return;\n        }\n        \n        // Si hay algo de balance pero menos del registrado, ajustar posiciÃ³n al real\n        log(`Ajustando posiciÃ³n ${pair} (${lotId}) de ${sellAmount} a ${realAssetBalance}`, \"trading\");\n        position.amount = realAssetBalance;\n        this.openPositions.set(lotId, position);\n        await this.savePositionToDB(pair, position);\n        \n        // Notificar ajuste\n        if (this.telegramService.isInitialized()) {\n          await this.telegramService.sendMessage(`ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ”§ <b>PosiciÃ³n Ajustada</b>\n\nğŸ“¦ <b>Detalles:</b>\n   â€¢ Par: <code>${pair}</code>\n   â€¢ Lot: <code>${lotId}</code>\n   â€¢ Cantidad anterior: <code>${sellAmount.toFixed(8)}</code>\n   â€¢ Cantidad real: <code>${realAssetBalance.toFixed(8)}</code>\n\nâ„¹ï¸ Se usarÃ¡ la cantidad real para la venta.\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);\n        }\n        \n        // Continuar con la venta usando el balance real\n      }\n\n      log(`${emoji} ${reason} para ${pair} (${lotId})`, \"trading\");\n\n      // Usar position.amount (puede haber sido ajustado al balance real)\n      const actualSellAmount = position.amount;\n      const pnl = (currentPrice - position.entryPrice) * actualSellAmount;\n      const pnlPercent = priceChange;\n\n      const sellContext = { entryPrice: position.entryPrice, aiSampleId: position.aiSampleId };\n      const success = await this.executeTrade(pair, \"sell\", actualSellAmount.toFixed(8), currentPrice, reason, undefined, undefined, undefined, sellContext);\n      \n      if (success && this.telegramService.isInitialized()) {\n        const pnlEmoji = pnl >= 0 ? \"ğŸ“ˆ\" : \"ğŸ“‰\";\n        await this.telegramService.sendAlertToMultipleChats(`ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n${emoji} <b>${reason}</b>\n\nğŸ“¦ <b>Detalles:</b>\n   â€¢ Par: <code>${pair}</code>\n   â€¢ Lot: <code>${lotId}</code>\n   â€¢ Precio entrada: <code>$${position.entryPrice.toFixed(2)}</code>\n   â€¢ Precio actual: <code>$${currentPrice.toFixed(2)}</code>\n   â€¢ Cantidad vendida: <code>${actualSellAmount.toFixed(8)}</code>\n\n${pnlEmoji} <b>P&L:</b> <code>${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)} (${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%)</code>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, \"trades\");\n      }\n\n      if (success) {\n        this.openPositions.delete(lotId);\n        await this.deletePositionFromDBByLotId(lotId);\n        this.lastTradeTime.set(pair, Date.now());\n      }\n    }\n  }\n\n  private async checkSmartGuardExit(\n    pair: string,\n    position: OpenPosition,\n    currentPrice: number,\n    priceChange: number\n  ) {\n    const snapshot = position.configSnapshot!;\n    const paramsSource = `SMART_GUARD snapshot`;\n    \n    // Get snapshot params with defaults\n    const beAtPct = snapshot.sgBeAtPct ?? 1.5;\n    const feeCushionPct = snapshot.sgFeeCushionPct ?? 0.45;\n    const trailStartPct = snapshot.sgTrailStartPct ?? 2.0;\n    const trailDistancePct = snapshot.sgTrailDistancePct ?? 1.5;\n    const trailStepPct = snapshot.sgTrailStepPct ?? 0.25;\n    const tpFixedEnabled = snapshot.sgTpFixedEnabled ?? false;\n    const tpFixedPct = snapshot.sgTpFixedPct ?? 10;\n    const scaleOutEnabled = snapshot.sgScaleOutEnabled ?? false;\n    const scaleOutPct = snapshot.sgScaleOutPct ?? 35;\n    const minPartUsd = snapshot.sgMinPartUsd ?? 50;\n    const scaleOutThreshold = snapshot.sgScaleOutThreshold ?? 80;\n    \n    // Also use the standard SL from snapshot as ultimate protection\n    const ultimateSL = snapshot.stopLossPercent;\n    \n    let shouldSellFull = false;\n    let shouldScaleOut = false;\n    let sellReason = \"\";\n    let emoji = \"\";\n    let positionModified = false;\n    \n    // Calculate break-even price (entry + fee cushion)\n    const breakEvenPrice = position.entryPrice * (1 + feeCushionPct / 100);\n    \n    // 1. ULTIMATE STOP-LOSS - Emergency exit (always active)\n    if (priceChange <= -ultimateSL) {\n      shouldSellFull = true;\n      sellReason = `Stop-Loss emergencia SMART_GUARD (${priceChange.toFixed(2)}% < -${ultimateSL}%) [${paramsSource}]`;\n      emoji = \"ğŸ›‘\";\n      this.setStopLossCooldown(pair);\n      await botLogger.warn(\"SG_EMERGENCY_STOPLOSS\", `SMART_GUARD Stop-Loss emergencia en ${pair}`, {\n        pair, entryPrice: position.entryPrice, currentPrice, priceChange, ultimateSL, paramsSource,\n      });\n    }\n    \n    // 2. FIXED TAKE-PROFIT (if enabled)\n    else if (tpFixedEnabled && priceChange >= tpFixedPct) {\n      shouldSellFull = true;\n      sellReason = `Take-Profit fijo SMART_GUARD (${priceChange.toFixed(2)}% >= ${tpFixedPct}%) [${paramsSource}]`;\n      emoji = \"ğŸ¯\";\n      await botLogger.info(\"SG_TP_FIXED\", `SMART_GUARD TP fijo alcanzado en ${pair}`, {\n        pair, entryPrice: position.entryPrice, currentPrice, priceChange, tpFixedPct, paramsSource,\n      });\n    }\n    \n    // 3. BREAK-EVEN ACTIVATION - Move stop to breakeven when profit >= beAtPct\n    else if (!position.sgBreakEvenActivated && priceChange >= beAtPct) {\n      position.sgBreakEvenActivated = true;\n      position.sgCurrentStopPrice = breakEvenPrice;\n      positionModified = true;\n      log(`SMART_GUARD ${pair}: Break-even activado (+${priceChange.toFixed(2)}%), stop movido a $${breakEvenPrice.toFixed(4)}`, \"trading\");\n      \n      // Send alert (only once per lot, no throttle needed as flag prevents re-entry)\n      if (this.shouldSendSgAlert(position.lotId, \"SG_BREAK_EVEN_ACTIVATED\")) {\n        await this.sendSgEventAlert(\"SG_BREAK_EVEN_ACTIVATED\", position, currentPrice, {\n          stopPrice: breakEvenPrice,\n          profitPct: priceChange,\n          reason: `Profit +${beAtPct}% alcanzado, stop movido a break-even + comisiones`,\n        });\n      }\n    }\n    \n    // 4. TRAILING STOP ACTIVATION - Start trailing when profit >= trailStartPct\n    if (!position.sgTrailingActivated && priceChange >= trailStartPct) {\n      position.sgTrailingActivated = true;\n      const trailStopPrice = currentPrice * (1 - trailDistancePct / 100);\n      // Only update stop if higher than current\n      if (!position.sgCurrentStopPrice || trailStopPrice > position.sgCurrentStopPrice) {\n        position.sgCurrentStopPrice = trailStopPrice;\n      }\n      positionModified = true;\n      log(`SMART_GUARD ${pair}: Trailing activado (+${priceChange.toFixed(2)}%), stop dinÃ¡mico @ $${position.sgCurrentStopPrice!.toFixed(4)}`, \"trading\");\n      \n      // Send alert (only once per lot)\n      if (this.shouldSendSgAlert(position.lotId, \"SG_TRAILING_ACTIVATED\")) {\n        await this.sendSgEventAlert(\"SG_TRAILING_ACTIVATED\", position, currentPrice, {\n          stopPrice: position.sgCurrentStopPrice,\n          profitPct: priceChange,\n          reason: `Profit +${trailStartPct}% alcanzado, trailing stop iniciado a ${trailDistancePct}% del mÃ¡ximo`,\n        });\n      }\n    }\n    \n    // 5. TRAILING STOP UPDATE - Ratchet up stop with step increments\n    if (position.sgTrailingActivated && position.sgCurrentStopPrice) {\n      const newTrailStop = currentPrice * (1 - trailDistancePct / 100);\n      const minStepPrice = position.sgCurrentStopPrice * (1 + trailStepPct / 100);\n      \n      // Only update if new stop is higher by at least one step\n      if (newTrailStop > minStepPrice) {\n        const oldStop = position.sgCurrentStopPrice;\n        position.sgCurrentStopPrice = newTrailStop;\n        positionModified = true;\n        log(`SMART_GUARD ${pair}: Trailing step $${oldStop.toFixed(4)} â†’ $${newTrailStop.toFixed(4)} (+${trailStepPct}%)`, \"trading\");\n        \n        // Send alert with throttle (max 1 per 5 min)\n        if (this.shouldSendSgAlert(position.lotId, \"SG_TRAILING_STOP_UPDATED\", this.SG_TRAIL_UPDATE_THROTTLE_MS)) {\n          await this.sendSgEventAlert(\"SG_TRAILING_STOP_UPDATED\", position, currentPrice, {\n            stopPrice: newTrailStop,\n            profitPct: priceChange,\n            reason: `Stop actualizado: $${oldStop.toFixed(2)} â†’ $${newTrailStop.toFixed(2)}`,\n          });\n        }\n      }\n    }\n    \n    // 6. CHECK IF STOP PRICE HIT\n    if (position.sgCurrentStopPrice && currentPrice <= position.sgCurrentStopPrice) {\n      const stopType = position.sgTrailingActivated ? \"Trailing Stop\" : \"Break-even Stop\";\n      shouldSellFull = true;\n      sellReason = `${stopType} SMART_GUARD ($${currentPrice.toFixed(2)} <= $${position.sgCurrentStopPrice.toFixed(2)}) [${paramsSource}]`;\n      emoji = position.sgTrailingActivated ? \"ğŸ“‰\" : \"âš–ï¸\";\n      await botLogger.info(\"SG_STOP_HIT\", `SMART_GUARD ${stopType} activado en ${pair}`, {\n        pair, entryPrice: position.entryPrice, currentPrice, stopPrice: position.sgCurrentStopPrice,\n        stopType, paramsSource,\n      });\n    }\n    \n    // 7. SCALE-OUT (optional, only if exceptional signal)\n    if (!shouldSellFull && scaleOutEnabled && !position.sgScaleOutDone) {\n      // Only scale out if signal confidence >= threshold and part is worth selling\n      const partValue = position.amount * currentPrice * (scaleOutPct / 100);\n      const confPct = toConfidencePct(position.signalConfidence, 0);\n      const thresholdPct = toConfidencePct(scaleOutThreshold, 80);\n      if (confPct >= thresholdPct && partValue >= minPartUsd) {\n        if (priceChange >= trailStartPct) { // Only scale out in profit\n          shouldScaleOut = true;\n          sellReason = `Scale-out SMART_GUARD (${scaleOutPct}% @ +${priceChange.toFixed(2)}%, conf=${confPct.toFixed(0)}%) [${paramsSource}]`;\n          emoji = \"ğŸ“Š\";\n          position.sgScaleOutDone = true;\n          positionModified = true;\n          \n          // Send alert (only once as sgScaleOutDone flag prevents re-entry)\n          if (this.shouldSendSgAlert(position.lotId, \"SG_SCALE_OUT_EXECUTED\")) {\n            await this.sendSgEventAlert(\"SG_SCALE_OUT_EXECUTED\", position, currentPrice, {\n              profitPct: priceChange,\n              reason: `Vendido ${scaleOutPct}% de posiciÃ³n ($${partValue.toFixed(2)}) a +${priceChange.toFixed(2)}%`,\n            });\n          }\n        }\n      }\n    }\n    \n    const lotId = position.lotId;\n    \n    // Save position changes\n    if (positionModified && !shouldSellFull && !shouldScaleOut) {\n      this.openPositions.set(lotId, position);\n      await this.savePositionToDB(pair, position);\n    }\n    \n    // Execute sell if needed\n    if (shouldSellFull || shouldScaleOut) {\n      const minVolume = this.getOrderMin(pair);\n      let sellAmount = shouldScaleOut \n        ? position.amount * (scaleOutPct / 100)\n        : position.amount;\n      \n      if (sellAmount < minVolume) {\n        log(`SMART_GUARD: Cantidad a vender (${sellAmount}) menor al mÃ­nimo (${minVolume}) para ${pair} (${lotId})`, \"trading\");\n        return;\n      }\n      \n      // Balance verification\n      const freshBalances = await this.krakenService.getBalance();\n      const realAssetBalance = this.getAssetBalance(pair, freshBalances);\n      \n      if (realAssetBalance < sellAmount * 0.995) {\n        if (realAssetBalance < minVolume) {\n          log(`SMART_GUARD: PosiciÃ³n huÃ©rfana en ${pair} (${lotId}), eliminando`, \"trading\");\n          this.openPositions.delete(lotId);\n          await this.deletePositionFromDBByLotId(lotId);\n          this.setPairCooldown(pair);\n          return;\n        }\n        sellAmount = realAssetBalance;\n        position.amount = realAssetBalance;\n      }\n      \n      log(`${emoji} ${sellReason} para ${pair} (${lotId})`, \"trading\");\n      \n      const pnl = (currentPrice - position.entryPrice) * sellAmount;\n      const sellContext = { entryPrice: position.entryPrice, aiSampleId: position.aiSampleId };\n      const success = await this.executeTrade(pair, \"sell\", sellAmount.toFixed(8), currentPrice, sellReason, undefined, undefined, undefined, sellContext);\n      \n      if (success && this.telegramService.isInitialized()) {\n        const pnlEmoji = pnl >= 0 ? \"ğŸ“ˆ\" : \"ğŸ“‰\";\n        await this.telegramService.sendAlertToMultipleChats(`ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n${emoji} <b>${sellReason}</b>\n\nğŸ“¦ <b>Detalles:</b>\n   â€¢ Par: <code>${pair}</code>\n   â€¢ Lot: <code>${lotId}</code>\n   â€¢ Precio entrada: <code>$${position.entryPrice.toFixed(2)}</code>\n   â€¢ Precio actual: <code>$${currentPrice.toFixed(2)}</code>\n   â€¢ Cantidad vendida: <code>${sellAmount.toFixed(8)}</code>\n\n${pnlEmoji} <b>P&L:</b> <code>${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)} (${priceChange >= 0 ? '+' : ''}${priceChange.toFixed(2)}%)</code>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, \"trades\");\n      }\n      \n      if (success) {\n        // Reduce position amount by what was sold\n        position.amount -= sellAmount;\n        \n        // Use epsilon comparison for floating-point safety (treat < 0.00000001 as zero)\n        const EPSILON = 1e-8;\n        const positionIsEmpty = shouldSellFull || position.amount < EPSILON;\n        \n        if (positionIsEmpty) {\n          this.openPositions.delete(lotId);\n          await this.deletePositionFromDBByLotId(lotId);\n          log(`SMART_GUARD ${pair} (${lotId}): PosiciÃ³n cerrada completamente`, \"trading\");\n        } else {\n          // Partial sell (scale-out) - save reduced position\n          this.openPositions.set(lotId, position);\n          await this.savePositionToDB(pair, position);\n          log(`SMART_GUARD ${pair} (${lotId}): Venta parcial, restante: ${position.amount.toFixed(8)}`, \"trading\");\n        }\n        this.lastTradeTime.set(pair, Date.now());\n      }\n    }\n  }\n\n  private async analyzePairAndTrade(\n    pair: string,\n    strategy: string,\n    riskConfig: RiskConfig,\n    balances: any\n  ) {\n    try {\n      const lastTrade = this.lastTradeTime.get(pair) || 0;\n      if (Date.now() - lastTrade < this.MIN_TRADE_INTERVAL_MS) {\n        return;\n      }\n\n      const krakenPair = this.formatKrakenPair(pair);\n      const ticker = await this.krakenService.getTicker(krakenPair);\n      const tickerData: any = Object.values(ticker)[0];\n      \n      if (!tickerData) return;\n\n      const currentPrice = parseFloat(tickerData.c?.[0] || \"0\");\n      const high24h = parseFloat(tickerData.h?.[1] || tickerData.h?.[0] || \"0\");\n      const low24h = parseFloat(tickerData.l?.[1] || tickerData.l?.[0] || \"0\");\n      const volume = parseFloat(tickerData.v?.[1] || tickerData.v?.[0] || \"0\");\n\n      this.updatePriceHistory(pair, {\n        price: currentPrice,\n        timestamp: Date.now(),\n        high: high24h,\n        low: low24h,\n        volume,\n      });\n\n      const history = this.priceHistory.get(pair) || [];\n      if (history.length < 5) return;\n\n      const signal = await this.analyzeWithStrategy(strategy, pair, history, currentPrice);\n      \n      // Registrar resultado del escaneo\n      const signalStr = signal.action === \"hold\" ? \"NONE\" : signal.action.toUpperCase();\n      const botConfigForScan = await storage.getBotConfig();\n      const exposure = this.getAvailableExposure(pair, botConfigForScan, this.currentUsdBalance);\n      this.lastScanResults.set(pair, {\n        signal: signalStr,\n        reason: signal.reason || \"Sin seÃ±al\",\n        cooldownSec: this.getCooldownRemainingSec(pair),\n        exposureAvailable: exposure.maxAllowed,\n      });\n      \n      if (signal.action === \"hold\" || signal.confidence < 0.6) {\n        return;\n      }\n\n      const assetBalance = this.getAssetBalance(pair, balances);\n      const existingPositions = this.getPositionsByPair(pair);\n      const existingPosition = existingPositions[0];\n\n      if (signal.action === \"buy\") {\n        if (this.isPairInCooldown(pair)) {\n          const cooldownSec = this.getCooldownRemainingSec(pair);\n          await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al BUY ignorada - par en cooldown`, {\n            pair,\n            signal: \"BUY\",\n            reason: \"PAIR_COOLDOWN\",\n            cooldownRemainingSec: cooldownSec,\n            signalReason: signal.reason,\n          });\n          return;\n        }\n\n        // MODO SINGLE o SMART_GUARD: Bloquear compras si ya hay posiciÃ³n abierta\n        const botConfigCheck = await storage.getBotConfig();\n        const positionMode = botConfigCheck?.positionMode || \"SINGLE\";\n        const sgMaxLotsPerPair = botConfigCheck?.sgMaxOpenLotsPerPair ?? 1;\n        \n        // En SINGLE siempre 1 slot. En SMART_GUARD respetamos sgMaxOpenLotsPerPair.\n        const maxLotsForMode = positionMode === \"SMART_GUARD\" ? sgMaxLotsPerPair : 1;\n        const currentOpenLots = this.countLotsForPair(pair);\n        \n        if ((positionMode === \"SINGLE\" || positionMode === \"SMART_GUARD\") && currentOpenLots >= maxLotsForMode) {\n          const reasonCode = positionMode === \"SMART_GUARD\" \n            ? \"SMART_GUARD_MAX_LOTS_REACHED\" \n            : \"SINGLE_MODE_POSITION_EXISTS\";\n          \n          log(`${pair}: Compra bloqueada - Modo ${positionMode}, lotes abiertos ${currentOpenLots}/${maxLotsForMode}`, \"trading\");\n          await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al BUY ignorada - mÃ¡ximo de lotes alcanzado`, {\n            pair,\n            signal: \"BUY\",\n            reason: reasonCode,\n            currentOpenLots,\n            maxOpenLots: maxLotsForMode,\n            existingAmount: existingPosition?.amount || 0,\n            signalReason: signal.reason,\n          });\n          this.lastScanResults.set(pair, {\n            signal: \"BUY\",\n            reason: reasonCode,\n            exposureAvailable: 0,\n          });\n          return;\n        }\n\n        // B3: SMART_GUARD requiere â‰¥5 seÃ±ales para BUY (umbral mÃ¡s estricto)\n        if (positionMode === \"SMART_GUARD\") {\n          const signalCountMatch = signal.reason.match(/SeÃ±ales:\\s*(\\d+)\\/(\\d+)/);\n          if (signalCountMatch) {\n            const buySignalCount = parseInt(signalCountMatch[1], 10);\n            if (buySignalCount < 5) {\n              await botLogger.info(\"TRADE_SKIPPED\", `SMART_GUARD BUY bloqueado - seÃ±ales insuficientes (${buySignalCount} < 5)`, {\n                pair,\n                signal: \"BUY\",\n                reason: \"SMART_GUARD_INSUFFICIENT_SIGNALS\",\n                buySignalCount,\n                requiredSignals: 5,\n                signalReason: signal.reason,\n              });\n              return;\n            }\n          }\n        }\n\n        // MEJORA 4: Verificar cooldown post stop-loss\n        if (this.isPairInStopLossCooldown(pair)) {\n          const cooldownSec = this.getStopLossCooldownRemainingSec(pair);\n          log(`${pair}: En cooldown post stop-loss`, \"trading\");\n          await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al BUY ignorada - cooldown post stop-loss`, {\n            pair,\n            signal: \"BUY\",\n            reason: \"STOPLOSS_COOLDOWN\",\n            cooldownRemainingSec: cooldownSec,\n            signalReason: signal.reason,\n          });\n          return;\n        }\n\n        // MEJORA 1: Verificar spread antes de comprar\n        const spreadCheck = this.isSpreadAcceptable(tickerData);\n        if (!spreadCheck.acceptable) {\n          log(`${pair}: Spread demasiado alto (${spreadCheck.spreadPct.toFixed(3)}% > ${MAX_SPREAD_PCT}%)`, \"trading\");\n          await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al BUY ignorada - spread alto`, {\n            pair,\n            signal: \"BUY\",\n            reason: \"SPREAD_TOO_HIGH\",\n            spreadPct: spreadCheck.spreadPct,\n            maxSpreadPct: MAX_SPREAD_PCT,\n            signalReason: signal.reason,\n          });\n          return;\n        }\n\n        if (existingPosition && existingPosition.amount * currentPrice > riskConfig.maxTradeUSD * 2) {\n          log(`PosiciÃ³n existente en ${pair} ya es grande: $${(existingPosition.amount * currentPrice).toFixed(2)}`, \"trading\");\n          await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al BUY ignorada - posiciÃ³n existente demasiado grande`, {\n            pair,\n            signal: \"BUY\",\n            reason: \"POSITION_TOO_LARGE\",\n            currentPositionUsd: existingPosition.amount * currentPrice,\n            maxTradeUsd: riskConfig.maxTradeUSD * 2,\n          });\n          return;\n        }\n\n        const minVolume = this.getOrderMin(pair);\n        const minRequiredUSD = minVolume * currentPrice;\n        const freshUsdBalance = parseFloat(balances?.ZUSD || balances?.USD || \"0\");\n\n        if (freshUsdBalance < minRequiredUSD) {\n          log(`Saldo USD insuficiente para ${pair}: $${freshUsdBalance.toFixed(2)} < $${minRequiredUSD.toFixed(2)}`, \"trading\");\n          await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al BUY ignorada - fondos insuficientes`, {\n            pair,\n            signal: \"BUY\",\n            reason: \"INSUFFICIENT_FUNDS\",\n            availableUsd: freshUsdBalance,\n            minRequiredUsd: minRequiredUSD,\n          });\n          this.setPairCooldown(pair);\n          return;\n        }\n\n        const botConfig = await storage.getBotConfig();\n        const riskPerTradePct = parseFloat(botConfig?.riskPerTradePct?.toString() || \"15\");\n        const takeProfitPct = parseFloat(botConfig?.takeProfitPercent?.toString() || \"7\");\n        \n        // === CÃLCULO DE TAMAÃ‘O DE ORDEN (tradeAmountUSD) ===\n        // SMART_GUARD v2: sgMinEntryUsd es un \"objetivo preferido\", no un bloqueo\n        // - Si saldo >= sgMinEntryUsd â†’ usar sgMinEntryUsd exactamente (no mÃ¡s)\n        // - Si saldo < sgMinEntryUsd â†’ fallback automÃ¡tico a saldo disponible\n        // - floorUsd = max(exchangeMin, absoluteMin) â†’ hard block si saldo < floorUsd\n        let tradeAmountUSD: number;\n        let wasAdjusted = false;\n        let originalAmount: number;\n        let sgReasonCode: SmartGuardReasonCode | undefined;\n        \n        // Para SMART_GUARD: calcular orderUsdProposed por lÃ³gica normal, luego validar mÃ­nimos\n        const sgParams = positionMode === \"SMART_GUARD\" ? this.getSmartGuardParams(pair, botConfig) : null;\n        const sgMinEntryUsd = sgParams?.sgMinEntryUsd || 100;\n        const sgAllowUnderMin = sgParams?.sgAllowUnderMin ?? true; // DEPRECATED - se ignora\n        const sgFeeCushionPct = sgParams?.sgFeeCushionPct || 0;\n        const sgFeeCushionAuto = sgParams?.sgFeeCushionAuto ?? false;\n        \n        // Calcular fee cushion efectivo (auto = 2 * KRAKEN_FEE_PCT)\n        const effectiveCushionPct = sgFeeCushionAuto ? (KRAKEN_FEE_PCT * 2) : sgFeeCushionPct;\n        \n        // usdDisponible = saldo real disponible (sin buffer en SMART_GUARD v2 para sizing exacto)\n        const usdDisponible = freshUsdBalance;\n        \n        // === NUEVA LÃ“GICA SMART_GUARD v2 ===\n        // floorUsd = max(minOrderExchangeUsd, MIN_ORDER_ABSOLUTE_USD) - HARD BLOCK\n        const floorUsd = Math.max(SG_ABSOLUTE_MIN_USD, minRequiredUSD);\n        \n        // availableAfterCushion = saldo menos reserva para fees\n        const cushionAmount = freshUsdBalance * (effectiveCushionPct / 100);\n        const availableAfterCushion = usdDisponible - cushionAmount;\n        \n        if (positionMode === \"SMART_GUARD\") {\n          // === SMART_GUARD v2 SIZING ===\n          // Regla 1: sgMinEntryUsd es \"objetivo preferido\"\n          // Regla 2: Si saldo >= sgMinEntryUsd â†’ usar sgMinEntryUsd EXACTO\n          // Regla 3: Si saldo < sgMinEntryUsd â†’ fallback a saldo disponible (si >= floorUsd)\n          // Regla 4: Si saldo < floorUsd â†’ BLOQUEAR\n          \n          originalAmount = sgMinEntryUsd; // El objetivo propuesto siempre es sgMinEntryUsd\n          \n          if (availableAfterCushion >= sgMinEntryUsd) {\n            // Caso A: Saldo suficiente â†’ usar sgMinEntryUsd EXACTO (no mÃ¡s)\n            tradeAmountUSD = sgMinEntryUsd;\n            sgReasonCode = \"SMART_GUARD_ENTRY_USING_CONFIG_MIN\";\n            \n          } else if (availableAfterCushion >= floorUsd) {\n            // Caso B: Saldo insuficiente para config, pero >= floorUsd â†’ fallback automÃ¡tico\n            tradeAmountUSD = availableAfterCushion;\n            sgReasonCode = \"SMART_GUARD_ENTRY_FALLBACK_TO_AVAILABLE\";\n            \n          } else if (usdDisponible >= floorUsd && availableAfterCushion < floorUsd) {\n            // Caso C: Fee cushion lo baja de floorUsd â†’ se bloquearÃ¡ en validaciÃ³n\n            tradeAmountUSD = availableAfterCushion;\n            sgReasonCode = \"SMART_GUARD_BLOCKED_AFTER_FEE_CUSHION\";\n            \n          } else {\n            // Caso D: Saldo < floorUsd â†’ se bloquearÃ¡ en validaciÃ³n\n            tradeAmountUSD = usdDisponible;\n            sgReasonCode = \"SMART_GUARD_BLOCKED_BELOW_EXCHANGE_MIN\";\n          }\n          \n          log(`SMART_GUARD ${pair}: Sizing v2 - order=$${tradeAmountUSD.toFixed(2)}, reason=${sgReasonCode}`, \"trading\");\n          log(`  â†’ availableUsd=$${usdDisponible.toFixed(2)}, sgMinEntryUsd=$${sgMinEntryUsd.toFixed(2)}, floorUsd=$${floorUsd.toFixed(2)} [exch=$${minRequiredUSD.toFixed(2)}, abs=$${SG_ABSOLUTE_MIN_USD}]`, \"trading\");\n          log(`  â†’ cushionPct=${effectiveCushionPct.toFixed(2)}%, cushionAmt=$${cushionAmount.toFixed(2)}, availableAfterCushion=$${availableAfterCushion.toFixed(2)}`, \"trading\");\n          log(`  â†’ sgAllowUnderMin=${sgAllowUnderMin} (DEPRECATED - ignorado, siempre fallback automÃ¡tico)`, \"trading\");\n          \n          // La validaciÃ³n final de mÃ­nimos se hace DESPUÃ‰S con validateMinimumsOrSkip()\n        } else {\n          // Modos SINGLE/DCA: lÃ³gica original con exposure limits\n          \n          // Verificar que el take-profit sea rentable despuÃ©s de comisiones\n          const profitCheck = this.isProfitableAfterFees(takeProfitPct);\n          if (!profitCheck.isProfitable) {\n            log(`${pair}: Trade rechazado - Take-Profit (${takeProfitPct}%) < mÃ­nimo rentable (${profitCheck.minProfitRequired.toFixed(2)}%). Fees round-trip: ${profitCheck.roundTripFees.toFixed(2)}%`, \"trading\");\n            \n            await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al BUY ignorada - take-profit menor que fees`, {\n              pair,\n              signal: \"BUY\",\n              reason: \"LOW_PROFITABILITY\",\n              takeProfitPct,\n              roundTripFees: profitCheck.roundTripFees,\n              minProfitRequired: profitCheck.minProfitRequired,\n              netExpectedProfit: profitCheck.netExpectedProfit,\n            });\n            \n            return;\n          }\n          \n          tradeAmountUSD = freshUsdBalance * (riskPerTradePct / 100);\n          tradeAmountUSD = Math.min(tradeAmountUSD, riskConfig.maxTradeUSD);\n\n          // MEJORA 3: Position sizing dinÃ¡mico basado en confianza\n          const confidenceFactor = this.getConfidenceSizingFactor(signal.confidence);\n          const originalBeforeConfidence = tradeAmountUSD;\n          tradeAmountUSD = tradeAmountUSD * confidenceFactor;\n          \n          if (confidenceFactor < 1.0) {\n            const confPct = toConfidencePct(signal.confidence, 0);\n            const factorPct = Math.round(confidenceFactor * 100);\n            log(`${pair}: Sizing ajustado por confianza (${confPct.toFixed(0)}%): $${originalBeforeConfidence.toFixed(2)} -> $${tradeAmountUSD.toFixed(2)} (${factorPct}%)`, \"trading\");\n          }\n\n          if (tradeAmountUSD < minRequiredUSD && freshUsdBalance >= minRequiredUSD) {\n            const smallAccountAmount = freshUsdBalance * SMALL_ACCOUNT_FACTOR;\n            tradeAmountUSD = Math.min(smallAccountAmount, riskConfig.maxTradeUSD);\n          }\n          \n          originalAmount = tradeAmountUSD;\n        }\n\n        const exposure = this.getAvailableExposure(pair, botConfig, freshUsdBalance);\n        const maxByBalance = Math.max(0, freshUsdBalance * 0.95);\n        // POLÃTICA UNIFICADA: SMART_GUARD SÃ respeta maxTotalExposurePct para evitar sobreapalancamiento\n        // Pero NO aplica maxPairExposurePct (permite concentraciÃ³n en un par si hay seÃ±al fuerte)\n        const effectiveMaxAllowed = positionMode === \"SMART_GUARD\" \n          ? Math.min(exposure.maxTotalAvailable, maxByBalance)  // Solo limita por exposiciÃ³n TOTAL\n          : Math.min(exposure.maxAllowed, maxByBalance);  // SINGLE/DCA limita por par Y total\n        \n        if (effectiveMaxAllowed < minRequiredUSD) {\n          log(`${pair}: Sin exposiciÃ³n disponible. Disponible: $${effectiveMaxAllowed.toFixed(2)}, MÃ­nimo: $${minRequiredUSD.toFixed(2)}`, \"trading\");\n          await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al BUY ignorada - sin exposiciÃ³n disponible`, {\n            pair,\n            signal: \"BUY\",\n            reason: \"EXPOSURE_ZERO\",\n            exposureAvailable: effectiveMaxAllowed,\n            minRequiredUsd: minRequiredUSD,\n          });\n          this.setPairCooldown(pair);\n          \n          if (this.shouldSendExposureAlert(pair)) {\n            await botLogger.info(\"PAIR_COOLDOWN\", `${pair} en cooldown - sin exposiciÃ³n disponible`, {\n              pair,\n              maxAllowed: effectiveMaxAllowed,\n              minRequired: minRequiredUSD,\n              cooldownMinutes: this.COOLDOWN_DURATION_MS / 60000,\n            });\n\n            if (this.telegramService.isInitialized()) {\n              await this.telegramService.sendAlertToMultipleChats(`ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâ¸ï¸ <b>Par en Espera</b>\n\nğŸ“¦ <b>Detalles:</b>\n   â€¢ Par: <code>${pair}</code>\n   â€¢ Disponible: <code>$${exposure.maxAllowed.toFixed(2)}</code>\n   â€¢ MÃ­nimo requerido: <code>$${minRequiredUSD.toFixed(2)}</code>\n\nâ„¹ï¸ Cooldown: ${this.COOLDOWN_DURATION_MS / 60000} min\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, \"system\");\n            }\n          }\n          return;\n        }\n\n        // Ajustar por lÃ­mite de exposiciÃ³n (solo para SINGLE/DCA, SMART_GUARD ya validÃ³ arriba)\n        if (positionMode !== \"SMART_GUARD\" && tradeAmountUSD > effectiveMaxAllowed) {\n          originalAmount = tradeAmountUSD;\n          tradeAmountUSD = effectiveMaxAllowed;\n          wasAdjusted = true;\n          \n          log(`${pair}: Trade ajustado de $${originalAmount.toFixed(2)} a $${tradeAmountUSD.toFixed(2)} (lÃ­mite exposiciÃ³n)`, \"trading\");\n          \n          await botLogger.info(\"TRADE_ADJUSTED\", `Trade ajustado por lÃ­mite de exposiciÃ³n`, {\n            pair,\n            originalAmountUsd: originalAmount,\n            adjustedAmountUsd: tradeAmountUSD,\n            maxPairAvailable: exposure.maxPairAvailable,\n            maxTotalAvailable: exposure.maxTotalAvailable,\n            riskPerTradePct,\n          });\n        }\n\n        const tradeVolume = tradeAmountUSD / currentPrice;\n\n        if (tradeVolume < minVolume) {\n          log(`${pair}: Volumen ${tradeVolume.toFixed(8)} < mÃ­nimo ${minVolume}`, \"trading\");\n          await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al BUY ignorada - volumen < mÃ­nimo`, {\n            pair,\n            signal: \"BUY\",\n            reason: \"VOLUME_BELOW_MINIMUM\",\n            calculatedVolume: tradeVolume,\n            minVolume,\n          });\n          this.setPairCooldown(pair);\n          return;\n        }\n\n        // === VALIDACIÃ“N FINAL ÃšNICA Y CENTRALIZADA (fuente de verdad) ===\n        // Se ejecuta ANTES de executeTrade() para REAL y DRY_RUN\n        const orderUsdFinal = tradeAmountUSD;\n        const envPrefix = environment.isReplit ? \"REPLIT/DEV\" : \"NAS/PROD\";\n        const currentOpenLotsForLog = this.countLotsForPair(pair);\n        const sgMaxLotsPerPairConfig = botConfig?.sgMaxOpenLotsPerPair ?? 1;\n        const maxLotsForModeConfig = positionMode === \"SMART_GUARD\" ? sgMaxLotsPerPairConfig : 1;\n        \n        const validationResult = validateMinimumsOrSkip({\n          positionMode,\n          orderUsdFinal,\n          orderUsdProposed: originalAmount || tradeAmountUSD,\n          usdDisponible: freshUsdBalance,\n          exposureAvailable: effectiveMaxAllowed,\n          pair,\n          sgMinEntryUsd,\n          sgAllowUnderMin, // DEPRECATED - se ignora en validaciÃ³n\n          dryRun: this.dryRunMode,\n          env: envPrefix,\n          floorUsd: positionMode === \"SMART_GUARD\" ? floorUsd : undefined,\n          availableAfterCushion: positionMode === \"SMART_GUARD\" ? availableAfterCushion : undefined,\n        });\n        \n        if (!validationResult.valid) {\n          // === [BUY_EVAL] LOGS v2: Valores detallados para auditorÃ­a ===\n          log(`[BUY_EVAL] ${pair}: mode=${positionMode}, sgReasonCode=${sgReasonCode}`, \"trading\");\n          log(`[BUY_EVAL] ${pair}: availableUsd=$${usdDisponible.toFixed(2)}, sgMinEntryUsd=$${sgMinEntryUsd.toFixed(2)}, floorUsd=$${floorUsd.toFixed(2)}`, \"trading\");\n          log(`[BUY_EVAL] ${pair}: orderUsd=$${orderUsdFinal.toFixed(2)}, availableAfterCushion=$${availableAfterCushion.toFixed(2)}`, \"trading\");\n          log(`[BUY_EVAL] ${pair}: currentOpenLots=${currentOpenLotsForLog}/${maxLotsForModeConfig}`, \"trading\");\n          log(`[BUY_EVAL] ${pair}: DECISION skipReason=${validationResult.skipReason} msg=${validationResult.message}`, \"trading\");\n          log(`[FINAL CHECK] ${pair}: SKIP - ${validationResult.message}`, \"trading\");\n          \n          this.lastScanResults.set(pair, {\n            signal: \"BUY\",\n            reason: validationResult.skipReason!,\n            exposureAvailable: orderUsdFinal,\n          });\n          \n          await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al BUY bloqueada - ${validationResult.skipReason}`, {\n            pair,\n            signal: \"BUY\",\n            reason: validationResult.skipReason,\n            sgReasonCode,\n            ...validationResult.meta,\n          });\n          \n          this.setPairCooldown(pair);\n          return;\n        }\n        \n        // Log de decisiÃ³n final antes de ejecutar (con nuevo reason code)\n        if (positionMode === \"SMART_GUARD\" && sgReasonCode) {\n          log(`[FINAL CHECK] ${pair}: ALLOWED - ${sgReasonCode} orderUsd=$${orderUsdFinal.toFixed(2)}`, \"trading\");\n        }\n\n        if (wasAdjusted) {\n          log(`${pair}: Ejecutando compra AJUSTADA $${tradeAmountUSD.toFixed(2)} (original: $${originalAmount.toFixed(2)})`, \"trading\");\n        } else {\n          log(`${pair}: Ejecutando compra $${tradeAmountUSD.toFixed(2)} (${riskPerTradePct}% de $${freshUsdBalance.toFixed(2)})`, \"trading\");\n        }\n\n        const adjustmentInfo = wasAdjusted ? {\n          wasAdjusted: true,\n          originalAmountUsd: originalAmount,\n          adjustedAmountUsd: tradeAmountUSD\n        } : undefined;\n        \n        // Meta completa para trazabilidad v2\n        const executionMeta = {\n          mode: positionMode,\n          usdDisponible: freshUsdBalance,\n          orderUsdProposed: originalAmount || tradeAmountUSD,\n          orderUsdFinal,\n          sgMinEntryUsd,\n          floorUsd,\n          availableAfterCushion,\n          sgReasonCode,\n          sgAllowUnderMin_DEPRECATED: sgAllowUnderMin,\n          dryRun: this.dryRunMode,\n          env: envPrefix,\n        };\n\n        const success = await this.executeTrade(pair, \"buy\", tradeVolume.toFixed(8), currentPrice, signal.reason, adjustmentInfo, undefined, executionMeta);\n        if (success) {\n          this.lastTradeTime.set(pair, Date.now());\n        }\n\n      } else if (signal.action === \"sell\") {\n        // A1: SMART_GUARD bloquea SELL por seÃ±al - solo risk exits permiten vender\n        // EXCEPCIÃ“N: Permitir liquidaciÃ³n de huÃ©rfanos (balance > 0 sin posiciÃ³n trackeada)\n        const botConfigSell = await storage.getBotConfig();\n        const positionModeSell = botConfigSell?.positionMode || \"SINGLE\";\n        const isOrphanCleanup = assetBalance > 0 && (!existingPosition || existingPosition.amount <= 0);\n        \n        if (positionModeSell === \"SMART_GUARD\" && !isOrphanCleanup) {\n          await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al SELL bloqueada en SMART_GUARD - solo risk exits permiten vender`, {\n            pair,\n            signal: \"SELL\",\n            reason: \"SMART_GUARD_SIGNAL_SELL_BLOCKED\",\n            signalReason: signal.reason,\n          });\n          return;\n        }\n\n        if (assetBalance <= 0 && (!existingPosition || existingPosition.amount <= 0)) {\n          await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al SELL ignorada - sin posiciÃ³n para vender`, {\n            pair,\n            signal: \"SELL\",\n            reason: \"NO_POSITION\",\n            assetBalance,\n            signalReason: signal.reason,\n          });\n          return;\n        }\n\n        // === FIX: Vender lote completo, no 50% ===\n        // Usar min(lot.amount, realAssetBalance) para evitar insufficient funds\n        // Si no hay lot trackeado, usar balance real del wallet\n        const lotAmount = existingPosition?.amount ?? assetBalance;\n        const realAssetBalance = assetBalance;\n        const rawSellVolume = Math.min(lotAmount, realAssetBalance);\n        \n        // Normalizar al stepSize de Kraken para evitar errores de precisiÃ³n\n        const sellVolume = this.normalizeVolume(pair, rawSellVolume);\n        \n        const minVolumeSell = this.getOrderMin(pair);\n        const sellValueUsd = sellVolume * currentPrice;\n\n        // === DUST DETECTION: No intentar vender si es dust ===\n        if (sellVolume < minVolumeSell) {\n          await botLogger.info(\"TRADE_SKIPPED\", `SELL skipped - dust position (volumen < mÃ­nimo)`, {\n            pair,\n            signal: \"SELL\",\n            reason: \"DUST_POSITION\",\n            lotAmount,\n            realAssetBalance,\n            sellVolume,\n            minVolume: minVolumeSell,\n            sellValueUsd,\n            signalReason: signal.reason,\n          });\n          return;\n        }\n        \n        if (sellValueUsd < DUST_THRESHOLD_USD) {\n          await botLogger.info(\"TRADE_SKIPPED\", `SELL skipped - dust position (valor < $${DUST_THRESHOLD_USD})`, {\n            pair,\n            signal: \"SELL\",\n            reason: \"DUST_POSITION\",\n            lotAmount,\n            realAssetBalance,\n            sellVolume,\n            sellValueUsd,\n            dustThresholdUsd: DUST_THRESHOLD_USD,\n            signalReason: signal.reason,\n          });\n          return;\n        }\n\n        log(`${pair}: SELL signal - vendiendo ${sellVolume.toFixed(8)} (lot: ${lotAmount.toFixed(8)}, balance: ${realAssetBalance.toFixed(8)}, value: $${sellValueUsd.toFixed(2)})`, \"trading\");\n\n        const sellContext = existingPosition \n          ? { entryPrice: existingPosition.entryPrice, aiSampleId: existingPosition.aiSampleId }\n          : undefined;\n        const success = await this.executeTrade(pair, \"sell\", sellVolume.toFixed(8), currentPrice, signal.reason, undefined, undefined, undefined, sellContext);\n        if (success) {\n          this.lastTradeTime.set(pair, Date.now());\n        }\n      }\n    } catch (error: any) {\n      log(`Error analizando ${pair}: ${error.message}`, \"trading\");\n    }\n  }\n\n  private async analyzePairAndTradeWithCandles(\n    pair: string,\n    timeframe: string,\n    candle: OHLCCandle,\n    riskConfig: RiskConfig,\n    balances: any\n  ) {\n    try {\n      const lastTrade = this.lastTradeTime.get(pair) || 0;\n      if (Date.now() - lastTrade < this.MIN_TRADE_INTERVAL_MS) {\n        return;\n      }\n\n      const signal = await this.analyzeWithCandleStrategy(pair, timeframe, candle);\n      const strategyId = `momentum_candles_${timeframe}`;\n      \n      // Registrar resultado del escaneo para candles\n      const signalStr = signal.action === \"hold\" ? \"NONE\" : signal.action.toUpperCase();\n      const botConfigForScan = await storage.getBotConfig();\n      const exposureScan = this.getAvailableExposure(pair, botConfigForScan, this.currentUsdBalance);\n      this.lastScanResults.set(pair, {\n        signal: signalStr,\n        reason: signal.reason || \"Sin seÃ±al\",\n        cooldownSec: this.getCooldownRemainingSec(pair),\n        exposureAvailable: exposureScan.maxAllowed,\n      });\n      \n      if (signal.action === \"hold\" || signal.confidence < 0.6) {\n        return;\n      }\n\n      const krakenPair = this.formatKrakenPair(pair);\n      const ticker = await this.krakenService.getTicker(krakenPair);\n      const tickerData: any = Object.values(ticker)[0];\n      if (!tickerData) return;\n\n      const currentPrice = parseFloat(tickerData.c?.[0] || \"0\");\n      const assetBalance = this.getAssetBalance(pair, balances);\n      const existingPositions = this.getPositionsByPair(pair);\n      const existingPosition = existingPositions[0];\n\n      if (signal.action === \"buy\") {\n        if (this.isPairInCooldown(pair)) {\n          const cooldownSec = this.getCooldownRemainingSec(pair);\n          await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al BUY ignorada - par en cooldown`, {\n            pair,\n            signal: \"BUY\",\n            reason: \"PAIR_COOLDOWN\",\n            cooldownRemainingSec: cooldownSec,\n            signalReason: signal.reason,\n          });\n          return;\n        }\n\n        // MODO SINGLE o SMART_GUARD: Bloquear compras si ya hay posiciÃ³n abierta\n        const botConfigCheck = await storage.getBotConfig();\n        const positionMode = botConfigCheck?.positionMode || \"SINGLE\";\n        const sgMaxLotsPerPair = botConfigCheck?.sgMaxOpenLotsPerPair ?? 1;\n        \n        // En SINGLE siempre 1 slot. En SMART_GUARD respetamos sgMaxOpenLotsPerPair.\n        const maxLotsForMode = positionMode === \"SMART_GUARD\" ? sgMaxLotsPerPair : 1;\n        const currentOpenLots = this.countLotsForPair(pair);\n        \n        if ((positionMode === \"SINGLE\" || positionMode === \"SMART_GUARD\") && currentOpenLots >= maxLotsForMode) {\n          const reasonCode = positionMode === \"SMART_GUARD\" \n            ? \"SMART_GUARD_MAX_LOTS_REACHED\" \n            : \"SINGLE_MODE_POSITION_EXISTS\";\n          \n          log(`${pair}: Compra bloqueada - Modo ${positionMode}, lotes abiertos ${currentOpenLots}/${maxLotsForMode}`, \"trading\");\n          await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al BUY ignorada - mÃ¡ximo de lotes alcanzado`, {\n            pair,\n            signal: \"BUY\",\n            reason: reasonCode,\n            currentOpenLots,\n            maxOpenLots: maxLotsForMode,\n            existingAmount: existingPosition?.amount || 0,\n            signalReason: signal.reason,\n          });\n          this.lastScanResults.set(pair, {\n            signal: \"BUY\",\n            reason: reasonCode,\n            exposureAvailable: 0,\n          });\n          return;\n        }\n\n        // B3: SMART_GUARD requiere â‰¥5 seÃ±ales para BUY (umbral mÃ¡s estricto)\n        if (positionMode === \"SMART_GUARD\") {\n          const signalCountMatch = signal.reason.match(/SeÃ±ales:\\s*(\\d+)\\/(\\d+)/);\n          if (signalCountMatch) {\n            const buySignalCount = parseInt(signalCountMatch[1], 10);\n            if (buySignalCount < 5) {\n              await botLogger.info(\"TRADE_SKIPPED\", `SMART_GUARD BUY bloqueado - seÃ±ales insuficientes (${buySignalCount} < 5)`, {\n                pair,\n                signal: \"BUY\",\n                reason: \"SMART_GUARD_INSUFFICIENT_SIGNALS\",\n                buySignalCount,\n                requiredSignals: 5,\n                signalReason: signal.reason,\n              });\n              return;\n            }\n          }\n        }\n\n        if (this.isPairInStopLossCooldown(pair)) {\n          const cooldownSec = this.getStopLossCooldownRemainingSec(pair);\n          log(`${pair}: En cooldown post stop-loss`, \"trading\");\n          await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al BUY ignorada - cooldown post stop-loss`, {\n            pair,\n            signal: \"BUY\",\n            reason: \"STOPLOSS_COOLDOWN\",\n            cooldownRemainingSec: cooldownSec,\n            signalReason: signal.reason,\n          });\n          return;\n        }\n\n        const spreadCheck = this.isSpreadAcceptable(tickerData);\n        if (!spreadCheck.acceptable) {\n          log(`${pair}: Spread demasiado alto (${spreadCheck.spreadPct.toFixed(3)}% > ${MAX_SPREAD_PCT}%)`, \"trading\");\n          await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al BUY ignorada - spread alto`, {\n            pair,\n            signal: \"BUY\",\n            reason: \"SPREAD_TOO_HIGH\",\n            spreadPct: spreadCheck.spreadPct,\n            maxSpreadPct: MAX_SPREAD_PCT,\n            signalReason: signal.reason,\n          });\n          return;\n        }\n\n        if (existingPosition && existingPosition.amount * currentPrice > riskConfig.maxTradeUSD * 2) {\n          log(`PosiciÃ³n existente en ${pair} ya es grande: $${(existingPosition.amount * currentPrice).toFixed(2)}`, \"trading\");\n          await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al BUY ignorada - posiciÃ³n existente demasiado grande`, {\n            pair,\n            signal: \"BUY\",\n            reason: \"POSITION_TOO_LARGE\",\n            currentPositionUsd: existingPosition.amount * currentPrice,\n            maxTradeUsd: riskConfig.maxTradeUSD * 2,\n          });\n          return;\n        }\n\n        const minVolume = this.getOrderMin(pair);\n        const minRequiredUSD = minVolume * currentPrice;\n        const freshUsdBalance = parseFloat(balances?.ZUSD || balances?.USD || \"0\");\n\n        if (freshUsdBalance < minRequiredUSD) {\n          log(`Saldo USD insuficiente para ${pair}: $${freshUsdBalance.toFixed(2)} < $${minRequiredUSD.toFixed(2)}`, \"trading\");\n          await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al BUY ignorada - fondos insuficientes`, {\n            pair,\n            signal: \"BUY\",\n            reason: \"INSUFFICIENT_FUNDS\",\n            availableUsd: freshUsdBalance,\n            minRequiredUsd: minRequiredUSD,\n          });\n          this.setPairCooldown(pair);\n          return;\n        }\n\n        const botConfig = await storage.getBotConfig();\n        const riskPerTradePct = parseFloat(botConfig?.riskPerTradePct?.toString() || \"15\");\n        const takeProfitPct = parseFloat(botConfig?.takeProfitPercent?.toString() || \"7\");\n        \n        // === CÃLCULO DE TAMAÃ‘O DE ORDEN (tradeAmountUSD) - UNIFICADO CON analyzePairAndTrade ===\n        let tradeAmountUSD: number;\n        let wasAdjusted = false;\n        let originalAmount: number;\n        let sgReasonCode: SmartGuardReasonCode | undefined;\n        \n        // SMART_GUARD: obtener parÃ¡metros\n        const sgParams = positionMode === \"SMART_GUARD\" ? this.getSmartGuardParams(pair, botConfig) : null;\n        const sgMinEntryUsd = sgParams?.sgMinEntryUsd || 100;\n        const sgAllowUnderMin = sgParams?.sgAllowUnderMin ?? true;\n        const sgFeeCushionPct = sgParams?.sgFeeCushionPct || 0;\n        const sgFeeCushionAuto = sgParams?.sgFeeCushionAuto ?? false;\n        \n        const effectiveCushionPct = sgFeeCushionAuto ? (KRAKEN_FEE_PCT * 2) : sgFeeCushionPct;\n        const usdDisponible = freshUsdBalance;\n        const floorUsd = Math.max(SG_ABSOLUTE_MIN_USD, minRequiredUSD);\n        const cushionAmount = freshUsdBalance * (effectiveCushionPct / 100);\n        const availableAfterCushion = usdDisponible - cushionAmount;\n        \n        if (positionMode === \"SMART_GUARD\") {\n          // === SMART_GUARD v2 SIZING (mismo que analyzePairAndTrade) ===\n          originalAmount = sgMinEntryUsd;\n          \n          if (availableAfterCushion >= sgMinEntryUsd) {\n            tradeAmountUSD = sgMinEntryUsd;\n            sgReasonCode = \"SMART_GUARD_ENTRY_USING_CONFIG_MIN\";\n          } else if (availableAfterCushion >= floorUsd) {\n            tradeAmountUSD = availableAfterCushion;\n            sgReasonCode = \"SMART_GUARD_ENTRY_FALLBACK_TO_AVAILABLE\";\n          } else if (usdDisponible >= floorUsd && availableAfterCushion < floorUsd) {\n            tradeAmountUSD = availableAfterCushion;\n            sgReasonCode = \"SMART_GUARD_BLOCKED_AFTER_FEE_CUSHION\";\n          } else {\n            tradeAmountUSD = usdDisponible;\n            sgReasonCode = \"SMART_GUARD_BLOCKED_BELOW_EXCHANGE_MIN\";\n          }\n          \n          log(`SMART_GUARD ${pair} [${strategyId}]: Sizing v2 - order=$${tradeAmountUSD.toFixed(2)}, reason=${sgReasonCode}`, \"trading\");\n          log(`  â†’ availableUsd=$${usdDisponible.toFixed(2)}, sgMinEntryUsd=$${sgMinEntryUsd.toFixed(2)}, floorUsd=$${floorUsd.toFixed(2)}`, \"trading\");\n        } else {\n          // Modos SINGLE/DCA: lÃ³gica original\n          const profitCheck = this.isProfitableAfterFees(takeProfitPct);\n          if (!profitCheck.isProfitable) {\n            log(`${pair}: Trade rechazado - Take-Profit (${takeProfitPct}%) < mÃ­nimo rentable`, \"trading\");\n            await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al BUY ignorada - take-profit menor que fees`, {\n              pair,\n              signal: \"BUY\",\n              reason: \"LOW_PROFITABILITY\",\n              takeProfitPct,\n              roundTripFees: profitCheck.roundTripFees,\n              minProfitRequired: profitCheck.minProfitRequired,\n              strategyId,\n            });\n            return;\n          }\n          \n          tradeAmountUSD = freshUsdBalance * (riskPerTradePct / 100);\n          tradeAmountUSD = Math.min(tradeAmountUSD, riskConfig.maxTradeUSD);\n\n          const confidenceFactor = this.getConfidenceSizingFactor(signal.confidence);\n          tradeAmountUSD = tradeAmountUSD * confidenceFactor;\n\n          if (tradeAmountUSD < minRequiredUSD && freshUsdBalance >= minRequiredUSD) {\n            const smallAccountAmount = freshUsdBalance * SMALL_ACCOUNT_FACTOR;\n            tradeAmountUSD = Math.min(smallAccountAmount, riskConfig.maxTradeUSD);\n          }\n          \n          originalAmount = tradeAmountUSD;\n        }\n\n        const exposure = this.getAvailableExposure(pair, botConfig, freshUsdBalance);\n        const maxByBalance = Math.max(0, freshUsdBalance * 0.95);\n        const effectiveMaxAllowed = positionMode === \"SMART_GUARD\"\n          ? Math.min(exposure.maxTotalAvailable, maxByBalance)\n          : Math.min(exposure.maxAllowed, maxByBalance);\n        \n        if (effectiveMaxAllowed < minRequiredUSD) {\n          log(`${pair}: Sin exposiciÃ³n disponible`, \"trading\");\n          await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al BUY ignorada - sin exposiciÃ³n disponible`, {\n            pair,\n            signal: \"BUY\",\n            reason: \"EXPOSURE_ZERO\",\n            exposureAvailable: effectiveMaxAllowed,\n            minRequiredUsd: minRequiredUSD,\n          });\n          this.setPairCooldown(pair);\n          return;\n        }\n\n        // Ajustar por lÃ­mite de exposiciÃ³n (solo para SINGLE/DCA)\n        if (positionMode !== \"SMART_GUARD\" && tradeAmountUSD > effectiveMaxAllowed) {\n          originalAmount = tradeAmountUSD;\n          tradeAmountUSD = effectiveMaxAllowed;\n          wasAdjusted = true;\n        }\n\n        const tradeVolume = tradeAmountUSD / currentPrice;\n\n        if (tradeVolume < minVolume) {\n          log(`${pair}: Volumen ${tradeVolume.toFixed(8)} < mÃ­nimo ${minVolume}`, \"trading\");\n          await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al BUY ignorada - volumen < mÃ­nimo`, {\n            pair,\n            signal: \"BUY\",\n            reason: \"VOLUME_BELOW_MINIMUM\",\n            calculatedVolume: tradeVolume,\n            minVolume,\n            strategyId,\n          });\n          this.setPairCooldown(pair);\n          return;\n        }\n\n        const adjustmentInfo = wasAdjusted ? {\n          wasAdjusted: true,\n          originalAmountUsd: originalAmount,\n          adjustedAmountUsd: tradeAmountUSD\n        } : undefined;\n\n        const success = await this.executeTrade(\n          pair, \n          \"buy\", \n          tradeVolume.toFixed(8), \n          currentPrice, \n          `${signal.reason} [${strategyId}]`, \n          adjustmentInfo,\n          { strategyId, timeframe, confidence: signal.confidence }\n        );\n        \n        if (success) {\n          this.lastTradeTime.set(pair, Date.now());\n        }\n\n      } else if (signal.action === \"sell\") {\n        // A2: SMART_GUARD bloquea SELL por seÃ±al - solo risk exits permiten vender\n        // EXCEPCIÃ“N: Permitir liquidaciÃ³n de huÃ©rfanos (balance > 0 sin posiciÃ³n trackeada)\n        const botConfigSellCandles = await storage.getBotConfig();\n        const positionModeSellCandles = botConfigSellCandles?.positionMode || \"SINGLE\";\n        const isOrphanCleanupCandles = assetBalance > 0 && (!existingPosition || existingPosition.amount <= 0);\n        \n        if (positionModeSellCandles === \"SMART_GUARD\" && !isOrphanCleanupCandles) {\n          await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al SELL bloqueada en SMART_GUARD - solo risk exits permiten vender`, {\n            pair,\n            signal: \"SELL\",\n            reason: \"SMART_GUARD_SIGNAL_SELL_BLOCKED\",\n            strategyId,\n            signalReason: signal.reason,\n          });\n          return;\n        }\n\n        if (assetBalance <= 0 && (!existingPosition || existingPosition.amount <= 0)) {\n          await botLogger.info(\"TRADE_SKIPPED\", `SeÃ±al SELL ignorada - sin posiciÃ³n para vender`, {\n            pair,\n            signal: \"SELL\",\n            reason: \"NO_POSITION\",\n            assetBalance,\n            strategyId,\n            signalReason: signal.reason,\n          });\n          return;\n        }\n\n        // === FIX: Vender lote completo, no 50% ===\n        // Si no hay lot trackeado, usar balance real del wallet\n        const lotAmount = existingPosition?.amount ?? assetBalance;\n        const realAssetBalance = assetBalance;\n        const rawSellVolume = Math.min(lotAmount, realAssetBalance);\n        const sellVolume = this.normalizeVolume(pair, rawSellVolume);\n        \n        const minVolumeSell = this.getOrderMin(pair);\n        const sellValueUsd = sellVolume * currentPrice;\n\n        // === DUST DETECTION ===\n        if (sellVolume < minVolumeSell) {\n          await botLogger.info(\"TRADE_SKIPPED\", `SELL skipped - dust position (volumen < mÃ­nimo)`, {\n            pair,\n            signal: \"SELL\",\n            reason: \"DUST_POSITION\",\n            lotAmount,\n            realAssetBalance,\n            sellVolume,\n            minVolume: minVolumeSell,\n            sellValueUsd,\n            strategyId,\n          });\n          return;\n        }\n        \n        if (sellValueUsd < DUST_THRESHOLD_USD) {\n          await botLogger.info(\"TRADE_SKIPPED\", `SELL skipped - dust position (valor < $${DUST_THRESHOLD_USD})`, {\n            pair,\n            signal: \"SELL\",\n            reason: \"DUST_POSITION\",\n            lotAmount,\n            realAssetBalance,\n            sellVolume,\n            sellValueUsd,\n            dustThresholdUsd: DUST_THRESHOLD_USD,\n            strategyId,\n          });\n          return;\n        }\n\n        log(`${pair}: SELL signal [${strategyId}] - vendiendo ${sellVolume.toFixed(8)} (value: $${sellValueUsd.toFixed(2)})`, \"trading\");\n\n        const sellContext = existingPosition \n          ? { entryPrice: existingPosition.entryPrice, aiSampleId: existingPosition.aiSampleId }\n          : undefined;\n        const success = await this.executeTrade(pair, \"sell\", sellVolume.toFixed(8), currentPrice, `${signal.reason} [${strategyId}]`, undefined, undefined, undefined, sellContext);\n        if (success) {\n          this.lastTradeTime.set(pair, Date.now());\n        }\n      }\n    } catch (error: any) {\n      log(`Error analizando ${pair} con velas: ${error.message}`, \"trading\");\n    }\n  }\n\n  private async analyzeWithStrategy(\n    strategy: string,\n    pair: string,\n    history: PriceData[],\n    currentPrice: number\n  ): Promise<TradeSignal> {\n    const mtfData = await this.getMultiTimeframeData(pair);\n    const mtfAnalysis = mtfData ? this.analyzeMultiTimeframe(mtfData) : null;\n\n    let signal: TradeSignal;\n    switch (strategy) {\n      case \"momentum\":\n        signal = this.momentumStrategy(pair, history, currentPrice);\n        break;\n      case \"mean_reversion\":\n        signal = this.meanReversionStrategy(pair, history, currentPrice);\n        break;\n      case \"scalping\":\n        signal = this.scalpingStrategy(pair, history, currentPrice);\n        break;\n      case \"grid\":\n        signal = this.gridStrategy(pair, history, currentPrice);\n        break;\n      default:\n        return { action: \"hold\", pair, confidence: 0, reason: \"Estrategia desconocida\" };\n    }\n\n    if (mtfAnalysis && signal.action !== \"hold\") {\n      const mtfBoost = this.applyMTFFilter(signal, mtfAnalysis);\n      if (mtfBoost.filtered) {\n        return { action: \"hold\", pair, confidence: 0.3, reason: `SeÃ±al filtrada por MTF: ${mtfBoost.reason}` };\n      }\n      signal.confidence = Math.min(0.95, signal.confidence + mtfBoost.confidenceBoost);\n      signal.reason += ` | MTF: ${mtfAnalysis.summary}`;\n    }\n\n    return signal;\n  }\n\n  private applyMTFFilter(signal: TradeSignal, mtf: TrendAnalysis): { filtered: boolean; confidenceBoost: number; reason: string } {\n    if (signal.action === \"buy\") {\n      if (mtf.longTerm === \"bearish\" && mtf.mediumTerm === \"bearish\") {\n        return { filtered: true, confidenceBoost: 0, reason: \"Tendencia 1h y 4h bajista\" };\n      }\n      if (mtf.alignment < -0.5) {\n        return { filtered: true, confidenceBoost: 0, reason: `AlineaciÃ³n MTF negativa (${mtf.alignment.toFixed(2)})` };\n      }\n      if (mtf.alignment > 0.5) {\n        return { filtered: false, confidenceBoost: 0.15, reason: \"Confirmado por MTF alcista\" };\n      }\n      if (mtf.longTerm === \"bullish\") {\n        return { filtered: false, confidenceBoost: 0.1, reason: \"Tendencia 4h alcista\" };\n      }\n    }\n\n    if (signal.action === \"sell\") {\n      if (mtf.longTerm === \"bullish\" && mtf.mediumTerm === \"bullish\") {\n        return { filtered: true, confidenceBoost: 0, reason: \"Tendencia 1h y 4h alcista\" };\n      }\n      if (mtf.alignment > 0.5) {\n        return { filtered: true, confidenceBoost: 0, reason: `AlineaciÃ³n MTF positiva (${mtf.alignment.toFixed(2)})` };\n      }\n      if (mtf.alignment < -0.5) {\n        return { filtered: false, confidenceBoost: 0.15, reason: \"Confirmado por MTF bajista\" };\n      }\n      if (mtf.longTerm === \"bearish\") {\n        return { filtered: false, confidenceBoost: 0.1, reason: \"Tendencia 4h bajista\" };\n      }\n    }\n\n    return { filtered: false, confidenceBoost: 0, reason: \"Sin filtro MTF aplicado\" };\n  }\n\n  private momentumStrategy(pair: string, history: PriceData[], currentPrice: number): TradeSignal {\n    const prices = history.map(h => h.price);\n    const shortEMA = this.calculateEMA(prices.slice(-10), 10);\n    const longEMA = this.calculateEMA(prices.slice(-20), 20);\n    const rsi = this.calculateRSI(prices.slice(-14));\n    const macd = this.calculateMACD(prices);\n    const bollinger = this.calculateBollingerBands(prices);\n    const volumeAnalysis = this.detectAbnormalVolume(history);\n    \n    const trend = (currentPrice - prices[0]) / prices[0] * 100;\n    \n    let buySignals = 0;\n    let sellSignals = 0;\n    const reasons: string[] = [];\n\n    if (shortEMA > longEMA) buySignals++;\n    else if (shortEMA < longEMA) sellSignals++;\n\n    if (rsi < 30) { buySignals += 2; reasons.push(`RSI sobrevendido (${rsi.toFixed(0)})`); }\n    else if (rsi < 45) { buySignals++; }\n    else if (rsi > 70) { sellSignals += 2; reasons.push(`RSI sobrecomprado (${rsi.toFixed(0)})`); }\n    else if (rsi > 55) { sellSignals++; }\n\n    if (macd.histogram > 0 && macd.macd > macd.signal) { buySignals++; reasons.push(\"MACD alcista\"); }\n    else if (macd.histogram < 0 && macd.macd < macd.signal) { sellSignals++; reasons.push(\"MACD bajista\"); }\n\n    if (bollinger.percentB < 20) { buySignals++; reasons.push(\"Precio cerca de Bollinger inferior\"); }\n    else if (bollinger.percentB > 80) { sellSignals++; reasons.push(\"Precio cerca de Bollinger superior\"); }\n\n    if (volumeAnalysis.isAbnormal) {\n      if (volumeAnalysis.direction === \"bullish\") { buySignals++; reasons.push(`Volumen alto alcista (${volumeAnalysis.ratio.toFixed(1)}x)`); }\n      else if (volumeAnalysis.direction === \"bearish\") { sellSignals++; reasons.push(`Volumen alto bajista (${volumeAnalysis.ratio.toFixed(1)}x)`); }\n    }\n\n    if (trend > 1) buySignals++;\n    else if (trend < -1) sellSignals++;\n\n    const confidence = Math.min(0.95, 0.5 + (Math.max(buySignals, sellSignals) * 0.08));\n    \n    if (buySignals >= 4 && buySignals > sellSignals && rsi < 70) {\n      return {\n        action: \"buy\",\n        pair,\n        confidence,\n        reason: `Momentum alcista: ${reasons.join(\", \")} | SeÃ±ales: ${buySignals} compra vs ${sellSignals} venta`,\n      };\n    }\n    \n    if (sellSignals >= 4 && sellSignals > buySignals && rsi > 30) {\n      return {\n        action: \"sell\",\n        pair,\n        confidence,\n        reason: `Momentum bajista: ${reasons.join(\", \")} | SeÃ±ales: ${sellSignals} venta vs ${buySignals} compra`,\n      };\n    }\n\n    return { action: \"hold\", pair, confidence: 0.3, reason: `Sin seÃ±al clara (${buySignals} compra / ${sellSignals} venta)` };\n  }\n\n  private meanReversionStrategy(pair: string, history: PriceData[], currentPrice: number): TradeSignal {\n    const prices = history.map(h => h.price);\n    const mean = prices.reduce((a, b) => a + b, 0) / prices.length;\n    const stdDev = Math.sqrt(prices.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / prices.length);\n    const zScore = (currentPrice - mean) / stdDev;\n    \n    const bollinger = this.calculateBollingerBands(prices);\n    const rsi = this.calculateRSI(prices.slice(-14));\n    const volumeAnalysis = this.detectAbnormalVolume(history);\n    \n    const reasons: string[] = [];\n    let confidence = 0.6;\n\n    if (zScore < -2 || bollinger.percentB < 5) {\n      confidence += 0.15;\n      reasons.push(`Extremadamente sobrevendido (Z=${zScore.toFixed(2)}, %B=${bollinger.percentB.toFixed(0)})`);\n      \n      if (rsi < 25) { confidence += 0.1; reasons.push(`RSI muy bajo (${rsi.toFixed(0)})`); }\n      if (volumeAnalysis.isAbnormal && volumeAnalysis.direction === \"bearish\") {\n        confidence += 0.05;\n        reasons.push(\"Volumen de capitulaciÃ³n\");\n      }\n      \n      return {\n        action: \"buy\",\n        pair,\n        confidence: Math.min(0.95, confidence),\n        reason: `Mean Reversion COMPRA: ${reasons.join(\", \")}`,\n      };\n    }\n    \n    if (zScore < -1.5 || bollinger.percentB < 15) {\n      if (rsi < 35) { confidence += 0.1; reasons.push(`RSI bajo (${rsi.toFixed(0)})`); }\n      reasons.push(`Sobrevendido (Z=${zScore.toFixed(2)}, %B=${bollinger.percentB.toFixed(0)})`);\n      \n      return {\n        action: \"buy\",\n        pair,\n        confidence: Math.min(0.85, confidence),\n        reason: `Mean Reversion COMPRA: ${reasons.join(\", \")}`,\n      };\n    }\n    \n    if (zScore > 2 || bollinger.percentB > 95) {\n      confidence += 0.15;\n      reasons.push(`Extremadamente sobrecomprado (Z=${zScore.toFixed(2)}, %B=${bollinger.percentB.toFixed(0)})`);\n      \n      if (rsi > 75) { confidence += 0.1; reasons.push(`RSI muy alto (${rsi.toFixed(0)})`); }\n      if (volumeAnalysis.isAbnormal && volumeAnalysis.direction === \"bullish\") {\n        confidence += 0.05;\n        reasons.push(\"Volumen de euforia\");\n      }\n      \n      return {\n        action: \"sell\",\n        pair,\n        confidence: Math.min(0.95, confidence),\n        reason: `Mean Reversion VENTA: ${reasons.join(\", \")}`,\n      };\n    }\n    \n    if (zScore > 1.5 || bollinger.percentB > 85) {\n      if (rsi > 65) { confidence += 0.1; reasons.push(`RSI alto (${rsi.toFixed(0)})`); }\n      reasons.push(`Sobrecomprado (Z=${zScore.toFixed(2)}, %B=${bollinger.percentB.toFixed(0)})`);\n      \n      return {\n        action: \"sell\",\n        pair,\n        confidence: Math.min(0.85, confidence),\n        reason: `Mean Reversion VENTA: ${reasons.join(\", \")}`,\n      };\n    }\n\n    return { action: \"hold\", pair, confidence: 0.3, reason: `Precio en rango normal (Z=${zScore.toFixed(2)})` };\n  }\n\n  private scalpingStrategy(pair: string, history: PriceData[], currentPrice: number): TradeSignal {\n    if (history.length < 15) {\n      return { action: \"hold\", pair, confidence: 0, reason: \"Datos insuficientes para scalping\" };\n    }\n\n    const prices = history.map(h => h.price);\n    const recentPrices = prices.slice(-5);\n    const avgPrice = recentPrices.reduce((a, b) => a + b, 0) / recentPrices.length;\n    const priceChange = (currentPrice - avgPrice) / avgPrice * 100;\n    \n    const volatility = this.calculateVolatility(recentPrices);\n    const rsi = this.calculateRSI(prices.slice(-14));\n    const volumeAnalysis = this.detectAbnormalVolume(history);\n    const macd = this.calculateMACD(prices);\n    const atr = this.calculateATR(history, 14);\n    const atrPercent = this.calculateATRPercent(history, 14);\n    \n    const reasons: string[] = [];\n    let confidence = 0.65;\n\n    // Filtro de volatilidad mÃ­nima usando ATR\n    if (atrPercent < 0.1) {\n      return { action: \"hold\", pair, confidence: 0.2, reason: `Volatilidad ATR muy baja (${atrPercent.toFixed(2)}%)` };\n    }\n\n    // Ajustar umbral de entrada basado en ATR\n    const entryThreshold = Math.max(0.2, atrPercent * 0.3);\n\n    if (priceChange < -entryThreshold && volatility > 0.15) {\n      reasons.push(`CaÃ­da rÃ¡pida ${priceChange.toFixed(2)}%`);\n      reasons.push(`ATR: ${atrPercent.toFixed(2)}%`);\n      \n      if (volumeAnalysis.isAbnormal && volumeAnalysis.ratio > 1.5) {\n        confidence += 0.1;\n        reasons.push(`Volumen alto (${volumeAnalysis.ratio.toFixed(1)}x)`);\n      }\n      if (rsi < 40) {\n        confidence += 0.05;\n        reasons.push(`RSI bajo (${rsi.toFixed(0)})`);\n      }\n      if (macd.histogram < 0 && macd.histogram > -0.5) {\n        confidence += 0.05;\n        reasons.push(\"MACD cerca de cruce\");\n      }\n      // Bonus de confianza si ATR es alto (mÃ¡s oportunidad de profit)\n      if (atrPercent > 0.5) {\n        confidence += 0.05;\n      }\n      \n      return {\n        action: \"buy\",\n        pair,\n        confidence: Math.min(0.9, confidence),\n        reason: `Scalping COMPRA: ${reasons.join(\", \")}`,\n      };\n    }\n    \n    if (priceChange > entryThreshold && volatility > 0.15) {\n      reasons.push(`Subida rÃ¡pida +${priceChange.toFixed(2)}%`);\n      reasons.push(`ATR: ${atrPercent.toFixed(2)}%`);\n      \n      if (volumeAnalysis.isAbnormal && volumeAnalysis.ratio > 1.5) {\n        confidence += 0.1;\n        reasons.push(`Volumen alto (${volumeAnalysis.ratio.toFixed(1)}x)`);\n      }\n      if (rsi > 60) {\n        confidence += 0.05;\n        reasons.push(`RSI alto (${rsi.toFixed(0)})`);\n      }\n      if (atrPercent > 0.5) {\n        confidence += 0.05;\n      }\n      \n      return {\n        action: \"sell\",\n        pair,\n        confidence: Math.min(0.9, confidence),\n        reason: `Scalping VENTA: ${reasons.join(\", \")}`,\n      };\n    }\n\n    return { action: \"hold\", pair, confidence: 0.3, reason: `Sin oportunidad (cambio: ${priceChange.toFixed(2)}%, ATR: ${atrPercent.toFixed(2)}%)` };\n  }\n\n  private gridStrategy(pair: string, history: PriceData[], currentPrice: number): TradeSignal {\n    if (history.length < 15) {\n      return { action: \"hold\", pair, confidence: 0, reason: \"Datos insuficientes para grid\" };\n    }\n\n    const prices = history.map(h => h.price);\n    const high = Math.max(...prices);\n    const low = Math.min(...prices);\n    \n    // Usar ATR para determinar el espaciado del grid dinÃ¡micamente\n    const atr = this.calculateATR(history, 14);\n    const atrPercent = this.calculateATRPercent(history, 14);\n    \n    // El grid size se basa en ATR para adaptarse a la volatilidad del mercado\n    // Usamos 1.5x ATR como espaciado entre niveles del grid\n    const atrBasedGridSize = atr * 1.5;\n    const rangeBasedGridSize = (high - low) / 5;\n    \n    // Usamos el mayor de los dos para evitar niveles demasiado cercanos\n    const gridSize = Math.max(atrBasedGridSize, rangeBasedGridSize);\n    \n    if (gridSize <= 0) {\n      return { action: \"hold\", pair, confidence: 0, reason: \"Grid size invÃ¡lido\" };\n    }\n    \n    // Calcular niveles basados en precio medio\n    const midPrice = (high + low) / 2;\n    const distanceFromMid = currentPrice - midPrice;\n    const levelFromMid = Math.round(distanceFromMid / gridSize);\n    \n    const prevPrice = prices[prices.length - 2];\n    const prevDistanceFromMid = prevPrice - midPrice;\n    const prevLevelFromMid = Math.round(prevDistanceFromMid / gridSize);\n    \n    // Niveles de soporte/resistencia basados en ATR\n    const supportLevel = midPrice - (2 * gridSize);\n    const resistanceLevel = midPrice + (2 * gridSize);\n    \n    let confidence = 0.7;\n    \n    // Ajustar confianza basado en ATR\n    if (atrPercent > 0.5 && atrPercent < 2) {\n      confidence += 0.1; // Volatilidad ideal para grid\n    } else if (atrPercent > 2) {\n      confidence -= 0.1; // Demasiada volatilidad\n    }\n    \n    if (currentPrice <= supportLevel && levelFromMid < prevLevelFromMid) {\n      return {\n        action: \"buy\",\n        pair,\n        confidence: Math.min(0.85, confidence),\n        reason: `Grid ATR: Precio en soporte $${supportLevel.toFixed(2)} (ATR: ${atrPercent.toFixed(2)}%, nivel: ${levelFromMid})`,\n      };\n    }\n    \n    if (currentPrice >= resistanceLevel && levelFromMid > prevLevelFromMid) {\n      return {\n        action: \"sell\",\n        pair,\n        confidence: Math.min(0.85, confidence),\n        reason: `Grid ATR: Precio en resistencia $${resistanceLevel.toFixed(2)} (ATR: ${atrPercent.toFixed(2)}%, nivel: ${levelFromMid})`,\n      };\n    }\n\n    return { action: \"hold\", pair, confidence: 0.3, reason: `Grid: Nivel ${levelFromMid}, ATR: ${atrPercent.toFixed(2)}%` };\n  }\n\n  private calculateEMA(prices: number[], period: number): number {\n    if (prices.length === 0) return 0;\n    const multiplier = 2 / (period + 1);\n    let ema = prices[0];\n    for (let i = 1; i < prices.length; i++) {\n      ema = (prices[i] - ema) * multiplier + ema;\n    }\n    return ema;\n  }\n\n  private calculateRSI(prices: number[]): number {\n    if (prices.length < 2) return 50;\n    \n    let gains = 0, losses = 0;\n    for (let i = 1; i < prices.length; i++) {\n      const change = prices[i] - prices[i - 1];\n      if (change > 0) gains += change;\n      else losses -= change;\n    }\n    \n    const avgGain = gains / (prices.length - 1);\n    const avgLoss = losses / (prices.length - 1);\n    \n    if (avgLoss === 0) return 100;\n    const rs = avgGain / avgLoss;\n    return 100 - (100 / (1 + rs));\n  }\n\n  private calculateVolatility(prices: number[]): number {\n    if (prices.length < 2) return 0;\n    const mean = prices.reduce((a, b) => a + b, 0) / prices.length;\n    const variance = prices.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / prices.length;\n    return (Math.sqrt(variance) / mean) * 100;\n  }\n\n  private calculateMACD(prices: number[]): { macd: number; signal: number; histogram: number } {\n    if (prices.length < 26) {\n      return { macd: 0, signal: 0, histogram: 0 };\n    }\n    \n    const ema12 = this.calculateEMA(prices.slice(-12), 12);\n    const ema26 = this.calculateEMA(prices.slice(-26), 26);\n    const macd = ema12 - ema26;\n    \n    const macdHistory: number[] = [];\n    for (let i = 26; i <= prices.length; i++) {\n      const e12 = this.calculateEMA(prices.slice(i - 12, i), 12);\n      const e26 = this.calculateEMA(prices.slice(i - 26, i), 26);\n      macdHistory.push(e12 - e26);\n    }\n    \n    const signal = macdHistory.length >= 9 ? this.calculateEMA(macdHistory.slice(-9), 9) : 0;\n    const histogram = macd - signal;\n    \n    return { macd, signal, histogram };\n  }\n\n  private calculateBollingerBands(prices: number[], period: number = 20, stdDevMultiplier: number = 2): { \n    upper: number; \n    middle: number; \n    lower: number; \n    percentB: number;\n  } {\n    if (prices.length < period) {\n      const avg = prices.reduce((a, b) => a + b, 0) / prices.length;\n      return { upper: avg, middle: avg, lower: avg, percentB: 50 };\n    }\n    \n    const recentPrices = prices.slice(-period);\n    const middle = recentPrices.reduce((a, b) => a + b, 0) / period;\n    const stdDev = Math.sqrt(\n      recentPrices.reduce((sum, p) => sum + Math.pow(p - middle, 2), 0) / period\n    );\n    \n    const upper = middle + (stdDevMultiplier * stdDev);\n    const lower = middle - (stdDevMultiplier * stdDev);\n    const currentPrice = prices[prices.length - 1];\n    const percentB = ((currentPrice - lower) / (upper - lower)) * 100;\n    \n    return { upper, middle, lower, percentB };\n  }\n\n  private calculateATR(history: PriceData[], period: number = 14): number {\n    if (history.length < period + 1) {\n      return 0;\n    }\n    \n    const trueRanges: number[] = [];\n    for (let i = 1; i < history.length; i++) {\n      const current = history[i];\n      const previous = history[i - 1];\n      \n      const tr1 = current.high - current.low;\n      const tr2 = Math.abs(current.high - previous.price);\n      const tr3 = Math.abs(current.low - previous.price);\n      \n      const trueRange = Math.max(tr1, tr2, tr3);\n      trueRanges.push(trueRange);\n    }\n    \n    const recentTRs = trueRanges.slice(-period);\n    const atr = recentTRs.reduce((a, b) => a + b, 0) / recentTRs.length;\n    \n    return atr;\n  }\n\n  private calculateATRPercent(history: PriceData[], period: number = 14): number {\n    const atr = this.calculateATR(history, period);\n    if (history.length === 0 || atr === 0) return 0;\n    \n    const currentPrice = history[history.length - 1].price;\n    return (atr / currentPrice) * 100;\n  }\n\n  private detectAbnormalVolume(history: PriceData[]): { isAbnormal: boolean; ratio: number; direction: string } {\n    if (history.length < 10) {\n      return { isAbnormal: false, ratio: 1, direction: \"neutral\" };\n    }\n    \n    const volumes = history.map(h => h.volume);\n    const currentVolume = volumes[volumes.length - 1];\n    const avgVolume = volumes.slice(0, -1).reduce((a, b) => a + b, 0) / (volumes.length - 1);\n    \n    if (avgVolume <= 0 || !isFinite(avgVolume) || currentVolume <= 0) {\n      return { isAbnormal: false, ratio: 1, direction: \"neutral\" };\n    }\n    \n    const ratio = currentVolume / avgVolume;\n    \n    if (!isFinite(ratio) || isNaN(ratio)) {\n      return { isAbnormal: false, ratio: 1, direction: \"neutral\" };\n    }\n    \n    const isAbnormal = ratio > 2.0 || ratio < 0.3;\n    \n    const priceChange = (history[history.length - 1].price - history[history.length - 2].price);\n    const direction = priceChange > 0 ? \"bullish\" : priceChange < 0 ? \"bearish\" : \"neutral\";\n    \n    return { isAbnormal, ratio, direction };\n  }\n\n  private updatePriceHistory(pair: string, data: PriceData) {\n    if (!this.priceHistory.has(pair)) {\n      this.priceHistory.set(pair, []);\n    }\n    const history = this.priceHistory.get(pair)!;\n    history.push(data);\n    if (history.length > this.PRICE_HISTORY_LENGTH) {\n      history.shift();\n    }\n  }\n\n  private formatKrakenPair(pair: string): string {\n    const pairMap: Record<string, string> = {\n      \"BTC/USD\": \"XXBTZUSD\",\n      \"ETH/USD\": \"XETHZUSD\",\n      \"SOL/USD\": \"SOLUSD\",\n      \"XRP/USD\": \"XXRPZUSD\",\n      \"TON/USD\": \"TONUSD\",\n      \"ETH/BTC\": \"XETHXXBT\",\n      \"BTC/ETH\": \"XXBTZXETH\",\n      \"SOL/ETH\": \"SOLETH\",\n    };\n    return pairMap[pair] || pair.replace(\"/\", \"\");\n  }\n\n  private getAssetBalance(pair: string, balances: any): number {\n    const asset = pair.split(\"/\")[0];\n    const assetMap: Record<string, string[]> = {\n      \"BTC\": [\"XXBT\", \"XBT\", \"BTC\"],\n      \"ETH\": [\"XETH\", \"ETH\"],\n      \"SOL\": [\"SOL\"],\n      \"XRP\": [\"XXRP\", \"XRP\"],\n      \"TON\": [\"TON\"],\n    };\n    \n    const keys = assetMap[asset] || [asset];\n    for (const key of keys) {\n      if (balances?.[key]) {\n        return parseFloat(balances[key]);\n      }\n    }\n    return 0;\n  }\n\n  // === HELPER: Validar cantidad de venta antes de enviar orden ===\n  // Solo para flujo SELL/cierre. NO afecta BUY ni sizing global.\n  private async validateSellAmount(\n    pair: string,\n    lotId: string,\n    requestedAmount: number\n  ): Promise<{\n    canSell: boolean;\n    sellAmountFinal: number;\n    reason: string;\n    isDust: boolean;\n    realAssetBalance: number;\n    orderMin: number;\n    stepSize: number;\n    needsPositionAdjust: boolean;\n  }> {\n    const stepSize = this.krakenService.getStepSize(pair) || 0.00000001;\n    const orderMin = this.getOrderMin(pair);\n    \n    // 1) Obtener balance real del asset base\n    let freshBalances: any;\n    try {\n      freshBalances = await this.krakenService.getBalance();\n    } catch (error: any) {\n      log(`[MANUAL_CLOSE_EVAL] ${pair} ${lotId}: ERROR getBalance - ${error.message}`, \"trading\");\n      return {\n        canSell: false,\n        sellAmountFinal: 0,\n        reason: `Error obteniendo balance de Kraken: ${error.message}`,\n        isDust: false,\n        realAssetBalance: 0,\n        orderMin,\n        stepSize,\n        needsPositionAdjust: false,\n      };\n    }\n    \n    const realAssetBalance = this.getAssetBalance(pair, freshBalances);\n    \n    // 2) Calcular sellAmount seguro = min(requested, realBalance)\n    let sellAmountRaw = Math.min(requestedAmount, realAssetBalance);\n    \n    // 3) Normalizar al stepSize (truncar, no redondear)\n    const decimals = Math.abs(Math.log10(stepSize));\n    const sellAmountFinal = Math.floor(sellAmountRaw * Math.pow(10, decimals)) / Math.pow(10, decimals);\n    \n    // 4) Caso DUST: balance real < orderMin\n    if (realAssetBalance < orderMin) {\n      const logMsg = `[MANUAL_CLOSE_EVAL] ${pair} ${lotId} | lotAmount=${requestedAmount.toFixed(8)} realBalance=${realAssetBalance.toFixed(8)} orderMin=${orderMin} stepSize=${stepSize} sellFinal=0 decision=DUST`;\n      log(logMsg, \"trading\");\n      \n      return {\n        canSell: false,\n        sellAmountFinal: 0,\n        reason: `Balance real (${realAssetBalance.toFixed(8)}) menor al mÃ­nimo de Kraken (${orderMin}). PosiciÃ³n marcada como DUST.`,\n        isDust: true,\n        realAssetBalance,\n        orderMin,\n        stepSize,\n        needsPositionAdjust: false,\n      };\n    }\n    \n    // 5) Verificar si sellAmountFinal queda por debajo del mÃ­nimo tras normalizar\n    if (sellAmountFinal < orderMin) {\n      const logMsg = `[MANUAL_CLOSE_EVAL] ${pair} ${lotId} | lotAmount=${requestedAmount.toFixed(8)} realBalance=${realAssetBalance.toFixed(8)} orderMin=${orderMin} stepSize=${stepSize} sellFinal=${sellAmountFinal.toFixed(8)} decision=BELOW_MIN_AFTER_NORMALIZE`;\n      log(logMsg, \"trading\");\n      \n      return {\n        canSell: false,\n        sellAmountFinal: 0,\n        reason: `Cantidad normalizada (${sellAmountFinal.toFixed(8)}) menor al mÃ­nimo de Kraken (${orderMin}).`,\n        isDust: true,\n        realAssetBalance,\n        orderMin,\n        stepSize,\n        needsPositionAdjust: false,\n      };\n    }\n    \n    // 6) Detectar discrepancia: position.amount > realAssetBalance\n    const needsPositionAdjust = requestedAmount > realAssetBalance * 1.005; // tolerancia 0.5%\n    \n    const logMsg = `[MANUAL_CLOSE_EVAL] ${pair} ${lotId} | lotAmount=${requestedAmount.toFixed(8)} realBalance=${realAssetBalance.toFixed(8)} orderMin=${orderMin} stepSize=${stepSize} sellFinal=${sellAmountFinal.toFixed(8)} decision=CAN_SELL${needsPositionAdjust ? \" (adjusted)\" : \"\"}`;\n    log(logMsg, \"trading\");\n    \n    return {\n      canSell: true,\n      sellAmountFinal,\n      reason: needsPositionAdjust \n        ? `Cantidad ajustada de ${requestedAmount.toFixed(8)} a ${sellAmountFinal.toFixed(8)} (balance real)` \n        : \"OK\",\n      isDust: false,\n      realAssetBalance,\n      orderMin,\n      stepSize,\n      needsPositionAdjust,\n    };\n  }\n\n  private async executeTrade(\n    pair: string,\n    type: \"buy\" | \"sell\",\n    volume: string,\n    price: number,\n    reason: string,\n    adjustmentInfo?: { wasAdjusted: boolean; originalAmountUsd: number; adjustedAmountUsd: number },\n    strategyMeta?: { strategyId: string; timeframe: string; confidence: number },\n    executionMeta?: { mode: string; usdDisponible: number; orderUsdProposed: number; orderUsdFinal: number; minOrderUsd: number; allowUnderMin: boolean; dryRun: boolean },\n    sellContext?: { entryPrice: number; aiSampleId?: number } // For sells: pass entry price for correct P&L calculation\n  ): Promise<boolean> {\n    try {\n      // === VALIDACIÃ“N: Bloquear pares no-USD ===\n      const allowedQuotes = [\"USD\"];\n      const pairQuote = pair.split(\"/\")[1];\n      if (!allowedQuotes.includes(pairQuote)) {\n        log(`[BLOCKED] Par ${pair} rechazado: quote \"${pairQuote}\" no permitido (solo ${allowedQuotes.join(\", \")})`, \"trading\");\n        await botLogger.warn(\"PAIR_NOT_ALLOWED_QUOTE\", `Trade bloqueado: par ${pair} no tiene quote USD`, {\n          pair,\n          type,\n          quote: pairQuote,\n          allowedQuotes,\n        });\n        return false;\n      }\n      \n      const volumeNum = parseFloat(volume);\n      const totalUSD = volumeNum * price;\n      \n      // === PUNTO 2: Autocompletar strategyMeta desde posiciÃ³n si falta ===\n      if (!strategyMeta?.strategyId || !strategyMeta?.timeframe) {\n        // Buscar posiciones por par para heredar meta de la posiciÃ³n original\n        const positions = this.getPositionsByPair(pair);\n        let pos: OpenPosition | null = null;\n        \n        // Si hay mÃºltiples posiciones, usar la mÃ¡s antigua (FIFO)\n        if (positions.length > 0) {\n          pos = positions[0];\n        }\n        \n        if (pos) {\n          strategyMeta = {\n            strategyId: pos.entryStrategyId ?? strategyMeta?.strategyId ?? \"unknown\",\n            timeframe: pos.entrySignalTf ?? strategyMeta?.timeframe ?? \"cycle\",\n            confidence: pos.signalConfidence ?? strategyMeta?.confidence ?? 0,\n          };\n          log(`[META] Autocompletado strategyMeta desde posiciÃ³n ${pos.lotId}: ${strategyMeta.strategyId}/${strategyMeta.timeframe}`, \"trading\");\n        }\n      }\n      \n      // === DRY_RUN MODE: Simular sin enviar orden real ===\n      if (this.dryRunMode) {\n        const envPrefix = environment.isReplit ? \"[REPLIT/DEV][DRY\\\\_RUN]\" : \"[NAS/PROD][DRY\\\\_RUN]\";\n        const envPrefixLog = environment.isReplit ? \"[REPLIT/DEV][DRY_RUN]\" : \"[NAS/PROD][DRY_RUN]\";\n        \n        // === DOBLE CINTURÃ“N: ValidaciÃ³n redundante para DRY_RUN ===\n        // Si falla mÃ­nimos, ni simula ni envÃ­a mensaje de trade\n        if (type === \"buy\" && executionMeta) {\n          const positionMode = executionMeta.mode || \"SINGLE\";\n          const orderUsdFinal = totalUSD;\n          const sgMinEntryUsd = executionMeta.minOrderUsd || 100;\n          const sgAllowUnderMin = executionMeta.allowUnderMin ?? true;\n          \n          const doubleBeltValidation = validateMinimumsOrSkip({\n            positionMode,\n            orderUsdFinal,\n            orderUsdProposed: executionMeta.orderUsdProposed || orderUsdFinal,\n            usdDisponible: executionMeta.usdDisponible || 0,\n            exposureAvailable: executionMeta.orderUsdFinal || 0,\n            pair,\n            sgMinEntryUsd,\n            sgAllowUnderMin,\n            dryRun: true,\n            env: envPrefixLog,\n          });\n          \n          if (!doubleBeltValidation.valid) {\n            log(`${envPrefixLog} BLOQUEADO - ${doubleBeltValidation.message}`, \"trading\");\n            await botLogger.info(\"TRADE_SKIPPED\", `${envPrefixLog} Trade bloqueado en double-belt`, {\n              pair,\n              type,\n              reason: doubleBeltValidation.skipReason,\n              ...doubleBeltValidation.meta,\n            });\n            // NO enviar Telegram de simulaciÃ³n - solo log\n            return false;\n          }\n        }\n        \n        const simTxid = `DRY-${Date.now()}`;\n        log(`${envPrefixLog} SIMULACIÃ“N ${type.toUpperCase()} ${volume} ${pair} @ $${price.toFixed(2)} (Total: $${totalUSD.toFixed(2)})`, \"trading\");\n        \n        await botLogger.info(\"DRY_RUN_TRADE\", `${envPrefixLog} Trade simulado - NO enviado al exchange`, {\n          pair,\n          type,\n          volume: volumeNum,\n          price,\n          totalUsd: totalUSD,\n          simTxid,\n          reason,\n          ...(executionMeta || {}),\n        });\n        \n        // Enviar Telegram de simulaciÃ³n con prefijo correcto\n        if (this.telegramService.isInitialized()) {\n          const emoji = type === \"buy\" ? \"ğŸŸ¢\" : \"ğŸ”´\";\n          const tipoLabel = type === \"buy\" ? \"COMPRAR\" : \"VENDER\";\n          \n          await this.telegramService.sendMessage(`ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ§ª <b>Trade Simulado</b> [DRY_RUN]\n\n${emoji} <b>SEÃ‘AL: ${tipoLabel} ${pair}</b> ${emoji}\n\nğŸ’µ <b>Precio:</b> <code>$${price.toFixed(2)}</code>\nğŸ“¦ <b>Cantidad:</b> <code>${volume}</code>\nğŸ’° <b>Total:</b> <code>$${totalUSD.toFixed(2)}</code>\n\nâš ï¸ Modo simulaciÃ³n - NO se enviÃ³ orden real\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);\n        }\n        \n        return true; // Simular Ã©xito para flujo normal\n      }\n      \n      // C1: Validar sellContext ANTES de ejecutar orden real (excepto emergency exits)\n      if (type === \"sell\" && !sellContext) {\n        const isEmergencyExit = reason.toLowerCase().includes(\"stop-loss\") || \n                                 reason.toLowerCase().includes(\"emergencia\") ||\n                                 reason.toLowerCase().includes(\"emergency\");\n        if (!isEmergencyExit) {\n          log(`[ERROR] SELL BLOQUEADO sin sellContext para ${pair} - violaciÃ³n de trazabilidad. RazÃ³n: ${reason}`, \"trading\");\n          await botLogger.warn(\"SELL_BLOCKED_NO_CONTEXT\", `SELL bloqueado - sin sellContext`, {\n            pair,\n            type,\n            volume,\n            price,\n            reason,\n          });\n          return false;\n        }\n        log(`[WARN] Emergency SELL sin sellContext para ${pair} - permitido. RazÃ³n: ${reason}`, \"trading\");\n      }\n      \n      log(`Ejecutando ${type.toUpperCase()} ${volume} ${pair} @ $${price.toFixed(2)}`, \"trading\");\n      \n      const order = await this.krakenService.placeOrder({\n        pair,\n        type,\n        ordertype: \"market\",\n        volume,\n      });\n\n      const txid = order.txid?.[0];\n      if (!txid) {\n        log(`Orden sin txid - posible fallo`, \"trading\");\n        return false;\n      }\n\n      const tradeId = `AUTO-${Date.now()}`;\n      \n      // === A) P&L INMEDIATO EN SELL AUTOMÃTICO ===\n      let tradeEntryPrice: string | null = null;\n      let tradeRealizedPnlUsd: string | null = null;\n      let tradeRealizedPnlPct: string | null = null;\n      let reasonWithContext = reason;\n      \n      if (type === \"sell\") {\n        const entryPrice = sellContext?.entryPrice ?? null;\n        \n        if (entryPrice != null && entryPrice > 0) {\n          // A2: Calcular P&L con entryPrice disponible\n          const grossPnlUsd = (price - entryPrice) * volumeNum;\n          const pnlPct = ((price - entryPrice) / entryPrice) * 100;\n          // Fee no disponible en este scope - guardar gross P&L\n          tradeEntryPrice = entryPrice.toString();\n          tradeRealizedPnlUsd = grossPnlUsd.toFixed(8);\n          tradeRealizedPnlPct = pnlPct.toFixed(4);\n          log(`[P&L] SELL ${pair}: entry=$${entryPrice.toFixed(2)} exit=$${price.toFixed(2)} â†’ PnL=$${grossPnlUsd.toFixed(2)} (${pnlPct.toFixed(2)}%)`, \"trading\");\n        } else {\n          // A3: Orphan/emergency sin entryPrice - permitir pero marcar\n          reasonWithContext = `${reason} | SELL_NO_ENTRYPRICE`;\n          log(`[WARN] SELL ${pair} sin entryPrice - P&L no calculado (orphan/emergency)`, \"trading\");\n        }\n      }\n      \n      await storage.createTrade({\n        tradeId,\n        pair,\n        type,\n        price: price.toString(),\n        amount: volume,\n        status: \"filled\",\n        krakenOrderId: txid,\n        executedAt: new Date(),\n        entryPrice: tradeEntryPrice,\n        realizedPnlUsd: tradeRealizedPnlUsd,\n        realizedPnlPct: tradeRealizedPnlPct,\n      });\n\n      // volumeNum ya declarado arriba\n      if (type === \"buy\") {\n        this.currentUsdBalance -= volumeNum * price;\n        const existingPositions = this.getPositionsByPair(pair);\n        const existing = existingPositions[0]; // First position for DCA mode\n        let newPosition: OpenPosition;\n        \n        const entryStrategyId = strategyMeta?.strategyId || \"momentum_cycle\";\n        const entrySignalTf = strategyMeta?.timeframe || \"cycle\";\n        const signalConfidence = strategyMeta?.confidence;\n        \n        const currentConfig = await storage.getBotConfig();\n        const entryMode = currentConfig?.positionMode || \"SINGLE\";\n        \n        // In SMART_GUARD with multi-lot, always create new positions\n        const shouldCreateNewLot = entryMode === \"SMART_GUARD\" || !existing || existing.amount <= 0;\n        \n        if (!shouldCreateNewLot && existing) {\n          // DCA mode: update existing position\n          const totalAmount = existing.amount + volumeNum;\n          const avgPrice = (existing.amount * existing.entryPrice + volumeNum * price) / totalAmount;\n          newPosition = { \n            ...existing,\n            amount: totalAmount, \n            entryPrice: avgPrice,\n            highestPrice: Math.max(existing.highestPrice, price),\n          };\n          this.openPositions.set(existing.lotId, newPosition);\n          log(`DCA entry: ${pair} (${existing.lotId}) - preserved snapshot from original entry`, \"trading\");\n        } else {\n          // NEW POSITION: create snapshot of current config with unique lotId\n          const lotId = generateLotId(pair);\n          \n          const configSnapshot: ConfigSnapshot = {\n            stopLossPercent: parseFloat(currentConfig?.stopLossPercent?.toString() || \"5\"),\n            takeProfitPercent: parseFloat(currentConfig?.takeProfitPercent?.toString() || \"7\"),\n            trailingStopEnabled: currentConfig?.trailingStopEnabled ?? false,\n            trailingStopPercent: parseFloat(currentConfig?.trailingStopPercent?.toString() || \"2\"),\n            positionMode: entryMode,\n          };\n          \n          // Add SMART_GUARD specific params using getSmartGuardParams() for per-pair override support\n          if (entryMode === \"SMART_GUARD\") {\n            const sgParams = this.getSmartGuardParams(pair, currentConfig);\n            configSnapshot.sgMinEntryUsd = sgParams.sgMinEntryUsd;\n            configSnapshot.sgAllowUnderMin = sgParams.sgAllowUnderMin;\n            configSnapshot.sgBeAtPct = sgParams.sgBeAtPct;\n            configSnapshot.sgFeeCushionPct = sgParams.sgFeeCushionPct;\n            configSnapshot.sgFeeCushionAuto = sgParams.sgFeeCushionAuto;\n            configSnapshot.sgTrailStartPct = sgParams.sgTrailStartPct;\n            configSnapshot.sgTrailDistancePct = sgParams.sgTrailDistancePct;\n            configSnapshot.sgTrailStepPct = sgParams.sgTrailStepPct;\n            configSnapshot.sgTpFixedEnabled = sgParams.sgTpFixedEnabled;\n            configSnapshot.sgTpFixedPct = sgParams.sgTpFixedPct;\n            configSnapshot.sgScaleOutEnabled = sgParams.sgScaleOutEnabled;\n            configSnapshot.sgScaleOutPct = sgParams.sgScaleOutPct;\n            configSnapshot.sgMinPartUsd = sgParams.sgMinPartUsd;\n            configSnapshot.sgScaleOutThreshold = sgParams.sgScaleOutThreshold;\n          }\n          \n          newPosition = { \n            lotId,\n            pair,\n            amount: volumeNum, \n            entryPrice: price,\n            highestPrice: price,\n            openedAt: Date.now(),\n            entryStrategyId,\n            entrySignalTf,\n            signalConfidence,\n            signalReason: reason,\n            entryMode,\n            configSnapshot,\n            // SMART_GUARD initial state\n            sgBreakEvenActivated: false,\n            sgCurrentStopPrice: undefined,\n            sgTrailingActivated: false,\n            sgScaleOutDone: false,\n          };\n          this.openPositions.set(lotId, newPosition);\n          \n          const lotCount = this.countLotsForPair(pair);\n          if (entryMode === \"SMART_GUARD\") {\n            log(`NEW LOT #${lotCount}: ${pair} (${lotId}) - SMART_GUARD snapshot saved (BE=${configSnapshot.sgBeAtPct}%, trail=${configSnapshot.sgTrailDistancePct}%, TP=${configSnapshot.sgTpFixedEnabled ? configSnapshot.sgTpFixedPct + '%' : 'OFF'})`, \"trading\");\n          } else {\n            log(`NEW POSITION: ${pair} (${lotId}) - snapshot saved (SL=${configSnapshot.stopLossPercent}%, TP=${configSnapshot.takeProfitPercent}%, trailing=${configSnapshot.trailingStopEnabled}, mode=${entryMode})`, \"trading\");\n          }\n        }\n        \n        // AI Sample collection: save features for ALL buy entries (not just new positions)\n        if (!newPosition.aiSampleId) {\n          try {\n            const features = aiService.extractFeatures({\n              rsi: 50, // Will be enriched from actual indicators in future\n              confidence: toConfidencePct(signalConfidence, 50),\n            });\n            const sampleTradeId = `SAMPLE-${Date.now()}-${pair}`;\n            const sample = await storage.saveAiSample({\n              tradeId: sampleTradeId,\n              pair,\n              side: \"buy\",\n              entryPrice: price.toString(),\n              entryTs: new Date(),\n              featuresJson: features,\n            });\n            if (sample?.id) {\n              newPosition.aiSampleId = sample.id;\n              log(`[AI] Sample #${sample.id} guardado para ${pair}`, \"trading\");\n            }\n          } catch (aiErr: any) {\n            log(`[AI] Error guardando sample: ${aiErr.message}`, \"trading\");\n          }\n        }\n        \n        await this.savePositionToDB(pair, newPosition);\n      } else {\n        // SELL: Update balance and P&L tracking\n        // Note: Position management for sells is now handled by the callers \n        // (checkSinglePositionSLTP, checkSmartGuardExit, forceClosePosition)\n        // which have the lotId context. This block only updates balance/P&L metrics.\n        this.currentUsdBalance += volumeNum * price;\n        \n        // Calculate P&L using sellContext if provided (for correct per-lot tracking)\n        if (sellContext) {\n          const pnl = (price - sellContext.entryPrice) * volumeNum;\n          this.dailyPnL += pnl;\n          log(`P&L de operaciÃ³n: $${pnl.toFixed(2)} | P&L diario acumulado: $${this.dailyPnL.toFixed(2)}`, \"trading\");\n          \n          // AI Sample update: mark sample complete with PnL result\n          if (sellContext.aiSampleId) {\n            try {\n              await storage.updateAiSample(sellContext.aiSampleId, {\n                exitPrice: price.toString(),\n                exitTs: new Date(),\n                pnlGross: pnl.toString(),\n                pnlNet: pnl.toString(),\n                labelWin: pnl > 0 ? 1 : 0,\n                isComplete: true,\n              });\n              log(`[AI] Sample #${sellContext.aiSampleId} actualizado: PnL=${pnl.toFixed(2)} (${pnl > 0 ? 'WIN' : 'LOSS'})`, \"trading\");\n            } catch (aiErr: any) {\n              log(`[AI] Error actualizando sample: ${aiErr.message}`, \"trading\");\n            }\n          }\n        } else {\n          // C1: sellContext no proporcionado - ya validado antes de ejecutar orden\n          // Si llegamos aquÃ­, es emergency exit permitido (P&L no registrado)\n          log(`[WARN] Emergency SELL completado sin sellContext para ${pair} - P&L no registrado.`, \"trading\");\n        }\n        // Position deletion is handled by the caller (checkSinglePositionSLTP, checkSmartGuardExit, etc.)\n      }\n\n      const emoji = type === \"buy\" ? \"ğŸŸ¢\" : \"ğŸ”´\";\n      const totalUSDFormatted = totalUSD.toFixed(2);\n      \n      if (this.telegramService.isInitialized()) {\n        const strategyLabel = strategyMeta?.strategyId ? \n          ((strategyMeta?.timeframe && strategyMeta.timeframe !== \"cycle\") ? \n            `Momentum (Velas ${strategyMeta.timeframe})` : \n            \"Momentum (Ciclos)\") : \n          \"Momentum (Ciclos)\";\n        const confidenceValue = strategyMeta?.confidence ? toConfidencePct(strategyMeta.confidence, 0).toFixed(0) : \"N/A\";\n        const tipoLabel = type === \"buy\" ? \"COMPRAR\" : \"VENDER\";\n        \n        await this.telegramService.sendMessage(`ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n${emoji} <b>SEÃ‘AL: ${tipoLabel} ${pair}</b> ${emoji}\n\nğŸ’µ <b>Precio:</b> <code>$${price.toFixed(2)}</code>\nğŸ“¦ <b>Cantidad:</b> <code>${volume}</code>\nğŸ’° <b>Total:</b> <code>$${totalUSDFormatted}</code>\n\nğŸ§  <b>Estrategia:</b> ${strategyLabel}\nğŸ“ˆ <b>Confianza:</b> <code>${confidenceValue}%</code>\n\nğŸ”— <b>ID:</b> <code>${txid}</code>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);\n      }\n\n      log(`Orden ejecutada: ${txid}`, \"trading\");\n      \n      await botLogger.info(\"TRADE_EXECUTED\", `Trade ${type.toUpperCase()} ejecutado en ${pair}`, {\n        pair,\n        type,\n        volume: volumeNum,\n        price,\n        totalUsd: volumeNum * price,\n        txid,\n        reason,\n        strategyId: strategyMeta?.strategyId || \"momentum_cycle\",\n        timeframe: strategyMeta?.timeframe || \"cycle\",\n        confidence: strategyMeta?.confidence,\n      });\n      \n      // FIFO Matcher: Ingest real sell fill and trigger automatic matching\n      // Only runs for real sells - DRY_RUN returns early at line ~3161\n      // Triple guard: check dryRunMode AND executionMeta.dryRun for belt-and-suspenders safety\n      const isSimulation = this.dryRunMode || (executionMeta?.dryRun ?? false);\n      if (type === \"sell\" && !isSimulation) {\n        try {\n          const fee = volumeNum * price * (KRAKEN_FEE_PCT / 100); // Use existing fee constant\n          await storage.upsertTradeFill({\n            txid,\n            pair,\n            type: \"sell\",\n            price: price.toString(),\n            amount: volume,\n            fee: fee.toFixed(8),\n            matched: false,\n          });\n          \n          const sellFill = await storage.getTradeFillByTxid(txid);\n          if (sellFill) {\n            const matchResult = await fifoMatcher.processSellFill(sellFill);\n            log(`[FIFO] Auto-matched sell ${txid}: matched=${matchResult.totalMatched.toFixed(8)}, lots_closed=${matchResult.lotsClosed}, pnl=$${matchResult.pnlNet.toFixed(2)}`, \"trading\");\n            \n            if (matchResult.lotsClosed > 0) {\n              await botLogger.info(\"FIFO_LOTS_CLOSED\", `FIFO cerrÃ³ ${matchResult.lotsClosed} lotes automÃ¡ticamente`, {\n                pair,\n                sellTxid: txid,\n                matchedQty: matchResult.totalMatched,\n                lotsClosed: matchResult.lotsClosed,\n                pnlNet: matchResult.pnlNet,\n              });\n            }\n          }\n        } catch (fifoErr: any) {\n          log(`[FIFO] Error procesando sell ${txid}: ${fifoErr.message}`, \"trading\");\n        }\n      }\n      \n      return true;\n    } catch (error: any) {\n      log(`Error ejecutando orden: ${error.message}`, \"trading\");\n      \n      await botLogger.error(\"TRADE_FAILED\", `Error ejecutando ${type} en ${pair}`, {\n        pair,\n        type,\n        volume,\n        price,\n        error: error.message,\n      });\n      \n      if (this.telegramService.isInitialized()) {\n        await this.telegramService.sendMessage(`ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâš ï¸ <b>Error en OperaciÃ³n</b>\n\nğŸ“¦ <b>Detalles:</b>\n   â€¢ Par: <code>${pair}</code>\n   â€¢ Tipo: <code>${type}</code>\n\nâŒ <b>Error:</b> <code>${error.message}</code>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);\n      }\n      return false;\n    }\n  }\n\n  private async getMultiTimeframeData(pair: string): Promise<MultiTimeframeData | null> {\n    try {\n      const cached = this.mtfCache.get(pair);\n      if (cached && Date.now() - cached.lastUpdate < this.MTF_CACHE_TTL) {\n        return cached;\n      }\n\n      const [tf5m, tf1h, tf4h] = await Promise.all([\n        this.krakenService.getOHLC(pair, 5),\n        this.krakenService.getOHLC(pair, 60),\n        this.krakenService.getOHLC(pair, 240),\n      ]);\n\n      const data: MultiTimeframeData = {\n        tf5m: tf5m.slice(-50),\n        tf1h: tf1h.slice(-50),\n        tf4h: tf4h.slice(-50),\n        lastUpdate: Date.now(),\n      };\n\n      this.mtfCache.set(pair, data);\n      log(`MTF datos actualizados para ${pair}: 5m=${tf5m.length}, 1h=${tf1h.length}, 4h=${tf4h.length}`, \"trading\");\n      return data;\n    } catch (error: any) {\n      log(`Error obteniendo datos MTF para ${pair}: ${error.message}`, \"trading\");\n      return null;\n    }\n  }\n\n  private analyzeTimeframeTrend(candles: OHLCCandle[]): \"bullish\" | \"bearish\" | \"neutral\" {\n    if (candles.length < 10) return \"neutral\";\n\n    const closes = candles.map(c => c.close);\n    const ema10 = this.calculateEMA(closes.slice(-10), 10);\n    const ema20 = this.calculateEMA(closes.slice(-20), 20);\n    const currentPrice = closes[closes.length - 1];\n\n    const priceVsEma10 = (currentPrice - ema10) / ema10 * 100;\n    const ema10VsEma20 = (ema10 - ema20) / ema20 * 100;\n\n    let score = 0;\n    if (priceVsEma10 > 0.5) score += 2;\n    else if (priceVsEma10 > 0) score += 1;\n    else if (priceVsEma10 < -0.5) score -= 2;\n    else if (priceVsEma10 < 0) score -= 1;\n\n    if (ema10VsEma20 > 0.3) score += 2;\n    else if (ema10VsEma20 > 0) score += 1;\n    else if (ema10VsEma20 < -0.3) score -= 2;\n    else if (ema10VsEma20 < 0) score -= 1;\n\n    const recentCandles = candles.slice(-5);\n    const higherHighs = recentCandles.filter((c, i) => i > 0 && c.high > recentCandles[i-1].high).length;\n    const lowerLows = recentCandles.filter((c, i) => i > 0 && c.low < recentCandles[i-1].low).length;\n    \n    if (higherHighs >= 3) score += 1;\n    if (lowerLows >= 3) score -= 1;\n\n    if (score >= 3) return \"bullish\";\n    if (score <= -3) return \"bearish\";\n    return \"neutral\";\n  }\n\n  private analyzeMultiTimeframe(mtfData: MultiTimeframeData): TrendAnalysis {\n    const shortTerm = this.analyzeTimeframeTrend(mtfData.tf5m);\n    const mediumTerm = this.analyzeTimeframeTrend(mtfData.tf1h);\n    const longTerm = this.analyzeTimeframeTrend(mtfData.tf4h);\n\n    const trendValues = { bullish: 1, neutral: 0, bearish: -1 };\n    const totalScore = trendValues[shortTerm] + trendValues[mediumTerm] * 1.5 + trendValues[longTerm] * 2;\n    \n    const allAligned = (shortTerm === mediumTerm && mediumTerm === longTerm && shortTerm !== \"neutral\");\n    const twoAligned = (shortTerm === mediumTerm || mediumTerm === longTerm || shortTerm === longTerm);\n    \n    let alignment = 0;\n    let confidence = 0.5;\n    \n    if (allAligned) {\n      alignment = trendValues[shortTerm];\n      confidence = 0.9;\n    } else if (twoAligned && shortTerm !== \"neutral\") {\n      alignment = totalScore > 0 ? 0.7 : totalScore < 0 ? -0.7 : 0;\n      confidence = 0.7;\n    } else {\n      alignment = totalScore / 4.5;\n      confidence = 0.5;\n    }\n\n    let summary = \"\";\n    if (allAligned) {\n      summary = `Tendencia ${shortTerm === \"bullish\" ? \"ALCISTA\" : \"BAJISTA\"} confirmada en todos los timeframes (5m/1h/4h)`;\n    } else {\n      summary = `5m: ${shortTerm}, 1h: ${mediumTerm}, 4h: ${longTerm}`;\n    }\n\n    return { shortTerm, mediumTerm, longTerm, alignment, confidence, summary };\n  }\n\n  isActive(): boolean {\n    return this.isRunning;\n  }\n\n  // === CIERRE MANUAL DE POSICIÃ“N ===\n  async forceClosePosition(\n    pair: string,\n    currentPrice: number,\n    correlationId: string,\n    reason: string,\n    lotId?: string // Optional: specify which lot to close (for multi-lot support)\n  ): Promise<{\n    success: boolean;\n    error?: string;\n    orderId?: string;\n    pnlUsd?: number;\n    pnlPct?: number;\n    dryRun?: boolean;\n    lotId?: string;\n    isDust?: boolean; // Flag para indicar que la posiciÃ³n es DUST y no se puede cerrar\n  }> {\n    try {\n      // Find the position to close\n      let position: OpenPosition | undefined;\n      if (lotId) {\n        position = this.openPositions.get(lotId);\n      } else {\n        // Close the first position for this pair\n        const positions = this.getPositionsByPair(pair);\n        position = positions[0];\n      }\n      \n      if (!position || position.amount <= 0) {\n        return {\n          success: false,\n          error: \"No se encontrÃ³ posiciÃ³n abierta en memoria para este par\",\n        };\n      }\n\n      const positionLotId = position.lotId;\n      const amount = position.amount;\n      const entryPrice = position.entryPrice;\n      const pnlUsd = (currentPrice - entryPrice) * amount;\n      const pnlPct = ((currentPrice - entryPrice) / entryPrice) * 100;\n\n      log(`[MANUAL_CLOSE] Iniciando cierre de ${pair} (${positionLotId}): ${amount.toFixed(8)} @ $${currentPrice.toFixed(2)}`, \"trading\");\n\n      // En DRY_RUN, simular el cierre\n      if (this.dryRunMode) {\n        const simTxid = `MANUAL-DRY-${Date.now()}`;\n        log(`[DRY_RUN] SIMULACIÃ“N cierre manual ${pair} (${positionLotId}) - ${amount.toFixed(8)} @ $${currentPrice.toFixed(2)}`, \"trading\");\n\n        // Actualizar memoria y DB para reflejar el cierre (aunque sea simulado)\n        this.openPositions.delete(positionLotId);\n        await storage.deleteOpenPositionByLotId(positionLotId);\n\n        // Registrar el trade de cierre\n        const tradeId = `MANUAL-${Date.now()}`;\n        await storage.createTrade({\n          tradeId,\n          pair,\n          type: \"sell\",\n          price: currentPrice.toString(),\n          amount: amount.toFixed(8),\n          status: \"filled\",\n          krakenOrderId: simTxid,\n          entryPrice: entryPrice.toString(),\n          realizedPnlUsd: pnlUsd.toString(),\n          realizedPnlPct: pnlPct.toString(),\n          executedAt: new Date(),\n        });\n\n        // Notificar por Telegram\n        if (this.telegramService.isInitialized()) {\n          const pnlEmoji = pnlUsd >= 0 ? \"ğŸ“ˆ\" : \"ğŸ“‰\";\n          await this.telegramService.sendMessage(`ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ§ª <b>Cierre Manual Simulado</b> [DRY_RUN]\n\nğŸ“¦ <b>Detalles:</b>\n   â€¢ Par: <code>${pair}</code>\n   â€¢ Cantidad: <code>${amount.toFixed(8)}</code>\n   â€¢ Precio entrada: <code>$${entryPrice.toFixed(2)}</code>\n   â€¢ Precio salida: <code>$${currentPrice.toFixed(2)}</code>\n\n${pnlEmoji} <b>PnL:</b> <code>${pnlUsd >= 0 ? \"+\" : \"\"}$${pnlUsd.toFixed(2)} (${pnlPct >= 0 ? \"+\" : \"\"}${pnlPct.toFixed(2)}%)</code>\n\nâš ï¸ Modo simulaciÃ³n - NO se enviÃ³ orden real\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);\n        }\n\n        return {\n          success: true,\n          orderId: simTxid,\n          pnlUsd,\n          pnlPct,\n          dryRun: true,\n          lotId: positionLotId,\n        };\n      }\n\n      // === VALIDACIÃ“N PRE-SELL: Verificar balance real y detectar DUST ===\n      const validation = await this.validateSellAmount(pair, positionLotId, amount);\n      \n      if (!validation.canSell) {\n        // Caso DUST: no se puede vender, devolver error con flag isDust\n        if (validation.isDust) {\n          // Enviar alerta Telegram\n          if (this.telegramService.isInitialized()) {\n            await this.telegramService.sendMessage(`ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nâš ï¸ <b>PosiciÃ³n DUST Detectada</b>\n\nğŸ“¦ <b>Detalles:</b>\n   â€¢ Par: <code>${pair}</code>\n   â€¢ Lot: <code>${positionLotId}</code>\n   â€¢ Cantidad registrada: <code>${amount.toFixed(8)}</code>\n   â€¢ Balance real: <code>${validation.realAssetBalance.toFixed(8)}</code>\n   â€¢ MÃ­nimo Kraken: <code>${validation.orderMin}</code>\n\nâ„¹ï¸ No se puede cerrar - usar \"Eliminar huÃ©rfana\" en UI\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);\n          }\n        }\n        \n        return {\n          success: false,\n          error: validation.reason,\n          lotId: positionLotId,\n          isDust: validation.isDust,\n        };\n      }\n      \n      // Si hubo ajuste de cantidad, actualizar posiciÃ³n interna\n      const sellAmountFinal = validation.sellAmountFinal;\n      if (validation.needsPositionAdjust) {\n        log(`[MANUAL_CLOSE] Ajustando posiciÃ³n ${pair} (${positionLotId}) de ${amount} a ${sellAmountFinal}`, \"trading\");\n        position.amount = sellAmountFinal;\n        this.openPositions.set(positionLotId, position);\n        await this.savePositionToDB(pair, position);\n      }\n      \n      // Recalcular PnL con cantidad real\n      const actualPnlUsd = (currentPrice - entryPrice) * sellAmountFinal;\n      const actualPnlPct = ((currentPrice - entryPrice) / entryPrice) * 100;\n\n      // PRODUCCIÃ“N: Ejecutar orden real de venta\n      const order = await this.krakenService.placeOrder({\n        pair,\n        type: \"sell\",\n        ordertype: \"market\",\n        volume: sellAmountFinal.toFixed(8),\n      });\n\n      const txid = order.txid?.[0];\n      if (!txid) {\n        return {\n          success: false,\n          error: \"Orden enviada pero no se recibiÃ³ txid de confirmaciÃ³n\",\n        };\n      }\n\n      // Actualizar memoria y DB (usar lotId para multi-lot)\n      this.openPositions.delete(positionLotId);\n      await storage.deleteOpenPositionByLotId(positionLotId);\n\n      // Registrar el trade de cierre\n      const tradeId = `MANUAL-${Date.now()}`;\n      await storage.createTrade({\n        tradeId,\n        pair,\n        type: \"sell\",\n        price: currentPrice.toString(),\n        amount: sellAmountFinal.toFixed(8),\n        status: \"filled\",\n        krakenOrderId: txid,\n        entryPrice: entryPrice.toString(),\n        realizedPnlUsd: actualPnlUsd.toString(),\n        realizedPnlPct: actualPnlPct.toString(),\n        executedAt: new Date(),\n      });\n\n      // Notificar por Telegram\n      if (this.telegramService.isInitialized()) {\n        const pnlEmoji = actualPnlUsd >= 0 ? \"ğŸ“ˆ\" : \"ğŸ“‰\";\n        await this.telegramService.sendMessage(`ğŸ¤– <b>KRAKEN BOT</b> ğŸ‡ªğŸ‡¸\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ”´ <b>Cierre Manual Ejecutado</b>\n\nğŸ“¦ <b>Detalles:</b>\n   â€¢ Par: <code>${pair}</code>\n   â€¢ Cantidad: <code>${sellAmountFinal.toFixed(8)}</code>\n   â€¢ Precio entrada: <code>$${entryPrice.toFixed(2)}</code>\n   â€¢ Precio salida: <code>$${currentPrice.toFixed(2)}</code>\n\n${pnlEmoji} <b>PnL:</b> <code>${actualPnlUsd >= 0 ? \"+\" : \"\"}$${actualPnlUsd.toFixed(2)} (${actualPnlPct >= 0 ? \"+\" : \"\"}${actualPnlPct.toFixed(2)}%)</code>\n\nğŸ”— <b>ID:</b> <code>${txid}</code>\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);\n      }\n\n      log(`[MANUAL_CLOSE] Cierre exitoso ${pair} (${positionLotId}) - Order: ${txid}, PnL: $${actualPnlUsd.toFixed(2)}`, \"trading\");\n\n      return {\n        success: true,\n        orderId: txid,\n        pnlUsd: actualPnlUsd,\n        pnlPct: actualPnlPct,\n        dryRun: false,\n        lotId: positionLotId,\n      };\n\n    } catch (error: any) {\n      log(`[MANUAL_CLOSE] Error al cerrar ${pair}: ${error.message}`, \"trading\");\n      return {\n        success: false,\n        error: error.message,\n      };\n    }\n  }\n\n  getOpenPositions(): Map<string, { amount: number; entryPrice: number }> {\n    return this.openPositions;\n  }\n\n  // === DIAGNÃ“STICO: Obtener resultados del scan con razones en espaÃ±ol ===\n  async getScanDiagnostic(): Promise<{\n    pairs: Array<{\n      pair: string;\n      signal: string;\n      razon: string;\n      cooldownSec?: number;\n      exposureAvailable?: number;\n      hasPosition: boolean;\n      positionUsd?: number;\n    }>;\n    positionMode: string;\n    usdBalance: number;\n    totalOpenPositions: number;\n    lastScanAt: string | null;\n  }> {\n    const config = await storage.getBotConfig();\n    const positionMode = config?.positionMode || \"SINGLE\";\n    \n    // Mapeo de razones a espaÃ±ol (segÃºn documento SMART_GUARD)\n    const reasonTranslations: Record<string, string> = {\n      \"PAIR_COOLDOWN\": \"En enfriamiento - esperando reintentos\",\n      \"SINGLE_MODE_POSITION_EXISTS\": \"Ya hay posiciÃ³n abierta en este par\",\n      \"SMART_GUARD_POSITION_EXISTS\": \"Ya hay posiciÃ³n abierta en este par\",\n      \"SMART_GUARD_MAX_LOTS_REACHED\": \"MÃ¡ximo de lotes abiertos alcanzado para este par\",\n      \"STOPLOSS_COOLDOWN\": \"Enfriamiento post stop-loss activo\",\n      \"SPREAD_TOO_HIGH\": \"Spread demasiado alto para operar\",\n      \"POSITION_TOO_LARGE\": \"PosiciÃ³n existente demasiado grande\",\n      \"INSUFFICIENT_FUNDS\": \"Fondos USD insuficientes\",\n      \"LOW_PROFITABILITY\": \"Take-profit menor que comisiones\",\n      \"EXPOSURE_ZERO\": \"Sin exposiciÃ³n disponible\",\n      \"VOLUME_BELOW_MINIMUM\": \"Volumen calculado < mÃ­nimo Kraken\",\n      \"SG_MIN_ENTRY_NOT_MET\": \"MÃ­nimo por operaciÃ³n no alcanzado (tiene saldo, pero tamaÃ±o quedÃ³ por debajo)\",\n      \"SG_REDUCED_ENTRY\": \"Saldo por debajo del mÃ­nimo â€” entro con lo disponible\",\n      \"MIN_ORDER_ABSOLUTE\": \"Por debajo del mÃ­nimo absoluto ($20) â€” mÃ­nimo exchange no alcanzado\",\n      \"MIN_ORDER_USD\": \"SKIP - MÃ­nimo por orden no alcanzado (allowUnderMin=OFF)\",\n      \"NO_POSITION\": \"Sin posiciÃ³n para vender\",\n      \"AI_FILTER_REJECTED\": \"SeÃ±al rechazada por filtro IA\",\n      \"Sin seÃ±al\": \"Sin seÃ±al de trading activa\",\n    };\n\n    const pairs: Array<{\n      pair: string;\n      signal: string;\n      razon: string;\n      cooldownSec?: number;\n      exposureAvailable?: number;\n      hasPosition: boolean;\n      positionUsd?: number;\n    }> = [];\n\n    // Helper: buscar posiciones por par (openPositions usa lotId como clave, no pair)\n    const getPositionsForPair = (targetPair: string): OpenPosition[] => {\n      const positions: OpenPosition[] = [];\n      this.openPositions.forEach((pos) => {\n        if (pos.pair === targetPair && pos.amount > 0) {\n          positions.push(pos);\n        }\n      });\n      return positions;\n    };\n\n    // Si hay datos de escaneo, usar esos\n    if (this.lastScanResults.size > 0) {\n      this.lastScanResults.forEach((result, pair) => {\n        const pairPositions = getPositionsForPair(pair);\n        const hasPosition = pairPositions.length > 0;\n        const totalPositionUsd = pairPositions.reduce((sum, p) => sum + (p.amount * p.entryPrice), 0);\n        \n        // Traducir la razÃ³n\n        let razon = result.reason;\n        for (const [key, value] of Object.entries(reasonTranslations)) {\n          if (razon.includes(key) || razon === key) {\n            razon = value;\n            break;\n          }\n        }\n\n        // Obtener cooldown si no viene en el resultado\n        const cooldownSec = result.cooldownSec ?? this.getCooldownRemainingSec(pair);\n\n        pairs.push({\n          pair,\n          signal: result.signal,\n          razon,\n          cooldownSec: cooldownSec > 0 ? cooldownSec : undefined,\n          exposureAvailable: result.exposureAvailable,\n          hasPosition,\n          positionUsd: hasPosition ? totalPositionUsd : undefined,\n        });\n      });\n    } else {\n      // Si no hay datos de escaneo, mostrar pares activos con info bÃ¡sica\n      const activePairs = config?.activePairs || [];\n      for (const pair of activePairs) {\n        const pairPositions = getPositionsForPair(pair);\n        const hasPosition = pairPositions.length > 0;\n        const totalPositionUsd = pairPositions.reduce((sum, p) => sum + (p.amount * p.entryPrice), 0);\n        const exposure = this.getAvailableExposure(pair, config, this.currentUsdBalance);\n        \n        // Determinar razÃ³n basada en el estado real\n        let razon = \"Bot inactivo - actÃ­valo para escanear\";\n        if (this.isRunning) {\n          if (this.lastScanTime > 0) {\n            // El bot ha escaneado pero este par no tiene resultado (puede ser por filtro u otra razÃ³n)\n            razon = \"Sin seÃ±al activa\";\n          } else {\n            razon = \"Esperando primer escaneo...\";\n          }\n        }\n        \n        const cooldownSec = this.getCooldownRemainingSec(pair);\n        pairs.push({\n          pair,\n          signal: \"NONE\",\n          razon,\n          cooldownSec: cooldownSec > 0 ? cooldownSec : undefined,\n          exposureAvailable: exposure.maxAllowed,\n          hasPosition,\n          positionUsd: hasPosition ? totalPositionUsd : undefined,\n        });\n      }\n    }\n\n    return {\n      pairs,\n      positionMode,\n      usdBalance: this.currentUsdBalance,\n      totalOpenPositions: this.openPositions.size,\n      lastScanAt: this.lastScanTime > 0 ? new Date(this.lastScanTime).toISOString() : null,\n    };\n  }\n}\n","path":null,"size_bytes":170396,"size_tokens":null},"client/src/pages/Integrations.tsx":{"content":"import { useState, useEffect } from \"react\";\nimport { Nav } from \"@/components/dashboard/Nav\";\nimport generatedImage from '@assets/generated_images/dark_digital_hex_grid_background.png';\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription } from \"@/components/ui/card\";\nimport { Label } from \"@/components/ui/label\";\nimport { Input } from \"@/components/ui/input\";\nimport { Button } from \"@/components/ui/button\";\nimport { Switch } from \"@/components/ui/switch\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { MessageSquare, Server, Check, Send, Plus, Trash2, Users, Plug, Eye, EyeOff } from \"lucide-react\";\nimport { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { toast } from \"sonner\";\n\ninterface TelegramChat {\n  id: number;\n  name: string;\n  chatId: string;\n  alertTrades: boolean;\n  alertErrors: boolean;\n  alertSystem: boolean;\n  alertBalance: boolean;\n  isActive: boolean;\n}\n\nexport default function Integrations() {\n  const queryClient = useQueryClient();\n  const [krakenApiKey, setKrakenApiKey] = useState(\"\");\n  const [krakenSecret, setKrakenSecret] = useState(\"\");\n  const [krakenConnected, setKrakenConnected] = useState(false);\n  const [showKrakenKey, setShowKrakenKey] = useState(false);\n  const [showKrakenSecret, setShowKrakenSecret] = useState(false);\n  \n  const [telegramToken, setTelegramToken] = useState(\"\");\n  const [telegramChatId, setTelegramChatId] = useState(\"\");\n  const [telegramConnected, setTelegramConnected] = useState(false);\n  const [showTelegramToken, setShowTelegramToken] = useState(false);\n  const [customMessage, setCustomMessage] = useState(\"\");\n\n  const [newChatName, setNewChatName] = useState(\"\");\n  const [newChatId, setNewChatId] = useState(\"\");\n  const [newAlertTrades, setNewAlertTrades] = useState(true);\n  const [newAlertErrors, setNewAlertErrors] = useState(true);\n  const [newAlertSystem, setNewAlertSystem] = useState(true);\n  const [newAlertBalance, setNewAlertBalance] = useState(false);\n\n  const { data: apiConfig } = useQuery({\n    queryKey: [\"apiConfig\"],\n    queryFn: async () => {\n      const res = await fetch(\"/api/config/api\");\n      if (!res.ok) throw new Error(\"Failed to fetch config\");\n      return res.json();\n    },\n  });\n\n  const { data: telegramChats = [] } = useQuery<TelegramChat[]>({\n    queryKey: [\"telegramChats\"],\n    queryFn: async () => {\n      const res = await fetch(\"/api/telegram/chats\");\n      if (!res.ok) throw new Error(\"Failed to fetch chats\");\n      return res.json();\n    },\n  });\n\n  useEffect(() => {\n    if (apiConfig) {\n      setKrakenConnected(apiConfig.krakenConnected);\n      setTelegramConnected(apiConfig.telegramConnected);\n    }\n  }, [apiConfig]);\n\n  const krakenMutation = useMutation({\n    mutationFn: async () => {\n      const res = await fetch(\"/api/config/kraken\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ apiKey: krakenApiKey, apiSecret: krakenSecret }),\n      });\n      if (!res.ok) throw new Error(\"Failed to connect\");\n      return res.json();\n    },\n    onSuccess: () => {\n      setKrakenConnected(true);\n      toast.success(\"Kraken conectado correctamente\");\n    },\n    onError: () => {\n      toast.error(\"Error al conectar con Kraken\");\n    },\n  });\n\n  const telegramMutation = useMutation({\n    mutationFn: async () => {\n      const res = await fetch(\"/api/config/telegram\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ token: telegramToken, chatId: telegramChatId }),\n      });\n      if (!res.ok) throw new Error(\"Failed to connect\");\n      return res.json();\n    },\n    onSuccess: () => {\n      setTelegramConnected(true);\n      toast.success(\"Telegram conectado correctamente\");\n    },\n    onError: () => {\n      toast.error(\"Error al conectar con Telegram\");\n    },\n  });\n\n  const sendMessageMutation = useMutation({\n    mutationFn: async () => {\n      const res = await fetch(\"/api/telegram/send\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ message: customMessage }),\n      });\n      if (!res.ok) throw new Error(\"Failed to send\");\n      return res.json();\n    },\n    onSuccess: () => {\n      toast.success(\"Mensaje enviado a Telegram\");\n      setCustomMessage(\"\");\n    },\n    onError: () => {\n      toast.error(\"Error al enviar mensaje\");\n    },\n  });\n\n  const createChatMutation = useMutation({\n    mutationFn: async () => {\n      const res = await fetch(\"/api/telegram/chats\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          name: newChatName,\n          chatId: newChatId,\n          alertTrades: newAlertTrades,\n          alertErrors: newAlertErrors,\n          alertSystem: newAlertSystem,\n          alertBalance: newAlertBalance,\n        }),\n      });\n      if (!res.ok) {\n        const error = await res.json();\n        throw new Error(error.error || \"Failed to create chat\");\n      }\n      return res.json();\n    },\n    onSuccess: () => {\n      toast.success(\"Chat aÃ±adido correctamente\");\n      setNewChatName(\"\");\n      setNewChatId(\"\");\n      setNewAlertTrades(true);\n      setNewAlertErrors(true);\n      setNewAlertSystem(true);\n      setNewAlertBalance(false);\n      queryClient.invalidateQueries({ queryKey: [\"telegramChats\"] });\n    },\n    onError: (error: Error) => {\n      toast.error(error.message);\n    },\n  });\n\n  const deleteChatMutation = useMutation({\n    mutationFn: async (id: number) => {\n      const res = await fetch(`/api/telegram/chats/${id}`, {\n        method: \"DELETE\",\n      });\n      if (!res.ok) throw new Error(\"Failed to delete\");\n      return res.json();\n    },\n    onSuccess: () => {\n      toast.success(\"Chat eliminado\");\n      queryClient.invalidateQueries({ queryKey: [\"telegramChats\"] });\n    },\n    onError: () => {\n      toast.error(\"Error al eliminar chat\");\n    },\n  });\n\n  const updateChatMutation = useMutation({\n    mutationFn: async ({ id, ...data }: { id: number } & Partial<TelegramChat>) => {\n      const res = await fetch(`/api/telegram/chats/${id}`, {\n        method: \"PUT\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(data),\n      });\n      if (!res.ok) throw new Error(\"Failed to update\");\n      return res.json();\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: [\"telegramChats\"] });\n    },\n    onError: () => {\n      toast.error(\"Error al actualizar chat\");\n    },\n  });\n\n  return (\n    <div className=\"min-h-screen bg-background flex flex-col relative overflow-hidden\">\n      <div \n        className=\"fixed inset-0 z-0 opacity-20 pointer-events-none\" \n        style={{ \n          backgroundImage: `url(${generatedImage})`, \n          backgroundSize: 'cover',\n          backgroundPosition: 'center',\n          mixBlendMode: 'overlay'\n        }} \n      />\n      \n      <div className=\"relative z-10 flex flex-col min-h-screen\">\n        <Nav />\n        \n        <main className=\"flex-1 p-6 max-w-4xl mx-auto w-full space-y-8\">\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <h1 className=\"text-3xl font-bold font-sans tracking-tight flex items-center gap-3\">\n                <Plug className=\"h-8 w-8 text-primary\" />\n                Integraciones\n              </h1>\n              <p className=\"text-muted-foreground mt-1\">Gestiona todas las conexiones y credenciales de APIs.</p>\n            </div>\n          </div>\n\n          <div className=\"grid gap-6\">\n            {/* Kraken API */}\n            <Card className=\"glass-panel border-border/50\">\n              <CardHeader>\n                <div className=\"flex items-center gap-3\">\n                  <div className=\"p-2 bg-orange-500/20 rounded-lg\">\n                    <Server className=\"h-6 w-6 text-orange-400\" />\n                  </div>\n                  <div className=\"flex-1\">\n                    <CardTitle>Kraken Exchange</CardTitle>\n                    <CardDescription>Conecta tu cuenta de Kraken para trading real.</CardDescription>\n                  </div>\n                  {krakenConnected ? (\n                    <div className=\"flex items-center gap-2 text-green-500\">\n                      <Check className=\"h-5 w-5\" />\n                      <span className=\"text-sm font-mono\">CONECTADO</span>\n                    </div>\n                  ) : (\n                    <span className=\"text-sm font-mono text-yellow-500\">DESCONECTADO</span>\n                  )}\n                </div>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                <div className=\"grid gap-2\">\n                  <Label>API Key</Label>\n                  <div className=\"relative\">\n                    <Input \n                      type={showKrakenKey ? \"text\" : \"password\"}\n                      placeholder=\"Tu Kraken API Key\" \n                      className=\"font-mono bg-background/50 pr-10\"\n                      value={krakenApiKey}\n                      onChange={(e) => setKrakenApiKey(e.target.value)}\n                      data-testid=\"input-kraken-api-key\"\n                    />\n                    <Button\n                      type=\"button\"\n                      variant=\"ghost\"\n                      size=\"icon\"\n                      className=\"absolute right-0 top-0 h-full\"\n                      onClick={() => setShowKrakenKey(!showKrakenKey)}\n                    >\n                      {showKrakenKey ? <EyeOff className=\"h-4 w-4\" /> : <Eye className=\"h-4 w-4\" />}\n                    </Button>\n                  </div>\n                </div>\n                <div className=\"grid gap-2\">\n                  <Label>API Secret</Label>\n                  <div className=\"relative\">\n                    <Input \n                      type={showKrakenSecret ? \"text\" : \"password\"}\n                      placeholder=\"Tu Kraken API Secret\" \n                      className=\"font-mono bg-background/50 pr-10\"\n                      value={krakenSecret}\n                      onChange={(e) => setKrakenSecret(e.target.value)}\n                      data-testid=\"input-kraken-secret\"\n                    />\n                    <Button\n                      type=\"button\"\n                      variant=\"ghost\"\n                      size=\"icon\"\n                      className=\"absolute right-0 top-0 h-full\"\n                      onClick={() => setShowKrakenSecret(!showKrakenSecret)}\n                    >\n                      {showKrakenSecret ? <EyeOff className=\"h-4 w-4\" /> : <Eye className=\"h-4 w-4\" />}\n                    </Button>\n                  </div>\n                </div>\n                <Button \n                  className=\"w-full bg-orange-600 hover:bg-orange-700\" \n                  onClick={() => krakenMutation.mutate()}\n                  disabled={!krakenApiKey || !krakenSecret || krakenMutation.isPending}\n                  data-testid=\"button-connect-kraken\"\n                >\n                  {krakenMutation.isPending ? \"Conectando...\" : krakenConnected ? \"Reconectar\" : \"Conectar a Kraken\"}\n                </Button>\n                <p className=\"text-xs text-muted-foreground\">\n                  ObtÃ©n tus credenciales en <a href=\"https://www.kraken.com/u/security/api\" target=\"_blank\" rel=\"noopener\" className=\"text-primary hover:underline\">kraken.com/u/security/api</a>\n                </p>\n              </CardContent>\n            </Card>\n\n            {/* Telegram Bot */}\n            <Card className=\"glass-panel border-border/50\">\n              <CardHeader>\n                <div className=\"flex items-center gap-3\">\n                  <div className=\"p-2 bg-blue-500/20 rounded-lg\">\n                    <MessageSquare className=\"h-6 w-6 text-blue-400\" />\n                  </div>\n                  <div className=\"flex-1\">\n                    <CardTitle>Telegram Bot</CardTitle>\n                    <CardDescription>Recibe alertas y controla el bot desde Telegram.</CardDescription>\n                  </div>\n                  {telegramConnected ? (\n                    <div className=\"flex items-center gap-2 text-green-500\">\n                      <Check className=\"h-5 w-5\" />\n                      <span className=\"text-sm font-mono\">CONECTADO</span>\n                    </div>\n                  ) : (\n                    <span className=\"text-sm font-mono text-yellow-500\">DESCONECTADO</span>\n                  )}\n                </div>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                <div className=\"grid gap-2\">\n                  <Label>Bot Token (de @BotFather)</Label>\n                  <div className=\"relative\">\n                    <Input \n                      type={showTelegramToken ? \"text\" : \"password\"}\n                      placeholder=\"123456789:ABCdefGHIjklMNOpqrsTUVwxyz\" \n                      className=\"font-mono bg-background/50 pr-10\"\n                      value={telegramToken}\n                      onChange={(e) => setTelegramToken(e.target.value)}\n                      data-testid=\"input-telegram-token\"\n                    />\n                    <Button\n                      type=\"button\"\n                      variant=\"ghost\"\n                      size=\"icon\"\n                      className=\"absolute right-0 top-0 h-full\"\n                      onClick={() => setShowTelegramToken(!showTelegramToken)}\n                    >\n                      {showTelegramToken ? <EyeOff className=\"h-4 w-4\" /> : <Eye className=\"h-4 w-4\" />}\n                    </Button>\n                  </div>\n                </div>\n                <div className=\"grid gap-2\">\n                  <Label>Chat ID principal</Label>\n                  <Input \n                    placeholder=\"-1001234567890\" \n                    className=\"font-mono bg-background/50\"\n                    value={telegramChatId}\n                    onChange={(e) => setTelegramChatId(e.target.value)}\n                    data-testid=\"input-telegram-chatid\"\n                  />\n                </div>\n                <Button \n                  className=\"w-full\"\n                  onClick={() => telegramMutation.mutate()}\n                  disabled={!telegramToken || !telegramChatId || telegramMutation.isPending}\n                  data-testid=\"button-connect-telegram\"\n                >\n                  {telegramMutation.isPending ? \"Probando...\" : telegramConnected ? \"Reconectar\" : \"Conectar Telegram\"}\n                </Button>\n                \n                {telegramConnected && (\n                  <div className=\"pt-4 border-t border-border/50 space-y-3\">\n                    <Label>Enviar mensaje de prueba</Label>\n                    <Textarea\n                      placeholder=\"Escribe un mensaje para enviar a Telegram...\"\n                      className=\"bg-background/50 min-h-[80px]\"\n                      value={customMessage}\n                      onChange={(e) => setCustomMessage(e.target.value)}\n                      data-testid=\"input-custom-message\"\n                    />\n                    <Button \n                      variant=\"outline\"\n                      className=\"w-full\"\n                      onClick={() => sendMessageMutation.mutate()}\n                      disabled={!customMessage.trim() || sendMessageMutation.isPending}\n                      data-testid=\"button-send-message\"\n                    >\n                      <Send className=\"mr-2 h-4 w-4\" />\n                      {sendMessageMutation.isPending ? \"Enviando...\" : \"Enviar Mensaje\"}\n                    </Button>\n                    <p className=\"text-xs text-muted-foreground\">\n                      Comandos: /estado, /pausar, /reanudar, /ultimas, /ayuda\n                    </p>\n                  </div>\n                )}\n              </CardContent>\n            </Card>\n\n            {/* Multi-Chat Telegram */}\n            {telegramConnected && (\n              <Card className=\"glass-panel border-border/50\">\n                <CardHeader>\n                  <div className=\"flex items-center gap-3\">\n                    <div className=\"p-2 bg-purple-500/20 rounded-lg\">\n                      <Users className=\"h-6 w-6 text-purple-400\" />\n                    </div>\n                    <div className=\"flex-1\">\n                      <CardTitle>Multi-Chat Telegram</CardTitle>\n                      <CardDescription>EnvÃ­a alertas a mÃºltiples chats con configuraciÃ³n individual.</CardDescription>\n                    </div>\n                    <span className=\"text-sm text-muted-foreground\">{telegramChats.length} chat(s)</span>\n                  </div>\n                </CardHeader>\n                <CardContent className=\"space-y-4\">\n                  {telegramChats.length > 0 && (\n                    <div className=\"space-y-3\">\n                      {telegramChats.map((chat) => (\n                        <div key={chat.id} className=\"p-4 border border-border rounded-lg bg-card/30 space-y-3\">\n                          <div className=\"flex items-center justify-between\">\n                            <div className=\"flex items-center gap-2\">\n                              <span className={`h-2 w-2 rounded-full ${chat.isActive ? 'bg-green-500' : 'bg-gray-500'}`}></span>\n                              <span className=\"font-medium\">{chat.name}</span>\n                              <span className=\"text-xs text-muted-foreground font-mono\">({chat.chatId})</span>\n                            </div>\n                            <div className=\"flex items-center gap-2\">\n                              <Switch \n                                checked={chat.isActive}\n                                onCheckedChange={(checked) => updateChatMutation.mutate({ id: chat.id, isActive: checked })}\n                              />\n                              <Button \n                                variant=\"ghost\" \n                                size=\"icon\"\n                                onClick={() => deleteChatMutation.mutate(chat.id)}\n                                data-testid={`button-delete-chat-${chat.id}`}\n                              >\n                                <Trash2 className=\"h-4 w-4 text-red-500\" />\n                              </Button>\n                            </div>\n                          </div>\n                          <div className=\"flex flex-wrap gap-2\">\n                            <Button \n                              variant={chat.alertTrades ? \"default\" : \"outline\"} \n                              size=\"sm\"\n                              onClick={() => updateChatMutation.mutate({ id: chat.id, alertTrades: !chat.alertTrades })}\n                            >\n                              Trades\n                            </Button>\n                            <Button \n                              variant={chat.alertErrors ? \"default\" : \"outline\"} \n                              size=\"sm\"\n                              onClick={() => updateChatMutation.mutate({ id: chat.id, alertErrors: !chat.alertErrors })}\n                            >\n                              Errores\n                            </Button>\n                            <Button \n                              variant={chat.alertSystem ? \"default\" : \"outline\"} \n                              size=\"sm\"\n                              onClick={() => updateChatMutation.mutate({ id: chat.id, alertSystem: !chat.alertSystem })}\n                            >\n                              Sistema\n                            </Button>\n                            <Button \n                              variant={chat.alertBalance ? \"default\" : \"outline\"} \n                              size=\"sm\"\n                              onClick={() => updateChatMutation.mutate({ id: chat.id, alertBalance: !chat.alertBalance })}\n                            >\n                              Balance\n                            </Button>\n                          </div>\n                        </div>\n                      ))}\n                    </div>\n                  )}\n\n                  <div className=\"pt-4 border-t border-border/50 space-y-3\">\n                    <Label className=\"flex items-center gap-2\">\n                      <Plus className=\"h-4 w-4\" /> AÃ±adir nuevo chat\n                    </Label>\n                    <div className=\"grid grid-cols-2 gap-3\">\n                      <div className=\"grid gap-2\">\n                        <Label className=\"text-xs\">Nombre</Label>\n                        <Input \n                          placeholder=\"Mi grupo\" \n                          className=\"bg-background/50\"\n                          value={newChatName}\n                          onChange={(e) => setNewChatName(e.target.value)}\n                          data-testid=\"input-new-chat-name\"\n                        />\n                      </div>\n                      <div className=\"grid gap-2\">\n                        <Label className=\"text-xs\">Chat ID</Label>\n                        <Input \n                          placeholder=\"-1001234567890\" \n                          className=\"font-mono bg-background/50\"\n                          value={newChatId}\n                          onChange={(e) => setNewChatId(e.target.value)}\n                          data-testid=\"input-new-chat-id\"\n                        />\n                      </div>\n                    </div>\n                    <div className=\"flex flex-wrap gap-4\">\n                      <div className=\"flex items-center gap-2\">\n                        <Switch checked={newAlertTrades} onCheckedChange={setNewAlertTrades} />\n                        <Label className=\"text-sm\">Trades</Label>\n                      </div>\n                      <div className=\"flex items-center gap-2\">\n                        <Switch checked={newAlertErrors} onCheckedChange={setNewAlertErrors} />\n                        <Label className=\"text-sm\">Errores</Label>\n                      </div>\n                      <div className=\"flex items-center gap-2\">\n                        <Switch checked={newAlertSystem} onCheckedChange={setNewAlertSystem} />\n                        <Label className=\"text-sm\">Sistema</Label>\n                      </div>\n                      <div className=\"flex items-center gap-2\">\n                        <Switch checked={newAlertBalance} onCheckedChange={setNewAlertBalance} />\n                        <Label className=\"text-sm\">Balance</Label>\n                      </div>\n                    </div>\n                    <Button \n                      className=\"w-full\"\n                      onClick={() => createChatMutation.mutate()}\n                      disabled={!newChatName.trim() || !newChatId.trim() || createChatMutation.isPending}\n                      data-testid=\"button-add-chat\"\n                    >\n                      <Plus className=\"mr-2 h-4 w-4\" />\n                      {createChatMutation.isPending ? \"AÃ±adiendo...\" : \"AÃ±adir Chat\"}\n                    </Button>\n                  </div>\n                </CardContent>\n              </Card>\n            )}\n\n          </div>\n        </main>\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":23168,"size_tokens":null},"client/src/pages/Guide.tsx":{"content":"import { Nav } from \"@/components/dashboard/Nav\";\nimport generatedImage from '@assets/generated_images/dark_digital_hex_grid_background.png';\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription } from \"@/components/ui/card\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from \"@/components/ui/accordion\";\nimport { \n  BookOpen, \n  Zap, \n  Settings, \n  AlertTriangle, \n  CheckCircle2, \n  TrendingUp, \n  TrendingDown,\n  Activity,\n  Target,\n  RefreshCw,\n  Shield,\n  DollarSign,\n  Clock,\n  BarChart3,\n  Plug,\n  HelpCircle,\n  ListChecks,\n  Lightbulb,\n  XCircle,\n  WifiOff,\n  Key,\n  Percent,\n  CandlestickChart,\n  Bell,\n  Database\n} from \"lucide-react\";\n\nexport default function Guide() {\n  return (\n    <div className=\"min-h-screen bg-background flex flex-col relative overflow-hidden\">\n      <div \n        className=\"fixed inset-0 z-0 opacity-20 pointer-events-none\" \n        style={{ \n          backgroundImage: `url(${generatedImage})`, \n          backgroundSize: 'cover',\n          backgroundPosition: 'center',\n          mixBlendMode: 'overlay'\n        }} \n      />\n      \n      <div className=\"relative z-10 flex flex-col min-h-screen\">\n        <Nav />\n        \n        <main className=\"flex-1 p-4 md:p-6 max-w-5xl mx-auto w-full space-y-6 md:space-y-8\">\n          <div className=\"flex items-center gap-3\">\n            <div className=\"p-2 bg-primary/20 rounded-lg\">\n              <BookOpen className=\"h-6 w-6 md:h-8 md:w-8 text-primary\" />\n            </div>\n            <div>\n              <h1 className=\"text-xl md:text-3xl font-bold font-sans tracking-tight\">GuÃ­a del Bot</h1>\n              <p className=\"text-sm md:text-base text-muted-foreground\">Manual completo de uso y configuraciÃ³n</p>\n            </div>\n          </div>\n\n          <div className=\"grid gap-6\">\n            \n            {/* SecciÃ³n 1: Â¿QuÃ© hace este bot? */}\n            <Card className=\"glass-panel border-border/50\">\n              <CardHeader>\n                <div className=\"flex items-center gap-3\">\n                  <div className=\"p-2 bg-cyan-500/20 rounded-lg\">\n                    <Zap className=\"h-6 w-6 text-cyan-400\" />\n                  </div>\n                  <div>\n                    <CardTitle className=\"text-lg md:text-xl\">1. Â¿QuÃ© hace este bot?</CardTitle>\n                    <CardDescription>Resumen general del funcionamiento</CardDescription>\n                  </div>\n                </div>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                <p className=\"text-sm md:text-base text-muted-foreground leading-relaxed\">\n                  KrakenBot.AI es un bot de trading automÃ¡tico que opera en el exchange Kraken. \n                  Analiza el mercado 24/7 usando indicadores tÃ©cnicos avanzados y ejecuta operaciones \n                  de compra/venta de forma autÃ³noma segÃºn la estrategia configurada.\n                </p>\n                \n                <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n                  <div className=\"p-4 border border-border rounded-lg bg-card/30\">\n                    <h4 className=\"font-semibold mb-2 flex items-center gap-2\">\n                      <Activity className=\"h-4 w-4 text-primary\" />\n                      Estrategias incluidas\n                    </h4>\n                    <ul className=\"text-sm text-muted-foreground space-y-1\">\n                      <li className=\"flex items-center gap-2\">\n                        <TrendingUp className=\"h-3 w-3 text-green-500\" />\n                        <strong>Momentum:</strong> Sigue tendencias fuertes\n                      </li>\n                      <li className=\"flex items-center gap-2\">\n                        <RefreshCw className=\"h-3 w-3 text-blue-500\" />\n                        <strong>ReversiÃ³n a la media:</strong> Opera en extremos\n                      </li>\n                      <li className=\"flex items-center gap-2\">\n                        <Zap className=\"h-3 w-3 text-yellow-500\" />\n                        <strong>Scalping:</strong> Operaciones rÃ¡pidas\n                      </li>\n                      <li className=\"flex items-center gap-2\">\n                        <Target className=\"h-3 w-3 text-purple-500\" />\n                        <strong>Grid:</strong> Ã“rdenes escalonadas\n                      </li>\n                    </ul>\n                  </div>\n                  \n                  <div className=\"p-4 border border-border rounded-lg bg-card/30\">\n                    <h4 className=\"font-semibold mb-2 flex items-center gap-2\">\n                      <DollarSign className=\"h-4 w-4 text-primary\" />\n                      Pares soportados\n                    </h4>\n                    <div className=\"flex flex-wrap gap-2\">\n                      <Badge variant=\"outline\">BTC/USD</Badge>\n                      <Badge variant=\"outline\">ETH/USD</Badge>\n                      <Badge variant=\"outline\">SOL/USD</Badge>\n                      <Badge variant=\"outline\">XRP/USD</Badge>\n                      <Badge variant=\"outline\">TON/USD</Badge>\n                      <Badge variant=\"outline\">ETH/BTC</Badge>\n                    </div>\n                  </div>\n                </div>\n\n                <div className=\"p-4 border border-primary/30 rounded-lg bg-primary/5\">\n                  <h4 className=\"font-semibold mb-2 flex items-center gap-2\">\n                    <BarChart3 className=\"h-4 w-4 text-primary\" />\n                    Indicadores tÃ©cnicos utilizados\n                  </h4>\n                  <div className=\"grid grid-cols-2 md:grid-cols-4 gap-2 text-sm\">\n                    <span className=\"text-muted-foreground\">â€¢ MACD</span>\n                    <span className=\"text-muted-foreground\">â€¢ RSI</span>\n                    <span className=\"text-muted-foreground\">â€¢ Bollinger Bands</span>\n                    <span className=\"text-muted-foreground\">â€¢ EMAs (9, 21, 50)</span>\n                    <span className=\"text-muted-foreground\">â€¢ Volumen</span>\n                    <span className=\"text-muted-foreground\">â€¢ ATR</span>\n                    <span className=\"text-muted-foreground\">â€¢ Multi-timeframe</span>\n                    <span className=\"text-muted-foreground\">â€¢ AnÃ¡lisis de tendencia</span>\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n\n            {/* SecciÃ³n 2: Pasos para usar el bot */}\n            <Card className=\"glass-panel border-border/50\">\n              <CardHeader>\n                <div className=\"flex items-center gap-3\">\n                  <div className=\"p-2 bg-green-500/20 rounded-lg\">\n                    <ListChecks className=\"h-6 w-6 text-green-400\" />\n                  </div>\n                  <div>\n                    <CardTitle className=\"text-lg md:text-xl\">2. Pasos para usar el bot</CardTitle>\n                    <CardDescription>Flujo bÃ¡sico de configuraciÃ³n</CardDescription>\n                  </div>\n                </div>\n              </CardHeader>\n              <CardContent>\n                <div className=\"space-y-4\">\n                  {[\n                    { step: 1, title: \"Configurar API de Kraken\", desc: \"Ve a Integraciones y aÃ±ade tu API Key y Secret de Kraken. AsegÃºrate de que la API tenga permisos de trading.\", icon: Key },\n                    { step: 2, title: \"Configurar Telegram (opcional)\", desc: \"AÃ±ade el token de tu bot de Telegram y tu Chat ID para recibir notificaciones de operaciones.\", icon: Plug },\n                    { step: 3, title: \"Elegir estrategia\", desc: \"En la pÃ¡gina Estrategias, selecciona el algoritmo que mejor se adapte a tu estilo (momentum, scalping, etc.).\", icon: Activity },\n                    { step: 4, title: \"Ajustar parÃ¡metros de riesgo\", desc: \"Configura el nivel de riesgo, Stop Loss y Take Profit segÃºn tu tolerancia.\", icon: Shield },\n                    { step: 5, title: \"Activar el bot\", desc: \"Activa el switch 'Bot Activo' y el bot comenzarÃ¡ a analizar el mercado y operar automÃ¡ticamente.\", icon: Zap },\n                  ].map((item) => (\n                    <div key={item.step} className=\"flex gap-4 p-4 border border-border rounded-lg bg-card/30\">\n                      <div className=\"flex-shrink-0 h-10 w-10 rounded-full bg-primary/20 flex items-center justify-center font-bold text-primary\">\n                        {item.step}\n                      </div>\n                      <div className=\"flex-1\">\n                        <h4 className=\"font-semibold flex items-center gap-2\">\n                          <item.icon className=\"h-4 w-4 text-primary\" />\n                          {item.title}\n                        </h4>\n                        <p className=\"text-sm text-muted-foreground mt-1\">{item.desc}</p>\n                      </div>\n                    </div>\n                  ))}\n                </div>\n              </CardContent>\n            </Card>\n\n            {/* SecciÃ³n 3: ParÃ¡metros y definiciones */}\n            <Card className=\"glass-panel border-border/50\">\n              <CardHeader>\n                <div className=\"flex items-center gap-3\">\n                  <div className=\"p-2 bg-purple-500/20 rounded-lg\">\n                    <Settings className=\"h-6 w-6 text-purple-400\" />\n                  </div>\n                  <div>\n                    <CardTitle className=\"text-lg md:text-xl\">3. ParÃ¡metros y definiciones</CardTitle>\n                    <CardDescription>ExplicaciÃ³n detallada de cada configuraciÃ³n</CardDescription>\n                  </div>\n                </div>\n              </CardHeader>\n              <CardContent>\n                <Accordion type=\"single\" collapsible className=\"w-full\">\n                  \n                  <AccordionItem value=\"strategy\">\n                    <AccordionTrigger className=\"text-left\">\n                      <div className=\"flex items-center gap-2\">\n                        <Activity className=\"h-4 w-4 text-primary\" />\n                        Estrategia de Trading\n                      </div>\n                    </AccordionTrigger>\n                    <AccordionContent className=\"space-y-3 text-sm\">\n                      <p><strong>Â¿QuÃ© es?</strong> El algoritmo que el bot usa para decidir cuÃ¡ndo comprar o vender.</p>\n                      <div className=\"space-y-2\">\n                        <div className=\"p-3 bg-card/50 rounded border border-border\">\n                          <p className=\"font-medium text-green-400\">Momentum</p>\n                          <p className=\"text-muted-foreground\">Sigue tendencias fuertes. Compra cuando el precio sube con fuerza, vende cuando baja. Ideal para mercados con tendencia clara.</p>\n                        </div>\n                        <div className=\"p-3 bg-card/50 rounded border border-border\">\n                          <p className=\"font-medium text-blue-400\">ReversiÃ³n a la Media</p>\n                          <p className=\"text-muted-foreground\">Opera cuando el precio se aleja mucho de su promedio. Compra en caÃ­das extremas, vende en subidas extremas.</p>\n                        </div>\n                        <div className=\"p-3 bg-card/50 rounded border border-border\">\n                          <p className=\"font-medium text-yellow-400\">Scalping</p>\n                          <p className=\"text-muted-foreground\">Muchas operaciones pequeÃ±as y rÃ¡pidas. Busca pequeÃ±os beneficios frecuentes. Requiere mÃ¡s comisiones.</p>\n                        </div>\n                        <div className=\"p-3 bg-card/50 rounded border border-border\">\n                          <p className=\"font-medium text-purple-400\">Grid Trading</p>\n                          <p className=\"text-muted-foreground\">Coloca Ã³rdenes de compra y venta en niveles de precio fijos. Funciona bien en mercados laterales.</p>\n                        </div>\n                      </div>\n                    </AccordionContent>\n                  </AccordionItem>\n\n                  <AccordionItem value=\"signalmode\">\n                    <AccordionTrigger className=\"text-left\">\n                      <div className=\"flex items-center gap-2\">\n                        <CandlestickChart className=\"h-4 w-4 text-cyan-500\" />\n                        Modo de SeÃ±al (Solo Momentum)\n                      </div>\n                    </AccordionTrigger>\n                    <AccordionContent className=\"space-y-3 text-sm\">\n                      <p><strong>Â¿QuÃ© es?</strong> Define cuÃ¡ndo y cÃ³mo el bot evalÃºa las seÃ±ales de trading cuando usas la estrategia Momentum.</p>\n                      <div className=\"space-y-2\">\n                        <div className=\"p-3 bg-card/50 rounded border border-border\">\n                          <p className=\"font-medium text-primary\">Ciclos (30 segundos)</p>\n                          <p className=\"text-muted-foreground\">EvalÃºa precios en tiempo real cada ciclo del bot (~30s). Usa indicadores sobre datos de ticks. MÃ¡s reactivo pero puede generar mÃ¡s seÃ±ales falsas. <strong>Ideal para:</strong> Trading activo, mercados muy volÃ¡tiles.</p>\n                        </div>\n                        <div className=\"p-3 bg-cyan-500/10 rounded border border-cyan-500/30\">\n                          <p className=\"font-medium text-cyan-400\">Velas 5 minutos</p>\n                          <p className=\"text-muted-foreground\">Solo evalÃºa al cierre de cada vela de 5 min. Usa anÃ¡lisis OHLC completo: EMA, RSI, MACD, patrones de velas (Engulfing), volumen relativo. <strong>Ideal para:</strong> Balance entre rapidez y confirmaciÃ³n.</p>\n                        </div>\n                        <div className=\"p-3 bg-cyan-500/10 rounded border border-cyan-500/30\">\n                          <p className=\"font-medium text-cyan-400\">Velas 15 minutos</p>\n                          <p className=\"text-muted-foreground\">EvalÃºa cada 15 minutos al cierre de vela. Menos ruido del mercado, seÃ±ales mÃ¡s confirmadas. <strong>Ideal para:</strong> Swing trading, menos operaciones pero mÃ¡s seguras.</p>\n                        </div>\n                        <div className=\"p-3 bg-cyan-500/10 rounded border border-cyan-500/30\">\n                          <p className=\"font-medium text-cyan-400\">Velas 1 hora</p>\n                          <p className=\"text-muted-foreground\">EvaluaciÃ³n cada hora. MÃ­nimas seÃ±ales falsas, solo opera en tendencias claras y confirmadas. <strong>Ideal para:</strong> Posiciones largas, mÃ­nima intervenciÃ³n.</p>\n                        </div>\n                      </div>\n                      <div className=\"p-3 bg-primary/10 rounded border border-primary/30\">\n                        <p className=\"text-xs\"><strong>Nota:</strong> En modo Velas, el bot usa anÃ¡lisis OHLC avanzado incluyendo patrones de velas japonesas (Engulfing alcista/bajista), Bandas de Bollinger, y anÃ¡lisis de volumen relativo que no estÃ¡n disponibles en modo Ciclos.</p>\n                      </div>\n                    </AccordionContent>\n                  </AccordionItem>\n\n                  <AccordionItem value=\"risk\">\n                    <AccordionTrigger className=\"text-left\">\n                      <div className=\"flex items-center gap-2\">\n                        <Shield className=\"h-4 w-4 text-primary\" />\n                        Nivel de Riesgo\n                      </div>\n                    </AccordionTrigger>\n                    <AccordionContent className=\"space-y-3 text-sm\">\n                      <p><strong>Â¿QuÃ© es?</strong> Controla el tamaÃ±o de las posiciones y la agresividad del bot.</p>\n                      <div className=\"grid grid-cols-1 md:grid-cols-3 gap-2\">\n                        <div className=\"p-3 bg-green-500/10 rounded border border-green-500/30\">\n                          <p className=\"font-medium text-green-400\">Bajo</p>\n                          <p className=\"text-muted-foreground text-xs\">Posiciones pequeÃ±as, stops ajustados. Menor ganancia pero menor riesgo.</p>\n                        </div>\n                        <div className=\"p-3 bg-yellow-500/10 rounded border border-yellow-500/30\">\n                          <p className=\"font-medium text-yellow-400\">Medio</p>\n                          <p className=\"text-muted-foreground text-xs\">Balance entre riesgo y rendimiento. Recomendado para la mayorÃ­a.</p>\n                        </div>\n                        <div className=\"p-3 bg-red-500/10 rounded border border-red-500/30\">\n                          <p className=\"font-medium text-red-400\">Alto</p>\n                          <p className=\"text-muted-foreground text-xs\">Posiciones grandes, mÃ¡s volatilidad. Mayor ganancia potencial pero mÃ¡s riesgo.</p>\n                        </div>\n                      </div>\n                    </AccordionContent>\n                  </AccordionItem>\n\n                  <AccordionItem value=\"stoploss\">\n                    <AccordionTrigger className=\"text-left\">\n                      <div className=\"flex items-center gap-2\">\n                        <TrendingDown className=\"h-4 w-4 text-red-500\" />\n                        Stop Loss (%)\n                      </div>\n                    </AccordionTrigger>\n                    <AccordionContent className=\"space-y-3 text-sm\">\n                      <p><strong>Â¿QuÃ© es?</strong> Porcentaje mÃ¡ximo de pÃ©rdida que el bot tolerarÃ¡ antes de cerrar una posiciÃ³n automÃ¡ticamente.</p>\n                      <div className=\"p-3 bg-card/50 rounded border border-border\">\n                        <p><strong>Valores recomendados:</strong> Entre 2% y 5%</p>\n                        <p className=\"text-muted-foreground mt-1\">\n                          <strong>Muy bajo (1%):</strong> Se cerrarÃ¡n posiciones muy rÃ¡pido, posibles pÃ©rdidas por volatilidad normal.<br/>\n                          <strong>Muy alto (10%+):</strong> PÃ©rdidas grandes si el mercado va en contra.\n                        </p>\n                      </div>\n                      <p className=\"text-muted-foreground\">\n                        <strong>Ejemplo:</strong> Si compras BTC a $100,000 con Stop Loss 3%, la posiciÃ³n se cerrarÃ¡ automÃ¡ticamente si BTC baja a $97,000.\n                      </p>\n                    </AccordionContent>\n                  </AccordionItem>\n\n                  <AccordionItem value=\"takeprofit\">\n                    <AccordionTrigger className=\"text-left\">\n                      <div className=\"flex items-center gap-2\">\n                        <TrendingUp className=\"h-4 w-4 text-green-500\" />\n                        Take Profit (%)\n                      </div>\n                    </AccordionTrigger>\n                    <AccordionContent className=\"space-y-3 text-sm\">\n                      <p><strong>Â¿QuÃ© es?</strong> Porcentaje de ganancia objetivo. Cuando se alcanza, el bot cierra la posiciÃ³n asegurando beneficios.</p>\n                      <div className=\"p-3 bg-card/50 rounded border border-border\">\n                        <p><strong>Valores recomendados:</strong> Entre 3% y 10%</p>\n                        <p className=\"text-muted-foreground mt-1\">\n                          <strong>Muy bajo (1%):</strong> Ganancias pequeÃ±as, las comisiones pueden comerlas.<br/>\n                          <strong>Muy alto (20%+):</strong> DifÃ­cil de alcanzar, el precio puede revertir antes.\n                        </p>\n                      </div>\n                      <p className=\"text-muted-foreground\">\n                        <strong>Ejemplo:</strong> Si compras ETH a $3,000 con Take Profit 5%, la posiciÃ³n se cerrarÃ¡ automÃ¡ticamente cuando ETH llegue a $3,150.\n                      </p>\n                    </AccordionContent>\n                  </AccordionItem>\n\n                  <AccordionItem value=\"trailing\">\n                    <AccordionTrigger className=\"text-left\">\n                      <div className=\"flex items-center gap-2\">\n                        <Percent className=\"h-4 w-4 text-primary\" />\n                        Trailing Stop\n                      </div>\n                    </AccordionTrigger>\n                    <AccordionContent className=\"space-y-3 text-sm\">\n                      <p><strong>Â¿QuÃ© es?</strong> Un stop loss dinÃ¡mico que sigue al precio cuando este sube, asegurando ganancias progresivamente.</p>\n                      <div className=\"p-3 bg-card/50 rounded border border-border\">\n                        <p><strong>CÃ³mo funciona:</strong></p>\n                        <p className=\"text-muted-foreground mt-1\">\n                          Si activas Trailing Stop al 2% y el precio sube un 5%, el stop se mueve automÃ¡ticamente para asegurar al menos un 3% de ganancia.\n                        </p>\n                      </div>\n                      <p className=\"text-muted-foreground\">\n                        <strong>RecomendaciÃ³n:</strong> ActÃ­valo si quieres capturar tendencias largas sin preocuparte por el Take Profit fijo.\n                      </p>\n                    </AccordionContent>\n                  </AccordionItem>\n\n                  <AccordionItem value=\"pairs\">\n                    <AccordionTrigger className=\"text-left\">\n                      <div className=\"flex items-center gap-2\">\n                        <DollarSign className=\"h-4 w-4 text-primary\" />\n                        Pares Activos\n                      </div>\n                    </AccordionTrigger>\n                    <AccordionContent className=\"space-y-3 text-sm\">\n                      <p><strong>Â¿QuÃ© es?</strong> Las criptomonedas que el bot analizarÃ¡ y operarÃ¡.</p>\n                      <div className=\"p-3 bg-card/50 rounded border border-border\">\n                        <p className=\"text-muted-foreground\">\n                          <strong>Pocos pares (1-2):</strong> El bot se concentra en esos mercados, operaciones mÃ¡s frecuentes por par.<br/>\n                          <strong>Muchos pares (5+):</strong> MÃ¡s oportunidades pero el capital se divide, operaciones mÃ¡s pequeÃ±as.\n                        </p>\n                      </div>\n                      <p className=\"text-muted-foreground\">\n                        <strong>RecomendaciÃ³n para saldos pequeÃ±os:</strong> Activa solo 1-2 pares con mejor liquidez (BTC/USD, ETH/USD).\n                      </p>\n                    </AccordionContent>\n                  </AccordionItem>\n\n                  <AccordionItem value=\"timeframes\">\n                    <AccordionTrigger className=\"text-left\">\n                      <div className=\"flex items-center gap-2\">\n                        <Clock className=\"h-4 w-4 text-primary\" />\n                        Multi-Timeframe\n                      </div>\n                    </AccordionTrigger>\n                    <AccordionContent className=\"space-y-3 text-sm\">\n                      <p><strong>Â¿QuÃ© es?</strong> El bot analiza mÃºltiples marcos temporales para confirmar seÃ±ales.</p>\n                      <div className=\"p-3 bg-card/50 rounded border border-border\">\n                        <p className=\"text-muted-foreground\">\n                          <strong>5 minutos:</strong> SeÃ±ales de entrada rÃ¡pidas<br/>\n                          <strong>1 hora:</strong> Tendencia a corto plazo<br/>\n                          <strong>4 horas:</strong> Tendencia general del mercado\n                        </p>\n                      </div>\n                      <p className=\"text-muted-foreground\">\n                        El bot no operarÃ¡ contra la tendencia principal. Si los 3 timeframes coinciden en direcciÃ³n, aÃ±ade +15% de confianza a la seÃ±al.\n                      </p>\n                    </AccordionContent>\n                  </AccordionItem>\n\n                  <AccordionItem value=\"indicators\">\n                    <AccordionTrigger className=\"text-left\">\n                      <div className=\"flex items-center gap-2\">\n                        <BarChart3 className=\"h-4 w-4 text-primary\" />\n                        Indicadores TÃ©cnicos por Estrategia\n                      </div>\n                    </AccordionTrigger>\n                    <AccordionContent className=\"space-y-3 text-sm\">\n                      <p><strong>Â¿QuÃ© son?</strong> FÃ³rmulas matemÃ¡ticas que analizan el precio y volumen para predecir movimientos.</p>\n                      <div className=\"space-y-2\">\n                        <div className=\"p-3 bg-green-500/10 rounded border border-green-500/30\">\n                          <p className=\"font-medium text-green-400\">Momentum usa:</p>\n                          <ul className=\"text-muted-foreground text-xs mt-1 space-y-1\">\n                            <li>â€¢ <strong>EMAs (9, 21, 50):</strong> Medias mÃ³viles exponenciales para detectar tendencia</li>\n                            <li>â€¢ <strong>MACD:</strong> SeÃ±al=12, LÃ­nea=26, Histograma para momentum</li>\n                            <li>â€¢ <strong>RSI (14):</strong> Fuerza relativa, seÃ±ales cuando &gt;70 o &lt;30</li>\n                          </ul>\n                        </div>\n                        <div className=\"p-3 bg-blue-500/10 rounded border border-blue-500/30\">\n                          <p className=\"font-medium text-blue-400\">ReversiÃ³n a la Media usa:</p>\n                          <ul className=\"text-muted-foreground text-xs mt-1 space-y-1\">\n                            <li>â€¢ <strong>Bollinger Bands (20, 2):</strong> Detecta extremos de precio</li>\n                            <li>â€¢ <strong>RSI (14):</strong> Sobreventa &lt;30 = compra, sobrecompra &gt;70 = venta</li>\n                            <li>â€¢ <strong>EMA 50:</strong> Referencia de precio promedio</li>\n                          </ul>\n                        </div>\n                        <div className=\"p-3 bg-yellow-500/10 rounded border border-yellow-500/30\">\n                          <p className=\"font-medium text-yellow-400\">Scalping usa:</p>\n                          <ul className=\"text-muted-foreground text-xs mt-1 space-y-1\">\n                            <li>â€¢ <strong>EMAs rÃ¡pidas (9, 21):</strong> Cruces para entradas rÃ¡pidas</li>\n                            <li>â€¢ <strong>Volumen:</strong> Confirma fuerza del movimiento</li>\n                            <li>â€¢ <strong>ATR:</strong> Volatilidad para ajustar stops dinÃ¡micos</li>\n                          </ul>\n                        </div>\n                        <div className=\"p-3 bg-purple-500/10 rounded border border-purple-500/30\">\n                          <p className=\"font-medium text-purple-400\">Grid Trading usa:</p>\n                          <ul className=\"text-muted-foreground text-xs mt-1 space-y-1\">\n                            <li>â€¢ <strong>ATR:</strong> Calcula separaciÃ³n entre niveles del grid</li>\n                            <li>â€¢ <strong>Soporte/Resistencia:</strong> Define lÃ­mites del grid</li>\n                            <li>â€¢ <strong>Volumen:</strong> Valida zonas de acumulaciÃ³n</li>\n                          </ul>\n                        </div>\n                      </div>\n                    </AccordionContent>\n                  </AccordionItem>\n\n                  <AccordionItem value=\"position-size\">\n                    <AccordionTrigger className=\"text-left\">\n                      <div className=\"flex items-center gap-2\">\n                        <Target className=\"h-4 w-4 text-primary\" />\n                        TamaÃ±o de PosiciÃ³n y Riesgo Diario\n                      </div>\n                    </AccordionTrigger>\n                    <AccordionContent className=\"space-y-3 text-sm\">\n                      <p><strong>Â¿QuÃ© es?</strong> La cantidad de capital que el bot arriesga en cada operaciÃ³n y el lÃ­mite diario.</p>\n                      <div className=\"p-3 bg-card/50 rounded border border-border\">\n                        <p><strong>CÃ¡lculo automÃ¡tico por operaciÃ³n:</strong></p>\n                        <p className=\"text-muted-foreground mt-1\">\n                          El bot calcula el tamaÃ±o basÃ¡ndose en:<br/>\n                          â€¢ Tu saldo disponible<br/>\n                          â€¢ El nivel de riesgo seleccionado (bajo/medio/alto)<br/>\n                          â€¢ El Stop Loss configurado<br/>\n                          â€¢ Los mÃ­nimos de orden de Kraken\n                        </p>\n                      </div>\n                      <div className=\"grid grid-cols-1 md:grid-cols-3 gap-2\">\n                        <div className=\"p-2 bg-green-500/10 rounded text-xs\">\n                          <p className=\"font-medium text-green-400\">Riesgo Bajo</p>\n                          <p className=\"text-muted-foreground\">~1-2% por operaciÃ³n</p>\n                          <p className=\"text-muted-foreground\">~5% mÃ¡x. diario</p>\n                        </div>\n                        <div className=\"p-2 bg-yellow-500/10 rounded text-xs\">\n                          <p className=\"font-medium text-yellow-400\">Riesgo Medio</p>\n                          <p className=\"text-muted-foreground\">~3-5% por operaciÃ³n</p>\n                          <p className=\"text-muted-foreground\">~10% mÃ¡x. diario</p>\n                        </div>\n                        <div className=\"p-2 bg-red-500/10 rounded text-xs\">\n                          <p className=\"font-medium text-red-400\">Riesgo Alto</p>\n                          <p className=\"text-muted-foreground\">~5-10% por operaciÃ³n</p>\n                          <p className=\"text-muted-foreground\">~20% mÃ¡x. diario</p>\n                        </div>\n                      </div>\n                      <div className=\"p-3 bg-yellow-500/10 rounded border border-yellow-500/30\">\n                        <p className=\"font-medium text-yellow-400\">LÃ­mite de pÃ©rdida diaria</p>\n                        <p className=\"text-muted-foreground text-xs mt-1\">\n                          El bot controla las pÃ©rdidas acumuladas del dÃ­a. Si alcanzas el lÃ­mite diario, \n                          el bot pausa las operaciones hasta el dÃ­a siguiente para proteger tu capital.\n                          Monitorea tu historial de operaciones para verificar el rendimiento diario.\n                        </p>\n                      </div>\n                      <p className=\"text-muted-foreground\">\n                        <strong>Ejemplo:</strong> Con $100 de saldo y riesgo medio, cada operaciÃ³n usarÃ¡ ~$3-5 y el bot pararÃ¡ si pierdes mÃ¡s de $10 en un dÃ­a.\n                      </p>\n                    </AccordionContent>\n                  </AccordionItem>\n\n                  <AccordionItem value=\"position-tracking\">\n                    <AccordionTrigger className=\"text-left\">\n                      <div className=\"flex items-center gap-2\">\n                        <Database className=\"h-4 w-4 text-primary\" />\n                        Seguimiento de Posiciones\n                      </div>\n                    </AccordionTrigger>\n                    <AccordionContent className=\"space-y-3 text-sm\">\n                      <p><strong>Â¿QuÃ© es?</strong> Cada posiciÃ³n abierta guarda informaciÃ³n sobre cÃ³mo fue creada.</p>\n                      <div className=\"p-3 bg-card/50 rounded border border-border\">\n                        <p className=\"font-medium mb-2\">Estrategia \"Grandfather\"</p>\n                        <p className=\"text-muted-foreground\">\n                          Cuando el bot abre una posiciÃ³n, guarda:<br/>\n                          â€¢ <strong>Estrategia usada:</strong> Momentum, Scalping, etc.<br/>\n                          â€¢ <strong>Timeframe de seÃ±al:</strong> Ciclos, 5m, 15m, 1h<br/>\n                          â€¢ <strong>Confianza de la seÃ±al:</strong> Porcentaje de certeza<br/>\n                          â€¢ <strong>RazÃ³n:</strong> Indicadores que activaron la compra\n                        </p>\n                      </div>\n                      <div className=\"p-3 bg-cyan-500/10 rounded border border-cyan-500/30\">\n                        <p className=\"font-medium text-cyan-400 mb-1\">Â¿Por quÃ© es Ãºtil?</p>\n                        <p className=\"text-muted-foreground text-xs\">\n                          â€¢ Puedes ver en la tabla de posiciones quÃ© estrategia abriÃ³ cada trade<br/>\n                          â€¢ Al ampliar una posiciÃ³n existente, se mantiene la estrategia original<br/>\n                          â€¢ Ayuda a analizar quÃ© configuraciÃ³n funciona mejor para ti\n                        </p>\n                      </div>\n                    </AccordionContent>\n                  </AccordionItem>\n\n                  <AccordionItem value=\"telegram\">\n                    <AccordionTrigger className=\"text-left\">\n                      <div className=\"flex items-center gap-2\">\n                        <Bell className=\"h-4 w-4 text-primary\" />\n                        Notificaciones Telegram\n                      </div>\n                    </AccordionTrigger>\n                    <AccordionContent className=\"space-y-3 text-sm\">\n                      <p><strong>Â¿QuÃ© es?</strong> El bot envÃ­a alertas a Telegram cuando ocurren eventos importantes.</p>\n                      <div className=\"p-3 bg-card/50 rounded border border-border\">\n                        <p className=\"font-medium mb-2\">InformaciÃ³n en cada notificaciÃ³n</p>\n                        <p className=\"text-muted-foreground\">\n                          â€¢ <strong>Tipo:</strong> COMPRA o VENTA<br/>\n                          â€¢ <strong>Par y cantidad:</strong> QuÃ© crypto y cuÃ¡nto<br/>\n                          â€¢ <strong>Precio:</strong> A quÃ© precio se ejecutÃ³<br/>\n                          â€¢ <strong>Estrategia:</strong> Momentum (Velas 5m), etc.<br/>\n                          â€¢ <strong>Confianza:</strong> Porcentaje de certeza de la seÃ±al<br/>\n                          â€¢ <strong>RazÃ³n:</strong> Indicadores que activaron la operaciÃ³n\n                        </p>\n                      </div>\n                      <div className=\"p-3 bg-green-500/10 rounded border border-green-500/30\">\n                        <p className=\"font-medium text-green-400 mb-1\">Tipos de alertas</p>\n                        <p className=\"text-muted-foreground text-xs\">\n                          â€¢ ğŸŸ¢ Compra ejecutada<br/>\n                          â€¢ ğŸ”´ Venta ejecutada<br/>\n                          â€¢ ğŸ›‘ Stop-Loss activado<br/>\n                          â€¢ ğŸ¯ Take-Profit alcanzado<br/>\n                          â€¢ ğŸ“‰ Trailing Stop activado<br/>\n                          â€¢ âš ï¸ Errores o lÃ­mites alcanzados\n                        </p>\n                      </div>\n                    </AccordionContent>\n                  </AccordionItem>\n\n                  <AccordionItem value=\"filters\">\n                    <AccordionTrigger className=\"text-left\">\n                      <div className=\"flex items-center gap-2\">\n                        <Activity className=\"h-4 w-4 text-primary\" />\n                        Filtros de Volatilidad y Volumen\n                      </div>\n                    </AccordionTrigger>\n                    <AccordionContent className=\"space-y-3 text-sm\">\n                      <p><strong>Â¿QuÃ© son?</strong> Condiciones adicionales que deben cumplirse antes de abrir una operaciÃ³n.</p>\n                      <div className=\"p-3 bg-card/50 rounded border border-border\">\n                        <p className=\"font-medium mb-2\">Filtro de Volatilidad (ATR)</p>\n                        <p className=\"text-muted-foreground\">\n                          El bot mide la volatilidad usando ATR (Average True Range). Si la volatilidad es muy baja, \n                          no opera porque los movimientos no cubrirÃ­an las comisiones. Si es muy alta, reduce el tamaÃ±o de posiciÃ³n.\n                        </p>\n                      </div>\n                      <div className=\"p-3 bg-card/50 rounded border border-border\">\n                        <p className=\"font-medium mb-2\">Filtro de Volumen</p>\n                        <p className=\"text-muted-foreground\">\n                          Compara el volumen actual con el promedio de las Ãºltimas 20 velas. Solo opera cuando el volumen \n                          es al menos 50% del promedio, evitando entrar en mercados \"muertos\" donde el precio puede manipularse fÃ¡cilmente.\n                        </p>\n                      </div>\n                      <p className=\"text-muted-foreground\">\n                        <strong>Beneficio:</strong> Estos filtros reducen operaciones en condiciones desfavorables, mejorando la tasa de acierto.\n                      </p>\n                    </AccordionContent>\n                  </AccordionItem>\n\n                  <AccordionItem value=\"mode\">\n                    <AccordionTrigger className=\"text-left\">\n                      <div className=\"flex items-center gap-2\">\n                        <Zap className=\"h-4 w-4 text-primary\" />\n                        Modo de OperaciÃ³n\n                      </div>\n                    </AccordionTrigger>\n                    <AccordionContent className=\"space-y-3 text-sm\">\n                      <p><strong>Â¿QuÃ© es?</strong> El bot estÃ¡ configurado para operar exclusivamente en modo REAL.</p>\n                      <div className=\"p-3 bg-yellow-500/10 rounded border border-yellow-500/30\">\n                        <p className=\"font-medium text-yellow-400\">âš ï¸ Importante</p>\n                        <p className=\"text-muted-foreground mt-1\">\n                          Este bot ejecuta operaciones reales con dinero real en Kraken. No incluye modo paper/demo.\n                          Cada operaciÃ³n afectarÃ¡ tu saldo real.\n                        </p>\n                      </div>\n                      <div className=\"p-3 bg-card/50 rounded border border-border\">\n                        <p className=\"font-medium mb-2\">Recomendaciones para empezar:</p>\n                        <ul className=\"text-muted-foreground space-y-1\">\n                          <li>â€¢ Empieza con el mÃ­nimo capital posible ($10-50)</li>\n                          <li>â€¢ Usa nivel de riesgo BAJO al principio</li>\n                          <li>â€¢ Activa solo 1-2 pares para observar</li>\n                          <li>â€¢ Revisa el historial de operaciones diariamente</li>\n                          <li>â€¢ Aumenta capital solo cuando entiendas el comportamiento</li>\n                        </ul>\n                      </div>\n                    </AccordionContent>\n                  </AccordionItem>\n\n                </Accordion>\n              </CardContent>\n            </Card>\n\n            {/* SecciÃ³n 4: Estados del bot y errores */}\n            <Card className=\"glass-panel border-border/50\">\n              <CardHeader>\n                <div className=\"flex items-center gap-3\">\n                  <div className=\"p-2 bg-orange-500/20 rounded-lg\">\n                    <AlertTriangle className=\"h-6 w-6 text-orange-400\" />\n                  </div>\n                  <div>\n                    <CardTitle className=\"text-lg md:text-xl\">4. Estados del bot y errores tÃ­picos</CardTitle>\n                    <CardDescription>Significado de cada estado y cÃ³mo solucionar problemas</CardDescription>\n                  </div>\n                </div>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                \n                <h4 className=\"font-semibold flex items-center gap-2\">\n                  <CheckCircle2 className=\"h-4 w-4 text-green-500\" />\n                  Estados normales\n                </h4>\n                <div className=\"grid grid-cols-1 md:grid-cols-2 gap-3\">\n                  <div className=\"p-3 border border-green-500/30 rounded-lg bg-green-500/5\">\n                    <div className=\"flex items-center gap-2 mb-1\">\n                      <span className=\"h-2 w-2 rounded-full bg-green-500\"></span>\n                      <span className=\"font-medium\">Bot Activo</span>\n                    </div>\n                    <p className=\"text-xs text-muted-foreground\">El bot estÃ¡ analizando el mercado y puede ejecutar operaciones.</p>\n                  </div>\n                  <div className=\"p-3 border border-yellow-500/30 rounded-lg bg-yellow-500/5\">\n                    <div className=\"flex items-center gap-2 mb-1\">\n                      <span className=\"h-2 w-2 rounded-full bg-yellow-500\"></span>\n                      <span className=\"font-medium\">Bot Pausado</span>\n                    </div>\n                    <p className=\"text-xs text-muted-foreground\">El bot no estÃ¡ operando. ActÃ­valo manualmente para que empiece.</p>\n                  </div>\n                  <div className=\"p-3 border border-green-500/30 rounded-lg bg-green-500/5\">\n                    <div className=\"flex items-center gap-2 mb-1\">\n                      <span className=\"h-2 w-2 rounded-full bg-green-500\"></span>\n                      <span className=\"font-medium\">Kraken Conectado</span>\n                    </div>\n                    <p className=\"text-xs text-muted-foreground\">La API de Kraken estÃ¡ configurada correctamente y funcionando.</p>\n                  </div>\n                  <div className=\"p-3 border border-green-500/30 rounded-lg bg-green-500/5\">\n                    <div className=\"flex items-center gap-2 mb-1\">\n                      <span className=\"h-2 w-2 rounded-full bg-green-500\"></span>\n                      <span className=\"font-medium\">Telegram Conectado</span>\n                    </div>\n                    <p className=\"text-xs text-muted-foreground\">Las notificaciones de Telegram estÃ¡n activas.</p>\n                  </div>\n                </div>\n\n                <h4 className=\"font-semibold flex items-center gap-2 mt-6\">\n                  <XCircle className=\"h-4 w-4 text-red-500\" />\n                  Errores comunes y soluciones\n                </h4>\n                <div className=\"space-y-3\">\n                  <div className=\"p-4 border border-red-500/30 rounded-lg bg-red-500/5\">\n                    <div className=\"flex items-center gap-2 mb-2\">\n                      <AlertTriangle className=\"h-4 w-4 text-red-500\" />\n                      <span className=\"font-medium\">Error de Nonce (Invalid nonce)</span>\n                    </div>\n                    <p className=\"text-sm text-muted-foreground mb-2\">\n                      Kraken rechaza la peticiÃ³n porque el identificador Ãºnico de la llamada es invÃ¡lido.\n                    </p>\n                    <div className=\"text-xs p-2 bg-card/50 rounded\">\n                      <strong>Causas posibles:</strong><br/>\n                      â€¢ Hay otra instancia del bot usando la misma API Key<br/>\n                      â€¢ Reinicio muy rÃ¡pido del bot<br/>\n                      <strong>SoluciÃ³n:</strong> Verifica que no tengas el bot corriendo en dos sitios (Replit + NAS). El bot reintenta automÃ¡ticamente 3 veces.\n                    </div>\n                  </div>\n                  \n                  <div className=\"p-4 border border-red-500/30 rounded-lg bg-red-500/5\">\n                    <div className=\"flex items-center gap-2 mb-2\">\n                      <WifiOff className=\"h-4 w-4 text-red-500\" />\n                      <span className=\"font-medium\">Kraken Desconectado</span>\n                    </div>\n                    <p className=\"text-sm text-muted-foreground mb-2\">\n                      El bot no puede comunicarse con Kraken.\n                    </p>\n                    <div className=\"text-xs p-2 bg-card/50 rounded\">\n                      <strong>Causas posibles:</strong><br/>\n                      â€¢ API Key o Secret incorrectos<br/>\n                      â€¢ La API no tiene permisos de trading<br/>\n                      â€¢ Kraken estÃ¡ en mantenimiento<br/>\n                      <strong>SoluciÃ³n:</strong> Ve a Integraciones y verifica tus credenciales. Regenera la API Key si es necesario.\n                    </div>\n                  </div>\n\n                  <div className=\"p-4 border border-yellow-500/30 rounded-lg bg-yellow-500/5\">\n                    <div className=\"flex items-center gap-2 mb-2\">\n                      <DollarSign className=\"h-4 w-4 text-yellow-500\" />\n                      <span className=\"font-medium\">Saldo insuficiente (Insufficient funds)</span>\n                    </div>\n                    <p className=\"text-sm text-muted-foreground mb-2\">\n                      No hay suficiente saldo para ejecutar la operaciÃ³n.\n                    </p>\n                    <div className=\"text-xs p-2 bg-card/50 rounded\">\n                      <strong>Causas posibles:</strong><br/>\n                      â€¢ El saldo disponible es menor que el mÃ­nimo de orden de Kraken<br/>\n                      â€¢ El saldo estÃ¡ bloqueado en Ã³rdenes abiertas<br/>\n                      â€¢ Se alcanzÃ³ el lÃ­mite de pÃ©rdida diaria<br/>\n                      <strong>SoluciÃ³n:</strong> Deposita mÃ¡s fondos en Kraken, cancela Ã³rdenes pendientes, o espera al dÃ­a siguiente si alcanzaste el lÃ­mite diario.\n                    </div>\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n\n            {/* SecciÃ³n 5: Buenas prÃ¡cticas */}\n            <Card className=\"glass-panel border-border/50\">\n              <CardHeader>\n                <div className=\"flex items-center gap-3\">\n                  <div className=\"p-2 bg-primary/20 rounded-lg\">\n                    <Lightbulb className=\"h-6 w-6 text-primary\" />\n                  </div>\n                  <div>\n                    <CardTitle className=\"text-lg md:text-xl\">5. Buenas prÃ¡cticas y consejos</CardTitle>\n                    <CardDescription>Recomendaciones para operar de forma segura</CardDescription>\n                  </div>\n                </div>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                \n                <div className=\"p-4 border border-primary/30 rounded-lg bg-primary/5\">\n                  <h4 className=\"font-semibold mb-3 flex items-center gap-2\">\n                    <CheckCircle2 className=\"h-4 w-4 text-primary\" />\n                    Checklist antes de activar el bot\n                  </h4>\n                  <div className=\"grid grid-cols-1 md:grid-cols-2 gap-2 text-sm\">\n                    <label className=\"flex items-center gap-2 text-muted-foreground\">\n                      <input type=\"checkbox\" className=\"rounded\" disabled /> API de Kraken configurada y verificada\n                    </label>\n                    <label className=\"flex items-center gap-2 text-muted-foreground\">\n                      <input type=\"checkbox\" className=\"rounded\" disabled /> Telegram configurado (opcional)\n                    </label>\n                    <label className=\"flex items-center gap-2 text-muted-foreground\">\n                      <input type=\"checkbox\" className=\"rounded\" disabled /> Saldo suficiente en la cuenta\n                    </label>\n                    <label className=\"flex items-center gap-2 text-muted-foreground\">\n                      <input type=\"checkbox\" className=\"rounded\" disabled /> Estrategia y pares seleccionados\n                    </label>\n                    <label className=\"flex items-center gap-2 text-muted-foreground\">\n                      <input type=\"checkbox\" className=\"rounded\" disabled /> Stop Loss y Take Profit configurados\n                    </label>\n                    <label className=\"flex items-center gap-2 text-muted-foreground\">\n                      <input type=\"checkbox\" className=\"rounded\" disabled /> Nivel de riesgo adecuado a tu capital\n                    </label>\n                  </div>\n                </div>\n\n                <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n                  <div className=\"p-4 border border-green-500/30 rounded-lg bg-green-500/5\">\n                    <h4 className=\"font-semibold mb-2 text-green-400\">âœ… Hacer</h4>\n                    <ul className=\"text-sm text-muted-foreground space-y-1\">\n                      <li>â€¢ Empezar con posiciones pequeÃ±as</li>\n                      <li>â€¢ Revisar el dashboard y balance diariamente</li>\n                      <li>â€¢ Configurar alertas de Telegram</li>\n                      <li>â€¢ Usar Stop Loss siempre</li>\n                      <li>â€¢ Monitorear pÃ©rdidas/ganancias diarias en Historial</li>\n                      <li>â€¢ Verificar saldo antes de activar el bot</li>\n                    </ul>\n                  </div>\n                  <div className=\"p-4 border border-red-500/30 rounded-lg bg-red-500/5\">\n                    <h4 className=\"font-semibold mb-2 text-red-400\">âŒ Evitar</h4>\n                    <ul className=\"text-sm text-muted-foreground space-y-1\">\n                      <li>â€¢ Invertir todo tu capital</li>\n                      <li>â€¢ Desactivar el Stop Loss</li>\n                      <li>â€¢ Usar riesgo alto sin experiencia</li>\n                      <li>â€¢ Ignorar las alertas del bot</li>\n                      <li>â€¢ Ejecutar mÃºltiples instancias</li>\n                      <li>â€¢ Operar sin revisar el rendimiento semanal</li>\n                    </ul>\n                  </div>\n                </div>\n\n                <div className=\"p-4 border border-yellow-500/30 rounded-lg bg-yellow-500/5\">\n                  <h4 className=\"font-semibold mb-2 flex items-center gap-2\">\n                    <AlertTriangle className=\"h-4 w-4 text-yellow-500\" />\n                    Advertencia importante\n                  </h4>\n                  <p className=\"text-sm text-muted-foreground\">\n                    El trading de criptomonedas conlleva riesgos significativos. Nunca inviertas dinero que no puedas permitirte perder. \n                    Este bot es una herramienta automatizada, pero no garantiza beneficios. Supervisa regularmente su funcionamiento \n                    y ajusta la configuraciÃ³n segÃºn las condiciones del mercado.\n                  </p>\n                </div>\n\n                <div className=\"p-4 border border-border rounded-lg bg-card/30\">\n                  <h4 className=\"font-semibold mb-2 flex items-center gap-2\">\n                    <HelpCircle className=\"h-4 w-4 text-primary\" />\n                    Â¿QuÃ© revisar en el Dashboard?\n                  </h4>\n                  <ul className=\"text-sm text-muted-foreground space-y-1\">\n                    <li>â€¢ <strong>Balances:</strong> Verifica que tu saldo es correcto</li>\n                    <li>â€¢ <strong>Estado del bot:</strong> Confirma que estÃ¡ activo y conectado</li>\n                    <li>â€¢ <strong>Ãšltimas operaciones:</strong> Revisa que las operaciones se ejecutan correctamente</li>\n                    <li>â€¢ <strong>Precios:</strong> Comprueba que los precios se actualizan en tiempo real</li>\n                  </ul>\n                </div>\n\n              </CardContent>\n            </Card>\n\n          </div>\n        </main>\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":50842,"size_tokens":null},"server/services/botLogger.ts":{"content":"import { db } from \"../db\";\nimport { botEvents } from \"@shared/schema\";\nimport type { BotEvent, InsertBotEvent } from \"@shared/schema\";\nimport { desc } from \"drizzle-orm\";\nimport { eventsWs } from \"./eventsWebSocket\";\nimport { environment } from \"./environment\";\n\nexport type LogLevel = \"INFO\" | \"WARN\" | \"ERROR\";\n\nexport type EventType = \n  | \"TRADE_EXECUTED\"\n  | \"TRADE_BLOCKED\"\n  | \"TRADE_FAILED\"\n  | \"TRADE_ADJUSTED\"\n  | \"TRADE_REJECTED_LOW_PROFIT\"\n  | \"TRADE_SKIPPED\"\n  | \"PAIR_COOLDOWN\"\n  | \"DAILY_LIMIT_HIT\"\n  | \"DAILY_LIMIT_RESET\"\n  | \"BOT_STARTED\"\n  | \"BOT_STOPPED\"\n  | \"BOT_PAUSED\"\n  | \"BOT_RESUMED\"\n  | \"ENGINE_TICK\"\n  | \"MARKET_SCAN_SUMMARY\"\n  | \"KRAKEN_ERROR\"\n  | \"KRAKEN_CONNECTED\"\n  | \"TELEGRAM_ERROR\"\n  | \"TELEGRAM_CONNECTED\"\n  | \"SIGNAL_GENERATED\"\n  | \"POSITION_OPENED\"\n  | \"POSITION_CLOSED\"\n  | \"STOP_LOSS_HIT\"\n  | \"TAKE_PROFIT_HIT\"\n  | \"TRAILING_STOP_HIT\"\n  | \"ORPHAN_POSITION_CLEANED\"\n  | \"NONCE_ERROR\"\n  | \"BALANCE_CHECK\"\n  | \"SYSTEM_ERROR\"\n  // SMART_GUARD events\n  | \"SG_EMERGENCY_STOPLOSS\"\n  | \"SG_TP_FIXED\"\n  | \"SG_BREAKEVEN_ACTIVATED\"\n  | \"SG_TRAILING_ACTIVATED\"\n  | \"SG_TRAILING_STOP_UPDATED\"\n  | \"SG_STOP_HIT\"\n  | \"SG_SCALE_OUT\"\n  | \"SG_SCALE_OUT_EXECUTED\"\n  | \"SG_BREAK_EVEN_ACTIVATED\"\n  // Config events\n  | \"CONFIG_OVERRIDE_UPDATED\"\n  // DRY_RUN mode\n  | \"DRY_RUN_TRADE\"\n  // TEST endpoint events\n  | \"TEST_TRADE_SIMULATED\"\n  | \"TEST_POSITION_CREATED\"\n  // Manual close events\n  | \"MANUAL_CLOSE_INITIATED\"\n  | \"MANUAL_CLOSE_SUCCESS\"\n  | \"MANUAL_CLOSE_FAILED\"\n  | \"MANUAL_CLOSE_EXCEPTION\"\n  | \"MANUAL_CLOSE_DUST\"\n  | \"ORPHAN_POSITION_DELETED\";\n\ninterface LogMeta {\n  [key: string]: any;\n}\n\ninterface MemoryEvent {\n  timestamp: string;\n  level: LogLevel;\n  type: EventType;\n  message: string;\n  meta?: LogMeta;\n  env: string;\n  instanceId: string;\n}\n\nconst MAX_MEMORY_EVENTS = 100;\n\nclass BotLogger {\n  private memoryEvents: MemoryEvent[] = [];\n  private persistToDb: boolean = true;\n\n  private formatConsoleLog(level: LogLevel, type: EventType, message: string): string {\n    const timestamp = new Date().toISOString();\n    const levelColor = level === \"ERROR\" ? \"\\x1b[31m\" : level === \"WARN\" ? \"\\x1b[33m\" : \"\\x1b[36m\";\n    const reset = \"\\x1b[0m\";\n    return `${levelColor}[${timestamp}] [${level}] [${type}]${reset} ${message}`;\n  }\n\n  private async log(level: LogLevel, type: EventType, message: string, meta?: LogMeta): Promise<void> {\n    const timestamp = new Date().toISOString();\n    const env = environment.envTag;\n    const instanceId = environment.instanceId;\n    \n    console.log(this.formatConsoleLog(level, type, message));\n    if (meta) {\n      console.log(\"  Meta:\", JSON.stringify(meta, null, 2));\n    }\n\n    const enrichedMeta = { ...meta, env, instanceId };\n    const event: MemoryEvent = { timestamp, level, type, message, meta: enrichedMeta, env, instanceId };\n    this.memoryEvents.unshift(event);\n    if (this.memoryEvents.length > MAX_MEMORY_EVENTS) {\n      this.memoryEvents.pop();\n    }\n\n    let insertedId: number | undefined;\n    if (this.persistToDb) {\n      try {\n        const result = await db.insert(botEvents).values({\n          level,\n          type,\n          message,\n          meta: enrichedMeta ? JSON.stringify(enrichedMeta) : null,\n        }).returning({ id: botEvents.id });\n        insertedId = result[0]?.id;\n      } catch (error) {\n        console.error(\"[BotLogger] Error persisting event to DB:\", error);\n      }\n    }\n\n    try {\n      eventsWs.broadcast({\n        id: insertedId,\n        timestamp,\n        level,\n        type,\n        message,\n        meta: enrichedMeta,\n        env,\n        instanceId,\n      });\n    } catch (error) {\n      // Silently fail if WS not initialized yet\n    }\n  }\n\n  async info(type: EventType, message: string, meta?: LogMeta): Promise<void> {\n    await this.log(\"INFO\", type, message, meta);\n  }\n\n  async warn(type: EventType, message: string, meta?: LogMeta): Promise<void> {\n    await this.log(\"WARN\", type, message, meta);\n  }\n\n  async error(type: EventType, message: string, meta?: LogMeta): Promise<void> {\n    await this.log(\"ERROR\", type, message, meta);\n  }\n\n  getMemoryEvents(limit: number = 50): MemoryEvent[] {\n    return this.memoryEvents.slice(0, limit);\n  }\n\n  async getDbEvents(limit: number = 50): Promise<BotEvent[]> {\n    try {\n      return await db.select()\n        .from(botEvents)\n        .orderBy(desc(botEvents.timestamp))\n        .limit(limit);\n    } catch (error) {\n      console.error(\"[BotLogger] Error fetching events from DB:\", error);\n      return [];\n    }\n  }\n\n  setPersistToDb(persist: boolean): void {\n    this.persistToDb = persist;\n  }\n}\n\nexport const botLogger = new BotLogger();\n","path":null,"size_bytes":4630,"size_tokens":null},"client/src/components/dashboard/EventsPanel.tsx":{"content":"import { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Button } from \"@/components/ui/button\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport { \n  AlertTriangle, \n  XCircle, \n  Info,\n  Wifi,\n  WifiOff,\n  RefreshCw,\n  Trash2\n} from \"lucide-react\";\nimport { useEventsFeed } from \"@/context/EventsWebSocketContext\";\nimport { BotEvent } from \"@/hooks/useEventsWebSocket\";\nimport { cn } from \"@/lib/utils\";\n\nexport function EventsPanel() {\n  const { events: allEvents, status, clearEvents, connect, isConnected } = useEventsFeed();\n  const events = allEvents.slice(0, 50);\n\n  const getLevelIcon = (level: string) => {\n    switch (level) {\n      case \"ERROR\":\n        return <XCircle className=\"h-4 w-4 text-red-500\" />;\n      case \"WARN\":\n        return <AlertTriangle className=\"h-4 w-4 text-yellow-500\" />;\n      default:\n        return <Info className=\"h-4 w-4 text-cyan-500\" />;\n    }\n  };\n\n  const getLevelBadge = (level: string) => {\n    switch (level) {\n      case \"ERROR\":\n        return <Badge variant=\"destructive\" className=\"text-xs\">ERROR</Badge>;\n      case \"WARN\":\n        return <Badge className=\"bg-yellow-500/20 text-yellow-400 border-yellow-500/30 text-xs\">WARN</Badge>;\n      default:\n        return <Badge className=\"bg-cyan-500/20 text-cyan-400 border-cyan-500/30 text-xs\">INFO</Badge>;\n    }\n  };\n\n  const getTypeBadge = (type: string) => {\n    const typeColors: Record<string, string> = {\n      TRADE_EXECUTED: \"bg-green-500/20 text-green-400 border-green-500/30\",\n      TRADE_BLOCKED: \"bg-orange-500/20 text-orange-400 border-orange-500/30\",\n      TRADE_FAILED: \"bg-red-500/20 text-red-400 border-red-500/30\",\n      TRADE_SKIPPED: \"bg-gray-500/20 text-gray-400 border-gray-500/30\",\n      DAILY_LIMIT_HIT: \"bg-red-500/20 text-red-400 border-red-500/30\",\n      BOT_STARTED: \"bg-green-500/20 text-green-400 border-green-500/30\",\n      BOT_STOPPED: \"bg-gray-500/20 text-gray-400 border-gray-500/30\",\n      KRAKEN_ERROR: \"bg-red-500/20 text-red-400 border-red-500/30\",\n      SIGNAL_GENERATED: \"bg-blue-500/20 text-blue-400 border-blue-500/30\",\n      STOP_LOSS_HIT: \"bg-red-500/20 text-red-400 border-red-500/30\",\n      TAKE_PROFIT_HIT: \"bg-green-500/20 text-green-400 border-green-500/30\",\n      ENGINE_TICK: \"bg-purple-500/20 text-purple-400 border-purple-500/30\",\n      MARKET_SCAN_SUMMARY: \"bg-indigo-500/20 text-indigo-400 border-indigo-500/30\",\n    };\n    \n    const colorClass = typeColors[type] || \"bg-primary/20 text-primary border-primary/30\";\n    return <Badge className={`${colorClass} text-xs`}>{type.replace(/_/g, \" \")}</Badge>;\n  };\n\n  const formatTime = (timestamp: string) => {\n    const date = new Date(timestamp);\n    return date.toLocaleTimeString(\"es-ES\", { \n      hour: \"2-digit\", \n      minute: \"2-digit\",\n      second: \"2-digit\"\n    });\n  };\n\n  const formatDate = (timestamp: string) => {\n    const date = new Date(timestamp);\n    return date.toLocaleDateString(\"es-ES\", { \n      day: \"2-digit\",\n      month: \"2-digit\"\n    });\n  };\n\n  return (\n    <Card className=\"h-full\" data-testid=\"events-panel\">\n      <CardHeader className=\"pb-3\">\n        <div className=\"flex items-center justify-between\">\n          <CardTitle className=\"text-lg flex items-center gap-2\">\n            Eventos del Bot\n            <Badge \n              variant=\"outline\" \n              className={cn(\n                \"gap-1 text-xs\",\n                isConnected ? \"border-green-500 text-green-400\" : \n                status === \"reconnecting\" ? \"border-yellow-500 text-yellow-400\" :\n                \"border-red-500 text-red-400\"\n              )}\n              data-testid=\"events-ws-status\"\n            >\n              {isConnected ? <Wifi className=\"h-3 w-3\" /> : \n               status === \"reconnecting\" ? <RefreshCw className=\"h-3 w-3 animate-spin\" /> :\n               <WifiOff className=\"h-3 w-3\" />}\n              {isConnected ? \"Live\" : status === \"reconnecting\" ? \"...\" : \"Off\"}\n            </Badge>\n          </CardTitle>\n          <div className=\"flex items-center gap-1\">\n            <Button\n              variant=\"ghost\"\n              size=\"icon\"\n              className=\"h-7 w-7\"\n              onClick={clearEvents}\n              title=\"Limpiar eventos\"\n              data-testid=\"button-clear-events\"\n            >\n              <Trash2 className=\"h-4 w-4\" />\n            </Button>\n            {!isConnected && (\n              <Button\n                variant=\"ghost\"\n                size=\"icon\"\n                className=\"h-7 w-7\"\n                onClick={connect}\n                title=\"Reconectar\"\n                data-testid=\"button-reconnect-events\"\n              >\n                <RefreshCw className=\"h-4 w-4\" />\n              </Button>\n            )}\n          </div>\n        </div>\n      </CardHeader>\n      <CardContent className=\"pt-0\">\n        <ScrollArea className=\"h-[300px]\">\n          <div className=\"space-y-2\">\n            {events.length === 0 ? (\n              <div className=\"text-center text-muted-foreground py-8 text-sm\">\n                {isConnected ? \"Esperando eventos...\" : \"Conectando...\"}\n              </div>\n            ) : (\n              events.slice(0, 20).map((event, idx) => (\n                <div\n                  key={event.id || `${event.timestamp}-${idx}`}\n                  className=\"flex items-start gap-2 p-2 rounded-lg bg-muted/30 hover:bg-muted/50 transition-colors\"\n                  data-testid={`event-item-${event.id || idx}`}\n                >\n                  {getLevelIcon(event.level)}\n                  <div className=\"flex-1 min-w-0\">\n                    <div className=\"flex items-center gap-2 flex-wrap\">\n                      {getTypeBadge(event.type)}\n                      {event.meta?.pair && (\n                        <Badge variant=\"outline\" className=\"text-xs\">\n                          {event.meta.pair}\n                        </Badge>\n                      )}\n                      <span className=\"text-xs text-muted-foreground ml-auto whitespace-nowrap\">\n                        {formatDate(event.timestamp)} {formatTime(event.timestamp)}\n                      </span>\n                    </div>\n                    <p className=\"text-sm text-foreground/80 mt-1 line-clamp-2\">\n                      {event.message}\n                    </p>\n                  </div>\n                </div>\n              ))\n            )}\n          </div>\n        </ScrollArea>\n      </CardContent>\n    </Card>\n  );\n}\n","path":null,"size_bytes":6495,"size_tokens":null},"server/services/mlTrainer.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nAI Filter Model Trainer for KrakenBot\nUses RandomForest with walk-forward validation\n\"\"\"\n\nimport sys\nimport json\nimport os\nimport pickle\n\nMODEL_DIR = \"/tmp/models\"\nMODEL_PATH = f\"{MODEL_DIR}/ai_filter.joblib\"\nSTATUS_PATH = f\"{MODEL_DIR}/ai_status.json\"\n\ndef ensure_model_dir():\n    if not os.path.exists(MODEL_DIR):\n        os.makedirs(MODEL_DIR, exist_ok=True)\n\ndef extract_features_from_sample(sample):\n    \"\"\"Extract feature vector from a sample's featuresJson\"\"\"\n    features = sample.get(\"featuresJson\", {})\n    if isinstance(features, str):\n        features = json.loads(features)\n    \n    return [\n        float(features.get(\"rsi14\", 50)),\n        float(features.get(\"macdLine\", 0)),\n        float(features.get(\"macdSignal\", 0)),\n        float(features.get(\"macdHist\", 0)),\n        float(features.get(\"bbUpper\", 0)),\n        float(features.get(\"bbMiddle\", 0)),\n        float(features.get(\"bbLower\", 0)),\n        float(features.get(\"atr14\", 0)),\n        float(features.get(\"ema12\", 0)),\n        float(features.get(\"ema26\", 0)),\n        float(features.get(\"volume24hChange\", 0)),\n        float(features.get(\"priceChange1h\", 0)),\n        float(features.get(\"priceChange4h\", 0)),\n        float(features.get(\"priceChange24h\", 0)),\n        float(features.get(\"spreadPct\", 0)),\n        float(features.get(\"confidence\", 50)),\n    ]\n\ndef train(samples_path):\n    \"\"\"Train RandomForest model on samples\"\"\"\n    try:\n        from sklearn.ensemble import RandomForestClassifier\n        from sklearn.model_selection import TimeSeriesSplit\n        from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score\n        import numpy as np\n    except ImportError:\n        print(json.dumps({\"success\": False, \"error\": \"sklearn not installed\"}))\n        sys.exit(1)\n    \n    ensure_model_dir()\n    \n    with open(samples_path, 'r') as f:\n        samples = json.load(f)\n    \n    complete_samples = [s for s in samples if s.get(\"isComplete\") and s.get(\"labelWin\") is not None]\n    \n    if len(complete_samples) < 50:\n        print(json.dumps({\"success\": False, \"error\": f\"Not enough samples: {len(complete_samples)}\"}))\n        sys.exit(1)\n    \n    X = []\n    y = []\n    \n    for sample in complete_samples:\n        try:\n            features = extract_features_from_sample(sample)\n            label = int(sample[\"labelWin\"])\n            X.append(features)\n            y.append(label)\n        except Exception as e:\n            continue\n    \n    X = np.array(X)\n    y = np.array(y)\n    \n    tscv = TimeSeriesSplit(n_splits=min(5, len(X) // 20))\n    \n    accuracies = []\n    precisions = []\n    recalls = []\n    f1s = []\n    \n    for train_idx, test_idx in tscv.split(X):\n        X_train, X_test = X[train_idx], X[test_idx]\n        y_train, y_test = y[train_idx], y[test_idx]\n        \n        model = RandomForestClassifier(\n            n_estimators=100,\n            max_depth=10,\n            min_samples_split=5,\n            min_samples_leaf=2,\n            random_state=42,\n            class_weight='balanced'\n        )\n        \n        model.fit(X_train, y_train)\n        y_pred = model.predict(X_test)\n        \n        accuracies.append(accuracy_score(y_test, y_pred))\n        precisions.append(precision_score(y_test, y_pred, zero_division=0))\n        recalls.append(recall_score(y_test, y_pred, zero_division=0))\n        f1s.append(f1_score(y_test, y_pred, zero_division=0))\n    \n    final_model = RandomForestClassifier(\n        n_estimators=100,\n        max_depth=10,\n        min_samples_split=5,\n        min_samples_leaf=2,\n        random_state=42,\n        class_weight='balanced'\n    )\n    final_model.fit(X, y)\n    \n    with open(MODEL_PATH, 'wb') as f:\n        pickle.dump(final_model, f)\n    \n    metrics = {\n        \"accuracy\": float(np.mean(accuracies)),\n        \"precision\": float(np.mean(precisions)),\n        \"recall\": float(np.mean(recalls)),\n        \"f1\": float(np.mean(f1s)),\n        \"nSamples\": len(complete_samples),\n        \"trainedAt\": str(os.popen('date -u +\"%Y-%m-%dT%H:%M:%SZ\"').read().strip())\n    }\n    \n    with open(STATUS_PATH, 'w') as f:\n        json.dump(metrics, f, indent=2)\n    \n    print(json.dumps({\"success\": True, \"metrics\": metrics}))\n\ndef predict(features_json):\n    \"\"\"Predict approval probability for given features\"\"\"\n    ensure_model_dir()\n    \n    if not os.path.exists(MODEL_PATH):\n        print(json.dumps({\"score\": 0.5, \"error\": \"Model not found\"}))\n        return\n    \n    try:\n        with open(MODEL_PATH, 'rb') as f:\n            model = pickle.load(f)\n        \n        features = json.loads(features_json)\n        \n        X = [[\n            float(features.get(\"rsi14\", 50)),\n            float(features.get(\"macdLine\", 0)),\n            float(features.get(\"macdSignal\", 0)),\n            float(features.get(\"macdHist\", 0)),\n            float(features.get(\"bbUpper\", 0)),\n            float(features.get(\"bbMiddle\", 0)),\n            float(features.get(\"bbLower\", 0)),\n            float(features.get(\"atr14\", 0)),\n            float(features.get(\"ema12\", 0)),\n            float(features.get(\"ema26\", 0)),\n            float(features.get(\"volume24hChange\", 0)),\n            float(features.get(\"priceChange1h\", 0)),\n            float(features.get(\"priceChange4h\", 0)),\n            float(features.get(\"priceChange24h\", 0)),\n            float(features.get(\"spreadPct\", 0)),\n            float(features.get(\"confidence\", 50)),\n        ]]\n        \n        proba = model.predict_proba(X)[0]\n        score = float(proba[1]) if len(proba) > 1 else 0.5\n        \n        print(json.dumps({\"score\": score}))\n        \n    except Exception as e:\n        print(json.dumps({\"score\": 0.5, \"error\": str(e)}))\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        print(json.dumps({\"error\": \"Usage: mlTrainer.py <train|predict> <arg>\"}))\n        sys.exit(1)\n    \n    command = sys.argv[1]\n    \n    if command == \"train\" and len(sys.argv) >= 3:\n        train(sys.argv[2])\n    elif command == \"predict\" and len(sys.argv) >= 3:\n        predict(sys.argv[2])\n    else:\n        print(json.dumps({\"error\": f\"Unknown command: {command}\"}))\n        sys.exit(1)\n","path":null,"size_bytes":6120,"size_tokens":null},"server/services/aiService.ts":{"content":"import { storage } from \"../storage\";\nimport { spawn } from \"child_process\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\n\nexport interface AiFeatures {\n  rsi14: number;\n  macdLine: number;\n  macdSignal: number;\n  macdHist: number;\n  bbUpper: number;\n  bbMiddle: number;\n  bbLower: number;\n  atr14: number;\n  ema12: number;\n  ema26: number;\n  volume24hChange: number;\n  priceChange1h: number;\n  priceChange4h: number;\n  priceChange24h: number;\n  spreadPct: number;\n  confidence: number;\n}\n\nexport interface AiPrediction {\n  approve: boolean;\n  score: number;\n  threshold: number;\n}\n\nexport interface AiStatus {\n  phase: \"red\" | \"yellow\" | \"green\";\n  phaseLabel: string;\n  completeSamples: number;\n  minSamplesForTrain: number;\n  minSamplesForActivate: number;\n  canTrain: boolean;\n  canActivate: boolean;\n  filterEnabled: boolean;\n  shadowEnabled: boolean;\n  modelLoaded: boolean;\n  lastTrainTs: Date | null;\n  threshold: number;\n  metrics: {\n    accuracy?: number;\n    precision?: number;\n    recall?: number;\n    f1?: number;\n    tradesBlocked?: number;\n    lossesAvoided?: number;\n  } | null;\n}\n\nexport interface AiDiagnostic {\n  operationsCount: number;\n  trainingTradesTotal: number;\n  closedTradesCount: number;\n  labeledTradesCount: number;\n  openTradesCount: number;\n  openLotsCount: number;\n  openTradesDescription: string;\n  openLotsDescription: string;\n  lastBackfillRun: Date | null;\n  lastBackfillError: string | null;\n  lastTrainRun: Date | null;\n  lastTrainError: string | null;\n  modelVersion: string | null;\n  discardReasonsDataset: Record<string, number>;\n  lastBackfillDiscardReasons: Record<string, number>;\n  winRate: number | null;\n  avgPnlNet: number | null;\n  avgHoldTimeMinutes: number | null;\n}\n\nconst MODEL_DIR = \"/tmp/models\";\nconst MODEL_PATH = `${MODEL_DIR}/ai_filter.joblib`;\nconst STATUS_PATH = `${MODEL_DIR}/ai_status.json`;\n\nconst MIN_SAMPLES_TRAIN = 300;\nconst MIN_SAMPLES_ACTIVATE = 300;\n\nconst LEGACY_KEY_MAP: Record<string, string> = {\n  'no_matching_sell': 'venta_sin_compra_previa',\n  'invalid_data': 'datos_invalidos',\n  'outlier_pnl': 'pnl_atipico',\n  'excessive_hold': 'hold_excesivo',\n  'abnormal_fees': 'comisiones_anormales',\n  'invalid_timestamps': 'timestamps_invalidos',\n  'sell_exceeds_lots': 'venta_excede_lotes',\n  'no_execution_date': 'sin_fecha_ejecucion',\n};\n\nfunction translateDiscardReasons(reasons: Record<string, number>): Record<string, number> {\n  const translated: Record<string, number> = {};\n  for (const [key, count] of Object.entries(reasons)) {\n    const translatedKey = LEGACY_KEY_MAP[key] || key;\n    translated[translatedKey] = (translated[translatedKey] || 0) + count;\n  }\n  return translated;\n}\n\nclass AiService {\n  private modelLoaded: boolean = false;\n  private cachedMetrics: any = null;\n\n  extractFeatures(indicators: {\n    rsi?: number;\n    macd?: { line: number; signal: number; histogram: number };\n    bollinger?: { upper: number; middle: number; lower: number };\n    atr?: number;\n    ema12?: number;\n    ema26?: number;\n    volume24hChange?: number;\n    priceChange1h?: number;\n    priceChange4h?: number;\n    priceChange24h?: number;\n    spreadPct?: number;\n    confidence?: number;\n  }): AiFeatures {\n    return {\n      rsi14: indicators.rsi ?? 50,\n      macdLine: indicators.macd?.line ?? 0,\n      macdSignal: indicators.macd?.signal ?? 0,\n      macdHist: indicators.macd?.histogram ?? 0,\n      bbUpper: indicators.bollinger?.upper ?? 0,\n      bbMiddle: indicators.bollinger?.middle ?? 0,\n      bbLower: indicators.bollinger?.lower ?? 0,\n      atr14: indicators.atr ?? 0,\n      ema12: indicators.ema12 ?? 0,\n      ema26: indicators.ema26 ?? 0,\n      volume24hChange: indicators.volume24hChange ?? 0,\n      priceChange1h: indicators.priceChange1h ?? 0,\n      priceChange4h: indicators.priceChange4h ?? 0,\n      priceChange24h: indicators.priceChange24h ?? 0,\n      spreadPct: indicators.spreadPct ?? 0,\n      confidence: indicators.confidence ?? 50,\n    };\n  }\n\n  async getStatus(): Promise<AiStatus> {\n    const aiConfig = await storage.getAiConfig();\n    const labeledCount = await storage.getTrainingTradesCount({ labeled: true });\n    \n    let phase: \"red\" | \"yellow\" | \"green\" = \"red\";\n    let phaseLabel = \"Recolectando datos\";\n    \n    if (labeledCount >= MIN_SAMPLES_ACTIVATE && aiConfig?.filterEnabled) {\n      phase = \"green\";\n      phaseLabel = \"Filtro activo\";\n    } else if (labeledCount >= MIN_SAMPLES_TRAIN) {\n      phase = \"yellow\";\n      phaseLabel = \"Listo para entrenar\";\n    }\n\n    const modelExists = fs.existsSync(MODEL_PATH);\n    \n    let metrics = null;\n    if (fs.existsSync(STATUS_PATH)) {\n      try {\n        const statusData = fs.readFileSync(STATUS_PATH, \"utf-8\");\n        metrics = JSON.parse(statusData);\n        this.cachedMetrics = metrics;\n      } catch (e) {\n        metrics = this.cachedMetrics;\n      }\n    }\n\n    return {\n      phase,\n      phaseLabel,\n      completeSamples: labeledCount,\n      minSamplesForTrain: MIN_SAMPLES_TRAIN,\n      minSamplesForActivate: MIN_SAMPLES_ACTIVATE,\n      canTrain: labeledCount >= MIN_SAMPLES_TRAIN,\n      canActivate: labeledCount >= MIN_SAMPLES_ACTIVATE && modelExists,\n      filterEnabled: aiConfig?.filterEnabled ?? false,\n      shadowEnabled: aiConfig?.shadowEnabled ?? false,\n      modelLoaded: modelExists && this.modelLoaded,\n      lastTrainTs: aiConfig?.lastTrainTs ?? null,\n      threshold: parseFloat(aiConfig?.threshold ?? \"0.60\"),\n      metrics,\n    };\n  }\n\n  async getDiagnostic(): Promise<AiDiagnostic> {\n    const aiConfig = await storage.getAiConfig();\n    const allTrades = await storage.getAllTradesForBackfill();\n    const trainingTradesTotal = await storage.getTrainingTradesCount();\n    const closedCount = await storage.getTrainingTradesCount({ closed: true });\n    const labeledCount = await storage.getTrainingTradesCount({ labeled: true });\n    const openCount = await storage.getTrainingTradesCount({ closed: false });\n    const openLotsCount = await storage.getTrainingTradesCount({ hasOpenLots: true });\n    \n    const labeledTrades = await storage.getTrainingTrades({ labeled: true });\n    \n    const rawDiscardReasonsDataset = await storage.getDiscardReasonsDataset();\n    const discardReasonsDataset = translateDiscardReasons(rawDiscardReasonsDataset);\n    \n    const rawLastBackfillDiscardReasons: Record<string, number> = \n      (aiConfig?.lastBackfillDiscardReasonsJson as Record<string, number>) || {};\n    const lastBackfillDiscardReasons = translateDiscardReasons(rawLastBackfillDiscardReasons);\n    \n    let winRate: number | null = null;\n    let avgPnlNet: number | null = null;\n    let avgHoldTimeMinutes: number | null = null;\n    \n    if (labeledTrades.length > 0) {\n      const wins = labeledTrades.filter(t => t.labelWin === 1).length;\n      winRate = (wins / labeledTrades.length) * 100;\n      \n      const pnlSum = labeledTrades.reduce((sum, t) => sum + parseFloat(t.pnlNet || '0'), 0);\n      avgPnlNet = pnlSum / labeledTrades.length;\n      \n      const holdSum = labeledTrades.reduce((sum, t) => sum + (t.holdTimeMinutes || 0), 0);\n      avgHoldTimeMinutes = holdSum / labeledTrades.length;\n    }\n    \n    return {\n      operationsCount: allTrades.length,\n      trainingTradesTotal,\n      closedTradesCount: closedCount,\n      labeledTradesCount: labeledCount,\n      openTradesCount: openCount,\n      openLotsCount,\n      openTradesDescription: \"training_trades con isClosed=false\",\n      openLotsDescription: \"training_trades con qtyRemaining > 0\",\n      lastBackfillRun: aiConfig?.lastBackfillTs ?? null,\n      lastBackfillError: aiConfig?.lastBackfillError ?? null,\n      lastTrainRun: aiConfig?.lastTrainTs ?? null,\n      lastTrainError: aiConfig?.lastTrainError ?? null,\n      modelVersion: aiConfig?.modelVersion ?? null,\n      discardReasonsDataset,\n      lastBackfillDiscardReasons,\n      winRate,\n      avgPnlNet,\n      avgHoldTimeMinutes,\n    };\n  }\n\n  async predict(features: AiFeatures): Promise<AiPrediction> {\n    const aiConfig = await storage.getAiConfig();\n    const threshold = parseFloat(aiConfig?.threshold ?? \"0.60\");\n    \n    if (!fs.existsSync(MODEL_PATH)) {\n      return { approve: true, score: 0.5, threshold };\n    }\n\n    try {\n      const featuresJson = JSON.stringify(features);\n      const result = await this.runPythonPredict(featuresJson);\n      const score = parseFloat(result.score);\n      \n      return {\n        approve: score >= threshold,\n        score,\n        threshold,\n      };\n    } catch (error) {\n      console.error(\"[AI] Prediction error:\", error);\n      return { approve: true, score: 0.5, threshold };\n    }\n  }\n\n  private runPythonPredict(featuresJson: string): Promise<{ score: string }> {\n    return new Promise((resolve, reject) => {\n      const pythonScript = path.join(process.cwd(), \"server/services/mlTrainer.py\");\n      \n      if (!fs.existsSync(pythonScript)) {\n        resolve({ score: \"0.5\" });\n        return;\n      }\n\n      const proc = spawn(\"python3\", [pythonScript, \"predict\", featuresJson], {\n        cwd: process.cwd(),\n      });\n\n      let stdout = \"\";\n      let stderr = \"\";\n\n      proc.stdout.on(\"data\", (data) => (stdout += data.toString()));\n      proc.stderr.on(\"data\", (data) => (stderr += data.toString()));\n\n      proc.on(\"close\", (code) => {\n        if (code !== 0) {\n          console.error(\"[AI] Python predict error:\", stderr);\n          resolve({ score: \"0.5\" });\n          return;\n        }\n        try {\n          const result = JSON.parse(stdout.trim());\n          resolve({ score: result.score?.toString() ?? \"0.5\" });\n        } catch (e) {\n          resolve({ score: \"0.5\" });\n        }\n      });\n\n      proc.on(\"error\", (err) => {\n        console.error(\"[AI] Python spawn error:\", err);\n        resolve({ score: \"0.5\" });\n      });\n    });\n  }\n\n  async runTraining(): Promise<{ \n    success: boolean; \n    message: string; \n    errorCode?: string;\n    required?: number;\n    current?: number;\n    metrics?: { accuracy: number; precision: number; recall: number; f1: number; trainSize: number; valSize: number } \n  }> {\n    const labeledTrades = await storage.getTrainingTrades({ labeled: true });\n    \n    if (labeledTrades.length < MIN_SAMPLES_TRAIN) {\n      return { \n        success: false, \n        errorCode: \"INSUFFICIENT_DATA\",\n        message: `Datos insuficientes para entrenar el modelo. Necesitas ${MIN_SAMPLES_TRAIN} trades cerrados etiquetados. Actualmente hay ${labeledTrades.length}.`,\n        required: MIN_SAMPLES_TRAIN,\n        current: labeledTrades.length\n      };\n    }\n\n    if (!fs.existsSync(MODEL_DIR)) {\n      fs.mkdirSync(MODEL_DIR, { recursive: true });\n    }\n\n    const sortedTrades = [...labeledTrades].sort((a, b) => {\n      const timeA = a.entryTs ? new Date(a.entryTs).getTime() : 0;\n      const timeB = b.entryTs ? new Date(b.entryTs).getTime() : 0;\n      return timeA - timeB;\n    });\n\n    const validTrades = sortedTrades.filter(trade => {\n      const entryTime = trade.entryTs ? new Date(trade.entryTs).getTime() : 0;\n      const exitTime = trade.exitTs ? new Date(trade.exitTs).getTime() : 0;\n      const entryPrice = parseFloat(trade.entryPrice || '0');\n      const exitPrice = parseFloat(trade.exitPrice || '0');\n      const amount = parseFloat(trade.entryAmount || '0');\n      \n      if (exitTime <= entryTime) return false;\n      if (entryPrice <= 0 || exitPrice <= 0) return false;\n      if (amount <= 0) return false;\n      if (trade.holdTimeMinutes !== null && trade.holdTimeMinutes < 0) return false;\n      \n      return true;\n    });\n\n    if (validTrades.length < MIN_SAMPLES_TRAIN) {\n      return { \n        success: false, \n        errorCode: \"INSUFFICIENT_DATA\",\n        message: `Datos insuficientes para entrenar el modelo. Solo hay ${validTrades.length} trades vÃ¡lidos despuÃ©s de validaciÃ³n. Necesitas ${MIN_SAMPLES_TRAIN}.`,\n        required: MIN_SAMPLES_TRAIN,\n        current: validTrades.length\n      };\n    }\n\n    const splitIdx = Math.floor(validTrades.length * 0.8);\n    const trainTrades = validTrades.slice(0, splitIdx);\n    const valTrades = validTrades.slice(splitIdx);\n\n    const trainingData = {\n      train: trainTrades.map(trade => ({\n        tradeId: trade.buyTxid,\n        pair: trade.pair,\n        entryPrice: trade.entryPrice,\n        exitPrice: trade.exitPrice,\n        pnlNet: trade.pnlNet,\n        pnlPct: trade.pnlPct,\n        holdTimeMinutes: trade.holdTimeMinutes,\n        labelWin: trade.labelWin,\n        featuresJson: trade.featuresJson || {},\n        entryTs: trade.entryTs,\n      })),\n      val: valTrades.map(trade => ({\n        tradeId: trade.buyTxid,\n        pair: trade.pair,\n        entryPrice: trade.entryPrice,\n        exitPrice: trade.exitPrice,\n        pnlNet: trade.pnlNet,\n        pnlPct: trade.pnlPct,\n        holdTimeMinutes: trade.holdTimeMinutes,\n        labelWin: trade.labelWin,\n        featuresJson: trade.featuresJson || {},\n        entryTs: trade.entryTs,\n      })),\n    };\n\n    const samplesPath = `${MODEL_DIR}/training_samples.json`;\n    fs.writeFileSync(samplesPath, JSON.stringify(trainingData, null, 2));\n\n    const modelVersion = `v${Date.now()}`;\n\n    return new Promise((resolve) => {\n      const pythonScript = path.join(process.cwd(), \"server/services/mlTrainer.py\");\n      \n      if (!fs.existsSync(pythonScript)) {\n        storage.updateAiConfig({ lastTrainError: \"Script de entrenamiento no encontrado\" });\n        resolve({ success: false, message: \"Script de entrenamiento no encontrado\" });\n        return;\n      }\n\n      const proc = spawn(\"python3\", [pythonScript, \"train\", samplesPath], {\n        cwd: process.cwd(),\n      });\n\n      let stdout = \"\";\n      let stderr = \"\";\n\n      proc.stdout.on(\"data\", (data) => (stdout += data.toString()));\n      proc.stderr.on(\"data\", (data) => (stderr += data.toString()));\n\n      proc.on(\"close\", async (code) => {\n        if (code !== 0) {\n          console.error(\"[AI] Training failed:\", stderr);\n          const errorMsg = stderr.slice(0, 500) || 'Unknown training error';\n          await storage.updateAiConfig({ lastTrainError: errorMsg });\n          resolve({ success: false, message: `Error en entrenamiento: ${errorMsg.slice(0, 200)}` });\n          return;\n        }\n\n        try {\n          const result = JSON.parse(stdout.trim());\n          const metrics = {\n            accuracy: result.metrics?.accuracy ?? 0,\n            precision: result.metrics?.precision ?? 0,\n            recall: result.metrics?.recall ?? 0,\n            f1: result.metrics?.f1 ?? 0,\n            trainSize: trainTrades.length,\n            valSize: valTrades.length,\n          };\n          \n          await storage.updateAiConfig({\n            lastTrainTs: new Date(),\n            lastTrainError: null,\n            nSamples: validTrades.length,\n            modelPath: MODEL_PATH,\n            modelVersion,\n            metricsJson: metrics,\n          });\n\n          this.modelLoaded = true;\n          \n          resolve({\n            success: true,\n            message: `Modelo ${modelVersion} entrenado: ${trainTrades.length} train / ${valTrades.length} val. Accuracy: ${(metrics.accuracy * 100).toFixed(1)}%`,\n            metrics,\n          });\n        } catch (e: any) {\n          await storage.updateAiConfig({\n            lastTrainTs: new Date(),\n            lastTrainError: null,\n            modelVersion,\n          });\n          resolve({ success: true, message: `Modelo ${modelVersion} entrenado (sin mÃ©tricas parseables)` });\n        }\n      });\n\n      proc.on(\"error\", async (err) => {\n        console.error(\"[AI] Training spawn error:\", err);\n        await storage.updateAiConfig({ lastTrainError: err.message });\n        resolve({ success: false, message: `Error: ${err.message}` });\n      });\n    });\n  }\n\n  async runBackfill(): Promise<{ success: boolean; message: string; stats: { created: number; closed: number; labeled: number; discardReasons: Record<string, number> } }> {\n    try {\n      const stats = await storage.runTrainingTradesBackfill();\n      \n      await storage.updateAiConfig({\n        lastBackfillTs: new Date(),\n        lastBackfillError: null,\n        lastBackfillDiscardReasonsJson: stats.discardReasons,\n      });\n      \n      return {\n        success: true,\n        message: `Backfill completado: ${stats.created} trades creados, ${stats.closed} cerrados, ${stats.labeled} etiquetados`,\n        stats,\n      };\n    } catch (error: any) {\n      const errorMsg = error.message || 'Unknown error';\n      await storage.updateAiConfig({\n        lastBackfillTs: new Date(),\n        lastBackfillError: errorMsg,\n      });\n      \n      return {\n        success: false,\n        message: `Error en backfill: ${errorMsg}`,\n        stats: { created: 0, closed: 0, labeled: 0, discardReasons: {} },\n      };\n    }\n  }\n\n  async toggleFilter(enabled: boolean): Promise<void> {\n    await storage.updateAiConfig({ filterEnabled: enabled });\n  }\n\n  async toggleShadow(enabled: boolean): Promise<void> {\n    await storage.updateAiConfig({ shadowEnabled: enabled });\n  }\n\n  async setThreshold(threshold: number): Promise<void> {\n    await storage.updateAiConfig({ threshold: threshold.toFixed(4) });\n  }\n}\n\nexport const aiService = new AiService();\n","path":null,"size_bytes":17120,"size_tokens":null},"client/src/pages/Terminal.tsx":{"content":"import { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { useState, useMemo } from \"react\";\nimport { Nav } from \"@/components/dashboard/Nav\";\nimport generatedImage from '@assets/generated_images/dark_digital_hex_grid_background.png';\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Button } from \"@/components/ui/button\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\nimport { \n  ArrowUpRight, \n  ArrowDownRight, \n  Clock, \n  DollarSign, \n  TrendingUp, \n  TrendingDown, \n  RefreshCw, \n  ChevronLeft, \n  ChevronRight, \n  Download, \n  Activity, \n  CandlestickChart,\n  CircleDot,\n  Zap,\n  Target,\n  BarChart3,\n  Layers,\n  Square,\n  X,\n  Loader2,\n  Trash2,\n  AlertTriangle\n} from \"lucide-react\";\nimport {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n} from \"@/components/ui/alert-dialog\";\nimport { useToast } from \"@/hooks/use-toast\";\n\ninterface OpenPosition {\n  id: number;\n  pair: string;\n  entryPrice: string;\n  amount: string;\n  highestPrice: string;\n  openedAt: string;\n  currentPrice: string;\n  unrealizedPnlUsd: string;\n  unrealizedPnlPct: string;\n  entryValueUsd: string;\n  currentValueUsd: string;\n  entryStrategyId: string;\n  entrySignalTf: string;\n  signalConfidence: string | null;\n  lotId?: string | null;\n  entryMode?: string | null;\n}\n\ninterface ClosedTrade {\n  id: number;\n  tradeId: string;\n  pair: string;\n  type: string;\n  price: string;\n  amount: string;\n  status: string;\n  entryPrice: string | null;\n  totalUsd: string;\n  entryValueUsd: string | null;\n  realizedPnlUsd: string | null;\n  realizedPnlPct: string | null;\n  executedAt: string | null;\n  createdAt: string;\n}\n\ninterface ClosedTradesResponse {\n  trades: ClosedTrade[];\n  total: number;\n  limit: number;\n  offset: number;\n}\n\nexport default function Terminal() {\n  const [limit, setLimit] = useState(10);\n  const [offset, setOffset] = useState(0);\n  const [pairFilter, setPairFilter] = useState<string>(\"all\");\n  const [resultFilter, setResultFilter] = useState<string>(\"all\");\n  const [typeFilter, setTypeFilter] = useState<string>(\"all\");\n  const [syncing, setSyncing] = useState(false);\n  const [activeTab, setActiveTab] = useState(\"positions\");\n  const [closingKey, setClosingKey] = useState<string | null>(null);\n  const [deletingOrphanKey, setDeletingOrphanKey] = useState<string | null>(null);\n  const [orphanDialogOpen, setOrphanDialogOpen] = useState(false);\n  const [orphanToDelete, setOrphanToDelete] = useState<{ lotId: string; pair: string; amount: string } | null>(null);\n  const [dustPositions, setDustPositions] = useState<Set<string>>(new Set());\n  const { toast } = useToast();\n  const queryClient = useQueryClient();\n\n  const getPositionKey = (pair: string, lotId?: string | null) => lotId || pair;\n\n  const { data: botConfig } = useQuery<{ positionMode?: string; sgMaxOpenLotsPerPair?: number }>({\n    queryKey: [\"botConfig\"],\n    queryFn: async () => {\n      const res = await fetch(\"/api/config\");\n      if (!res.ok) throw new Error(\"Failed to fetch config\");\n      return res.json();\n    },\n    refetchInterval: 60000,\n  });\n\n  const { data: openPositions, isLoading: loadingPositions, refetch: refetchPositions, isFetching: fetchingPositions } = useQuery<OpenPosition[]>({\n    queryKey: [\"openPositions\"],\n    queryFn: async () => {\n      const res = await fetch(\"/api/open-positions\");\n      if (!res.ok) throw new Error(\"Failed to fetch open positions\");\n      return res.json();\n    },\n    refetchInterval: 30000,\n  });\n\n  const lotsCountByPair = useMemo(() => {\n    if (!openPositions) return new Map<string, { count: number; max: number }>();\n    const maxLots = botConfig?.sgMaxOpenLotsPerPair || 1;\n    const counts = new Map<string, { count: number; max: number }>();\n    for (const pos of openPositions) {\n      const current = counts.get(pos.pair);\n      counts.set(pos.pair, { count: (current?.count || 0) + 1, max: maxLots });\n    }\n    return counts;\n  }, [openPositions, botConfig?.sgMaxOpenLotsPerPair]);\n\n  const getLotsCountByPair = (pair: string) => {\n    return lotsCountByPair.get(pair) || { count: 0, max: botConfig?.sgMaxOpenLotsPerPair || 1 };\n  };\n\n  const { data: closedData, isLoading: loadingClosed, refetch: refetchClosed, isFetching: fetchingClosed } = useQuery<ClosedTradesResponse>({\n    queryKey: [\"closedTrades\", limit, offset, pairFilter, resultFilter, typeFilter],\n    queryFn: async () => {\n      const params = new URLSearchParams({\n        limit: limit.toString(),\n        offset: offset.toString(),\n        result: resultFilter,\n        type: typeFilter,\n      });\n      if (pairFilter !== \"all\") {\n        params.set(\"pair\", pairFilter);\n      }\n      const res = await fetch(`/api/trades/closed?${params}`);\n      if (!res.ok) throw new Error(\"Failed to fetch closed trades\");\n      return res.json();\n    },\n  });\n\n  const handleSyncFromKraken = async () => {\n    setSyncing(true);\n    try {\n      const res = await fetch(\"/api/trades/sync\", { method: \"POST\" });\n      const data = await res.json();\n      if (res.ok) {\n        toast({\n          title: \"Sincronizado\",\n          description: `Se importaron ${data.synced} operaciones de Kraken (${data.total} en historial)`,\n        });\n        refetchClosed();\n      } else {\n        toast({\n          title: \"Error\",\n          description: data.error || \"No se pudo sincronizar\",\n          variant: \"destructive\",\n        });\n      }\n    } catch (e) {\n      toast({\n        title: \"Error\",\n        description: \"Error de conexiÃ³n\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setSyncing(false);\n    }\n  };\n\n  const closePositionMutation = useMutation({\n    mutationFn: async ({ pair, lotId, amount }: { pair: string; lotId?: string | null; amount?: string }) => {\n      const pairEncoded = pair.replace(\"/\", \"-\");\n      const body: { reason: string; lotId?: string } = { reason: \"Cierre manual desde dashboard\" };\n      if (lotId) body.lotId = lotId;\n      const res = await fetch(`/api/positions/${pairEncoded}/close`, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(body),\n      });\n      const data = await res.json();\n      // Check for DUST response (comes as 200 with isDust flag)\n      if (data.isDust && lotId) {\n        return { ...data, _isDust: true, _lotId: lotId, _pair: pair, _amount: amount };\n      }\n      if (!res.ok) {\n        throw new Error(data.message || \"Error al cerrar posiciÃ³n\");\n      }\n      return data;\n    },\n    onMutate: ({ pair, lotId }) => {\n      setClosingKey(getPositionKey(pair, lotId));\n    },\n    onSuccess: (data) => {\n      // Handle DUST position - show dialog to delete orphan\n      if (data._isDust && data._lotId) {\n        setDustPositions(prev => new Set(prev).add(data._lotId));\n        setOrphanToDelete({ lotId: data._lotId, pair: data._pair, amount: data._amount || \"?\" });\n        setOrphanDialogOpen(true);\n        toast({\n          title: \"PosiciÃ³n DUST\",\n          description: data.message || \"Balance real menor al mÃ­nimo de Kraken\",\n          variant: \"destructive\",\n        });\n        return;\n      }\n      toast({\n        title: data.message?.includes(\"DRY_RUN\") ? \"Cierre Simulado\" : \"PosiciÃ³n Cerrada\",\n        description: `${data.pair}: PnL ${parseFloat(data.realizedPnlUsd) >= 0 ? '+' : ''}$${data.realizedPnlUsd} (${parseFloat(data.realizedPnlPct) >= 0 ? '+' : ''}${data.realizedPnlPct}%)`,\n      });\n      queryClient.invalidateQueries({ queryKey: [\"openPositions\"] });\n      queryClient.invalidateQueries({ queryKey: [\"closedTrades\"] });\n    },\n    onError: (error: Error) => {\n      toast({\n        title: \"Error\",\n        description: error.message,\n        variant: \"destructive\",\n      });\n    },\n    onSettled: () => {\n      setClosingKey(null);\n    },\n  });\n\n  // Mutation for deleting orphan DUST positions\n  const deleteOrphanMutation = useMutation({\n    mutationFn: async ({ lotId }: { lotId: string }) => {\n      const res = await fetch(`/api/positions/${lotId}/orphan`, {\n        method: \"DELETE\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ reason: \"orphan_dust_cleanup\" }),\n      });\n      if (!res.ok) {\n        const data = await res.json();\n        throw new Error(data.message || \"Error al eliminar posiciÃ³n huÃ©rfana\");\n      }\n      return res.json();\n    },\n    onMutate: ({ lotId }) => {\n      setDeletingOrphanKey(lotId);\n    },\n    onSuccess: (data) => {\n      toast({\n        title: \"PosiciÃ³n HuÃ©rfana Eliminada\",\n        description: `${data.pair}: Registro interno eliminado (sin orden a Kraken)`,\n      });\n      setDustPositions(prev => {\n        const next = new Set(prev);\n        next.delete(data.lotId);\n        return next;\n      });\n      queryClient.invalidateQueries({ queryKey: [\"openPositions\"] });\n      queryClient.invalidateQueries({ queryKey: [\"closedTrades\"] });\n      setOrphanDialogOpen(false);\n      setOrphanToDelete(null);\n    },\n    onError: (error: Error) => {\n      toast({\n        title: \"Error\",\n        description: error.message,\n        variant: \"destructive\",\n      });\n    },\n    onSettled: () => {\n      setDeletingOrphanKey(null);\n    },\n  });\n\n  // Mutation for reconciling positions with Kraken\n  const reconcileMutation = useMutation({\n    mutationFn: async ({ autoClean }: { autoClean: boolean }) => {\n      const res = await fetch(\"/api/positions/reconcile\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ autoClean }),\n      });\n      if (!res.ok) {\n        const data = await res.json();\n        throw new Error(data.message || \"Error al reconciliar\");\n      }\n      return res.json();\n    },\n    onSuccess: (data) => {\n      if (data.cleaned > 0) {\n        toast({\n          title: \"ReconciliaciÃ³n Completada\",\n          description: `${data.cleaned} posiciones huÃ©rfanas eliminadas`,\n        });\n        queryClient.invalidateQueries({ queryKey: [\"openPositions\"] });\n      } else if (data.orphans?.length > 0) {\n        toast({\n          title: \"HuÃ©rfanas Detectadas\",\n          description: `${data.orphans.length} posiciones huÃ©rfanas encontradas`,\n          variant: \"destructive\",\n        });\n      } else {\n        toast({\n          title: \"Todo OK\",\n          description: \"No hay posiciones huÃ©rfanas\",\n        });\n      }\n    },\n    onError: (error: Error) => {\n      toast({\n        title: \"Error\",\n        description: error.message,\n        variant: \"destructive\",\n      });\n    },\n  });\n\n  const handleClosePosition = (pair: string, lotId?: string | null, amount?: string) => {\n    const displayId = lotId ? lotId.substring(0, 8) : pair;\n    if (confirm(`Â¿Cerrar ${lotId ? `lote ${displayId}` : `posiciÃ³n`} de ${pair}? Esta acciÃ³n no se puede deshacer.`)) {\n      closePositionMutation.mutate({ pair, lotId, amount });\n    }\n  };\n\n  const handleDeleteOrphan = (lotId: string, pair: string, amount: string) => {\n    setOrphanToDelete({ lotId, pair, amount });\n    setOrphanDialogOpen(true);\n  };\n\n  const confirmDeleteOrphan = () => {\n    if (orphanToDelete) {\n      deleteOrphanMutation.mutate({ lotId: orphanToDelete.lotId });\n    }\n  };\n\n  const handleReconcile = () => {\n    if (confirm(\"Â¿Reconciliar posiciones con Kraken? Esto eliminarÃ¡ automÃ¡ticamente las posiciones huÃ©rfanas (sin balance real).\")) {\n      reconcileMutation.mutate({ autoClean: true });\n    }\n  };\n\n  const formatDate = (dateStr: string | null) => {\n    if (!dateStr) return \"-\";\n    const date = new Date(dateStr);\n    return date.toLocaleDateString(\"es-ES\", {\n      day: \"2-digit\",\n      month: \"2-digit\",\n      year: \"numeric\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n    });\n  };\n\n  const formatPrice = (price: string) => {\n    const num = parseFloat(price);\n    if (num >= 1000) {\n      return num.toLocaleString(\"en-US\", { minimumFractionDigits: 2, maximumFractionDigits: 2 });\n    }\n    return num.toLocaleString(\"en-US\", { minimumFractionDigits: 2, maximumFractionDigits: 6 });\n  };\n\n  const formatStrategyLabel = (strategyId: string, timeframe: string) => {\n    const strategyMap: Record<string, string> = {\n      \"momentum\": \"MOM\",\n      \"momentum_candles_5m\": \"MOM\",\n      \"momentum_candles_15m\": \"MOM\",\n      \"momentum_candles_1h\": \"MOM\",\n      \"mean_reversion\": \"REV\",\n      \"scalping\": \"SCA\",\n      \"grid\": \"GRD\",\n    };\n    const tfMap: Record<string, string> = {\n      \"cycle\": \"CYC\",\n      \"5m\": \"5M\",\n      \"15m\": \"15M\",\n      \"1h\": \"1H\",\n    };\n    const strategyName = strategyMap[strategyId] || strategyId.split('_')[0]?.substring(0, 3).toUpperCase() || \"MOM\";\n    const tfLabel = tfMap[timeframe] || timeframe.toUpperCase();\n    const isCandles = timeframe !== \"cycle\";\n    return { strategyName, tfLabel, isCandles };\n  };\n\n  const totalPages = closedData ? Math.ceil(closedData.total / limit) : 0;\n  const currentPage = Math.floor(offset / limit) + 1;\n\n  const handlePrevPage = () => {\n    if (offset > 0) {\n      setOffset(Math.max(0, offset - limit));\n    }\n  };\n\n  const handleNextPage = () => {\n    if (closedData && offset + limit < closedData.total) {\n      setOffset(offset + limit);\n    }\n  };\n\n  const handleLimitChange = (value: string) => {\n    const newLimit = value === \"all\" ? 1000 : parseInt(value);\n    setLimit(newLimit);\n    setOffset(0);\n  };\n\n  const availablePairs = [\"BTC/USD\", \"ETH/USD\", \"SOL/USD\", \"XRP/USD\", \"TON/USD\"];\n\n  const totalUnrealizedPnl = openPositions?.reduce((sum, pos) => sum + parseFloat(pos.unrealizedPnlUsd), 0) || 0;\n  const positionsCount = openPositions?.length || 0;\n\n  return (\n    <div className=\"min-h-screen bg-background flex flex-col relative overflow-hidden\">\n      <div \n        className=\"fixed inset-0 z-0 opacity-15 pointer-events-none\" \n        style={{ \n          backgroundImage: `url(${generatedImage})`, \n          backgroundSize: 'cover',\n          backgroundPosition: 'center',\n          mixBlendMode: 'overlay'\n        }} \n      />\n      \n      <div className=\"relative z-10 flex flex-col min-h-screen\">\n        <Nav />\n        \n        <main className=\"flex-1 p-3 md:p-4 lg:p-6 max-w-7xl mx-auto w-full\">\n          <div className=\"flex flex-col md:flex-row md:items-center justify-between gap-4 mb-4\">\n            <div className=\"flex items-center gap-3\">\n              <div className=\"h-10 w-10 bg-gradient-to-br from-cyan-500/20 to-blue-600/20 rounded-lg flex items-center justify-center border border-cyan-500/30\">\n                <BarChart3 className=\"h-5 w-5 text-cyan-400\" />\n              </div>\n              <div>\n                <h1 className=\"text-xl md:text-2xl font-bold font-mono tracking-tight text-foreground\">TERMINAL</h1>\n                <p className=\"text-xs text-muted-foreground font-mono\">POSICIONES Y OPERACIONES</p>\n              </div>\n            </div>\n            \n            <div className=\"flex items-center gap-3\">\n              <div \n                className={`flex items-center gap-2 px-3 py-1.5 rounded-lg border ${\n                  botConfig?.positionMode === 'DCA' \n                    ? 'bg-purple-500/10 border-purple-500/30' \n                    : 'bg-amber-500/10 border-amber-500/30'\n                }`}\n                data-testid=\"badge-position-mode\"\n              >\n                {botConfig?.positionMode === 'DCA' \n                  ? <Layers className=\"h-3 w-3 text-purple-400\" /> \n                  : <Square className=\"h-3 w-3 text-amber-400\" />\n                }\n                <span className=\"font-mono text-xs text-muted-foreground\">MODO:</span>\n                <span className={`font-mono text-sm font-bold ${\n                  botConfig?.positionMode === 'DCA' ? 'text-purple-400' : 'text-amber-400'\n                }`}>\n                  {botConfig?.positionMode || 'SINGLE'}\n                </span>\n              </div>\n              <div className=\"flex items-center gap-2 px-3 py-1.5 bg-card/50 rounded-lg border border-border/50\">\n                <CircleDot className={`h-3 w-3 ${positionsCount > 0 ? 'text-green-400 animate-pulse' : 'text-muted-foreground'}`} />\n                <span className=\"font-mono text-xs text-muted-foreground\">ACTIVAS:</span>\n                <span className=\"font-mono text-sm font-bold\">{positionsCount}</span>\n              </div>\n              <div className={`flex items-center gap-2 px-3 py-1.5 rounded-lg border ${totalUnrealizedPnl >= 0 ? 'bg-green-500/10 border-green-500/30' : 'bg-red-500/10 border-red-500/30'}`}>\n                {totalUnrealizedPnl >= 0 ? <TrendingUp className=\"h-3 w-3 text-green-400\" /> : <TrendingDown className=\"h-3 w-3 text-red-400\" />}\n                <span className=\"font-mono text-xs text-muted-foreground\">P&L:</span>\n                <span className={`font-mono text-sm font-bold ${totalUnrealizedPnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>\n                  {totalUnrealizedPnl >= 0 ? '+' : ''}${totalUnrealizedPnl.toFixed(2)}\n                </span>\n              </div>\n            </div>\n          </div>\n\n          <Tabs value={activeTab} onValueChange={setActiveTab} className=\"space-y-4\">\n            <div className=\"flex flex-col sm:flex-row sm:items-center justify-between gap-3\">\n              <TabsList className=\"bg-card/50 border border-border/50 p-1\">\n                <TabsTrigger \n                  value=\"positions\" \n                  className=\"font-mono text-xs data-[state=active]:bg-cyan-500/20 data-[state=active]:text-cyan-400\"\n                  data-testid=\"tab-positions\"\n                >\n                  <Target className=\"h-3.5 w-3.5 mr-1.5\" />\n                  POSICIONES\n                </TabsTrigger>\n                <TabsTrigger \n                  value=\"history\" \n                  className=\"font-mono text-xs data-[state=active]:bg-cyan-500/20 data-[state=active]:text-cyan-400\"\n                  data-testid=\"tab-history\"\n                >\n                  <Activity className=\"h-3.5 w-3.5 mr-1.5\" />\n                  HISTORIAL\n                </TabsTrigger>\n              </TabsList>\n\n              {activeTab === \"positions\" && (\n                <Button \n                  variant=\"outline\" \n                  size=\"sm\" \n                  onClick={() => refetchPositions()}\n                  disabled={fetchingPositions}\n                  className=\"font-mono text-xs border-border/50 hover:border-cyan-500/50 hover:text-cyan-400\"\n                  data-testid=\"button-refresh-positions\"\n                >\n                  <RefreshCw className={`h-3.5 w-3.5 mr-1.5 ${fetchingPositions ? 'animate-spin' : ''}`} />\n                  ACTUALIZAR\n                </Button>\n              )}\n\n              {activeTab === \"history\" && (\n                <div className=\"flex flex-wrap items-center gap-2\">\n                  <Select value={typeFilter} onValueChange={setTypeFilter}>\n                    <SelectTrigger className=\"w-[90px] h-8 text-xs font-mono bg-card/50 border-border/50\" data-testid=\"select-type-filter\">\n                      <SelectValue placeholder=\"Tipo\" />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"all\">TODAS</SelectItem>\n                      <SelectItem value=\"buy\">COMPRAS</SelectItem>\n                      <SelectItem value=\"sell\">VENTAS</SelectItem>\n                    </SelectContent>\n                  </Select>\n\n                  <Select value={pairFilter} onValueChange={setPairFilter}>\n                    <SelectTrigger className=\"w-[100px] h-8 text-xs font-mono bg-card/50 border-border/50\" data-testid=\"select-pair-filter\">\n                      <SelectValue placeholder=\"Par\" />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"all\">TODOS</SelectItem>\n                      {availablePairs.map(pair => (\n                        <SelectItem key={pair} value={pair}>{pair}</SelectItem>\n                      ))}\n                    </SelectContent>\n                  </Select>\n                  \n                  <Select value={resultFilter} onValueChange={setResultFilter}>\n                    <SelectTrigger className=\"w-[100px] h-8 text-xs font-mono bg-card/50 border-border/50\" data-testid=\"select-result-filter\">\n                      <SelectValue placeholder=\"Resultado\" />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"all\">TODAS</SelectItem>\n                      <SelectItem value=\"winner\">GANADORAS</SelectItem>\n                      <SelectItem value=\"loser\">PERDEDORAS</SelectItem>\n                    </SelectContent>\n                  </Select>\n\n                  <Select value={limit.toString()} onValueChange={handleLimitChange}>\n                    <SelectTrigger className=\"w-[70px] h-8 text-xs font-mono bg-card/50 border-border/50\" data-testid=\"select-limit\">\n                      <SelectValue />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"10\">10</SelectItem>\n                      <SelectItem value=\"25\">25</SelectItem>\n                      <SelectItem value=\"50\">50</SelectItem>\n                      <SelectItem value=\"100\">100</SelectItem>\n                      <SelectItem value=\"all\">TODO</SelectItem>\n                    </SelectContent>\n                  </Select>\n\n                  <Button \n                    variant=\"outline\" \n                    size=\"sm\" \n                    onClick={handleSyncFromKraken}\n                    disabled={syncing}\n                    className=\"text-xs font-mono border-border/50 hover:border-cyan-500/50 hover:text-cyan-400\"\n                    data-testid=\"button-sync-kraken\"\n                  >\n                    <Download className={`h-3.5 w-3.5 mr-1 ${syncing ? 'animate-pulse' : ''}`} />\n                    SYNC\n                  </Button>\n\n                  <Button \n                    variant=\"ghost\" \n                    size=\"sm\" \n                    onClick={() => refetchClosed()}\n                    disabled={fetchingClosed}\n                    className=\"text-muted-foreground hover:text-cyan-400\"\n                    data-testid=\"button-refresh-closed\"\n                  >\n                    <RefreshCw className={`h-3.5 w-3.5 ${fetchingClosed ? 'animate-spin' : ''}`} />\n                  </Button>\n                </div>\n              )}\n            </div>\n\n            <TabsContent value=\"positions\" className=\"mt-0\">\n              <Card className=\"bg-card/40 border-border/50 backdrop-blur-sm\">\n                <CardHeader className=\"py-3 px-4 border-b border-border/30\">\n                  <div className=\"flex items-center justify-between\">\n                    <CardTitle className=\"text-sm font-mono text-muted-foreground flex items-center gap-2\">\n                      <Zap className=\"h-4 w-4 text-cyan-400\" />\n                      POSICIONES ABIERTAS\n                    </CardTitle>\n                    <div className=\"flex items-center gap-3\">\n                      <span className=\"text-xs font-mono text-muted-foreground\">\n                        {openPositions?.length || 0} activa{openPositions?.length !== 1 ? 's' : ''}\n                      </span>\n                      <Button\n                        variant=\"outline\"\n                        size=\"sm\"\n                        onClick={handleReconcile}\n                        disabled={reconcileMutation.isPending}\n                        className=\"h-7 text-[10px] font-mono border-orange-500/50 text-orange-400 hover:bg-orange-500/10\"\n                        data-testid=\"button-reconcile\"\n                        title=\"Compara balances reales de Kraken y elimina posiciones huÃ©rfanas\"\n                      >\n                        {reconcileMutation.isPending ? (\n                          <Loader2 className=\"h-3 w-3 animate-spin mr-1\" />\n                        ) : (\n                          <RefreshCw className=\"h-3 w-3 mr-1\" />\n                        )}\n                        RECONCILIAR\n                      </Button>\n                    </div>\n                  </div>\n                </CardHeader>\n                <CardContent className=\"p-0\">\n                  {loadingPositions ? (\n                    <div className=\"flex items-center justify-center py-12\">\n                      <div className=\"animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-cyan-400\"></div>\n                    </div>\n                  ) : openPositions && openPositions.length > 0 ? (\n                    <div className=\"divide-y divide-border/20\">\n                      {openPositions.map((pos) => {\n                        const pnlUsd = parseFloat(pos.unrealizedPnlUsd);\n                        const pnlPct = parseFloat(pos.unrealizedPnlPct);\n                        const isProfit = pnlUsd >= 0;\n                        const strategyInfo = formatStrategyLabel(pos.entryStrategyId || \"momentum\", pos.entrySignalTf || \"cycle\");\n                        \n                        return (\n                          <div \n                            key={pos.id}\n                            className=\"flex flex-col lg:flex-row lg:items-center justify-between p-4 hover:bg-white/[0.02] transition-colors\"\n                            data-testid={`position-row-${pos.id}`}\n                          >\n                            <div className=\"flex items-center gap-4 mb-3 lg:mb-0\">\n                              <div className=\"relative\">\n                                <div className={`h-10 w-10 rounded-lg flex items-center justify-center ${isProfit ? 'bg-green-500/10 border border-green-500/30' : 'bg-red-500/10 border border-red-500/30'}`}>\n                                  {isProfit ? <TrendingUp className=\"h-5 w-5 text-green-400\" /> : <TrendingDown className=\"h-5 w-5 text-red-400\" />}\n                                </div>\n                                <div className=\"absolute -top-1 -right-1 h-3 w-3 bg-green-400 rounded-full border-2 border-background animate-pulse\" />\n                              </div>\n                              <div>\n                                <div className=\"font-mono font-bold text-base flex items-center gap-2\">\n                                  {pos.pair}\n                                  <Badge variant=\"outline\" className={`text-[10px] px-1.5 py-0 font-mono ${strategyInfo.isCandles ? 'border-cyan-500/50 text-cyan-400' : 'border-primary/50 text-primary'}`}>\n                                    {strategyInfo.isCandles ? <CandlestickChart className=\"h-2.5 w-2.5 mr-0.5\" /> : <Activity className=\"h-2.5 w-2.5 mr-0.5\" />}\n                                    {strategyInfo.strategyName}/{strategyInfo.tfLabel}\n                                  </Badge>\n                                  {pos.entryMode && (\n                                    <Badge variant=\"outline\" className=\"text-[10px] px-1.5 py-0 font-mono border-orange-500/50 text-orange-400\">\n                                      <Layers className=\"h-2.5 w-2.5 mr-0.5\" />\n                                      {pos.entryMode}\n                                    </Badge>\n                                  )}\n                                </div>\n                                <div className=\"text-xs text-muted-foreground font-mono flex items-center gap-1.5\">\n                                  <Clock className=\"h-3 w-3\" />\n                                  {formatDate(pos.openedAt)}\n                                  <span className=\"text-[10px] opacity-60\">| Lote: {pos.lotId?.substring(0, 8) || 'N/A'}</span>\n                                  {botConfig?.positionMode === 'SMART_GUARD' && (\n                                    <Badge variant=\"secondary\" className=\"text-[9px] px-1 py-0 ml-1\" title=\"Slots usados / mÃ¡ximo\">\n                                      {getLotsCountByPair(pos.pair).count}/{getLotsCountByPair(pos.pair).max}\n                                    </Badge>\n                                  )}\n                                </div>\n                              </div>\n                            </div>\n                            \n                            <div className=\"flex items-center gap-4\">\n                              <div className=\"grid grid-cols-3 sm:grid-cols-6 gap-3 lg:gap-4 flex-1\">\n                                <div>\n                                  <div className=\"font-mono text-[10px] text-muted-foreground uppercase\">Cantidad</div>\n                                  <div className=\"font-mono font-medium text-sm\">{parseFloat(pos.amount).toFixed(6)}</div>\n                                </div>\n                                <div>\n                                  <div className=\"font-mono text-[10px] text-muted-foreground uppercase\">Precio Entrada</div>\n                                  <div className=\"font-mono font-medium text-sm\">${formatPrice(pos.entryPrice)}</div>\n                                </div>\n                                <div>\n                                  <div className=\"font-mono text-[10px] text-muted-foreground uppercase\" title=\"Valor de entrada en USD\">Valor Entrada</div>\n                                  <div className=\"font-mono font-medium text-sm text-blue-400\">${parseFloat(pos.entryValueUsd).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</div>\n                                </div>\n                                <div>\n                                  <div className=\"font-mono text-[10px] text-muted-foreground uppercase\">Precio Actual</div>\n                                  <div className=\"font-mono font-medium text-sm\">${formatPrice(pos.currentPrice)}</div>\n                                </div>\n                                <div>\n                                  <div className=\"font-mono text-[10px] text-muted-foreground uppercase\" title=\"Valor actual en USD\">Valor Actual</div>\n                                  <div className=\"font-mono font-medium text-sm text-cyan-400\">${parseFloat(pos.currentValueUsd).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</div>\n                                </div>\n                                <div>\n                                  <div className=\"font-mono text-[10px] text-muted-foreground uppercase\">P&L</div>\n                                  <div className={`font-mono font-bold text-sm flex items-center gap-1 ${isProfit ? 'text-green-400' : 'text-red-400'}`}>\n                                    {isProfit ? '+' : '-'}${Math.abs(pnlUsd).toFixed(2)}\n                                    <span className=\"text-xs opacity-75\">({pnlPct >= 0 ? '+' : ''}{pnlPct.toFixed(2)}%)</span>\n                                  </div>\n                                </div>\n                              </div>\n                              <div className=\"flex gap-2 shrink-0\">\n                                <Button\n                                  variant=\"destructive\"\n                                  size=\"sm\"\n                                  onClick={() => handleClosePosition(pos.pair, pos.lotId, pos.amount)}\n                                  disabled={closingKey === getPositionKey(pos.pair, pos.lotId)}\n                                  data-testid={`button-close-position-${pos.lotId || pos.id}`}\n                                >\n                                  {closingKey === getPositionKey(pos.pair, pos.lotId) ? (\n                                    <Loader2 className=\"h-4 w-4 animate-spin\" />\n                                  ) : (\n                                    <X className=\"h-4 w-4\" />\n                                  )}\n                                  <span className=\"hidden sm:inline ml-1\">Cerrar</span>\n                                </Button>\n                                {pos.lotId && dustPositions.has(pos.lotId) && (\n                                  <Button\n                                    variant=\"outline\"\n                                    size=\"sm\"\n                                    onClick={() => handleDeleteOrphan(pos.lotId!, pos.pair, pos.amount)}\n                                    disabled={deletingOrphanKey === pos.lotId}\n                                    className=\"text-orange-400 border-orange-400/50 hover:bg-orange-400/10\"\n                                    data-testid={`button-delete-orphan-${pos.lotId}`}\n                                    title=\"Eliminar registro interno sin enviar orden a Kraken\"\n                                  >\n                                    {deletingOrphanKey === pos.lotId ? (\n                                      <Loader2 className=\"h-4 w-4 animate-spin\" />\n                                    ) : (\n                                      <Trash2 className=\"h-4 w-4\" />\n                                    )}\n                                    <span className=\"hidden lg:inline ml-1\">HuÃ©rfana</span>\n                                  </Button>\n                                )}\n                              </div>\n                            </div>\n                          </div>\n                        );\n                      })}\n                    </div>\n                  ) : (\n                    <div className=\"text-center py-16\">\n                      <div className=\"h-16 w-16 mx-auto bg-muted/20 rounded-full flex items-center justify-center mb-4\">\n                        <Target className=\"h-8 w-8 text-muted-foreground/50\" />\n                      </div>\n                      <p className=\"font-mono text-muted-foreground text-sm\">NO HAY POSICIONES ABIERTAS</p>\n                      <p className=\"text-xs text-muted-foreground mt-1\">Las posiciones aparecerÃ¡n cuando el bot compre activos</p>\n                    </div>\n                  )}\n                </CardContent>\n              </Card>\n            </TabsContent>\n\n            <TabsContent value=\"history\" className=\"mt-0\">\n              <Card className=\"bg-card/40 border-border/50 backdrop-blur-sm\">\n                <CardHeader className=\"py-3 px-4 border-b border-border/30\">\n                  <div className=\"flex items-center justify-between\">\n                    <CardTitle className=\"text-sm font-mono text-muted-foreground flex items-center gap-2\">\n                      <Activity className=\"h-4 w-4 text-cyan-400\" />\n                      HISTORIAL DE OPERACIONES\n                    </CardTitle>\n                    <span className=\"text-xs font-mono text-muted-foreground\">\n                      {closedData?.total || 0} operaciones\n                    </span>\n                  </div>\n                </CardHeader>\n                <CardContent className=\"p-0\">\n                  {loadingClosed ? (\n                    <div className=\"flex items-center justify-center py-16\">\n                      <div className=\"animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-cyan-400\"></div>\n                    </div>\n                  ) : closedData && closedData.trades.length > 0 ? (\n                    <>\n                      <div className=\"overflow-x-auto\">\n                        <table className=\"w-full min-w-[900px]\">\n                          <thead>\n                            <tr className=\"border-b border-border/30 text-left\">\n                              <th className=\"py-3 px-3 font-mono text-[10px] text-muted-foreground uppercase font-normal\">Tipo</th>\n                              <th className=\"py-3 px-3 font-mono text-[10px] text-muted-foreground uppercase font-normal\">Par</th>\n                              <th className=\"py-3 px-3 font-mono text-[10px] text-muted-foreground uppercase font-normal\">Fecha</th>\n                              <th className=\"py-3 px-3 font-mono text-[10px] text-muted-foreground uppercase font-normal text-right\">Cantidad</th>\n                              <th className=\"py-3 px-3 font-mono text-[10px] text-muted-foreground uppercase font-normal text-right\">Precio</th>\n                              <th className=\"py-3 px-3 font-mono text-[10px] text-muted-foreground uppercase font-normal text-right\" title=\"Valor total de la operaciÃ³n en USD\">Total USD</th>\n                              <th className=\"py-3 px-3 font-mono text-[10px] text-muted-foreground uppercase font-normal text-right\">P&L</th>\n                              <th className=\"py-3 px-3 font-mono text-[10px] text-muted-foreground uppercase font-normal text-center\">Estado</th>\n                            </tr>\n                          </thead>\n                          <tbody className=\"divide-y divide-border/20\">\n                            {closedData.trades.map((trade) => {\n                              const pnlUsd = trade.realizedPnlUsd ? parseFloat(trade.realizedPnlUsd) : null;\n                              const pnlPct = trade.realizedPnlPct ? parseFloat(trade.realizedPnlPct) : null;\n                              const isProfit = pnlUsd !== null && pnlUsd >= 0;\n                              \n                              return (\n                                <tr \n                                  key={trade.id}\n                                  className=\"hover:bg-white/[0.02] transition-colors\"\n                                  data-testid={`closed-trade-row-${trade.id}`}\n                                >\n                                  <td className=\"py-3 px-3\">\n                                    <div className={`inline-flex items-center gap-1.5 px-2 py-1 rounded text-xs font-mono font-bold ${trade.type === 'buy' ? 'bg-green-500/10 text-green-400' : 'bg-red-500/10 text-red-400'}`}>\n                                      {trade.type === 'buy' ? <ArrowUpRight className=\"h-3 w-3\" /> : <ArrowDownRight className=\"h-3 w-3\" />}\n                                      {trade.type === 'buy' ? 'BUY' : 'SELL'}\n                                    </div>\n                                  </td>\n                                  <td className=\"py-3 px-3\">\n                                    <span className=\"font-mono font-medium text-sm\">{trade.pair}</span>\n                                  </td>\n                                  <td className=\"py-3 px-3\">\n                                    <span className=\"font-mono text-xs text-muted-foreground\">{formatDate(trade.executedAt || trade.createdAt)}</span>\n                                  </td>\n                                  <td className=\"py-3 px-3 text-right\">\n                                    <span className=\"font-mono text-sm\">{parseFloat(trade.amount).toFixed(6)}</span>\n                                  </td>\n                                  <td className=\"py-3 px-3 text-right\">\n                                    <span className=\"font-mono text-sm\">${formatPrice(trade.price)}</span>\n                                  </td>\n                                  <td className=\"py-3 px-3 text-right\">\n                                    <span className=\"font-mono text-sm font-medium text-cyan-400\" title=\"Cantidad Ã— Precio\">\n                                      ${parseFloat(trade.totalUsd).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}\n                                    </span>\n                                  </td>\n                                  <td className=\"py-3 px-3 text-right\">\n                                    {pnlUsd !== null ? (\n                                      <span className={`font-mono font-bold text-sm ${isProfit ? 'text-green-400' : 'text-red-400'}`}>\n                                        {isProfit ? '+' : ''}${pnlUsd.toFixed(2)}\n                                        <span className=\"text-xs opacity-75 ml-1\">\n                                          ({pnlPct !== null ? (pnlPct >= 0 ? '+' : '') + pnlPct.toFixed(1) : '0'}%)\n                                        </span>\n                                      </span>\n                                    ) : (\n                                      <span className=\"font-mono text-sm text-muted-foreground\">-</span>\n                                    )}\n                                  </td>\n                                  <td className=\"py-3 px-3 text-center\">\n                                    <Badge \n                                      variant=\"outline\"\n                                      className={`font-mono text-[10px] ${\n                                        trade.status === 'filled' \n                                          ? 'border-green-500/50 text-green-400 bg-green-500/10' \n                                          : trade.status === 'pending' \n                                            ? 'border-yellow-500/50 text-yellow-400 bg-yellow-500/10' \n                                            : 'border-red-500/50 text-red-400 bg-red-500/10'\n                                      }`}\n                                    >\n                                      {trade.status === 'filled' ? 'OK' : trade.status.toUpperCase()}\n                                    </Badge>\n                                  </td>\n                                </tr>\n                              );\n                            })}\n                          </tbody>\n                        </table>\n                      </div>\n\n                      {totalPages > 1 && (\n                        <div className=\"flex items-center justify-between p-4 border-t border-border/30\">\n                          <span className=\"text-xs font-mono text-muted-foreground\">\n                            {offset + 1}-{Math.min(offset + limit, closedData.total)} de {closedData.total}\n                          </span>\n                          <div className=\"flex items-center gap-2\">\n                            <Button\n                              variant=\"outline\"\n                              size=\"sm\"\n                              onClick={handlePrevPage}\n                              disabled={offset === 0}\n                              className=\"h-7 px-2 font-mono text-xs border-border/50\"\n                              data-testid=\"button-prev-page\"\n                            >\n                              <ChevronLeft className=\"h-3.5 w-3.5\" />\n                            </Button>\n                            <span className=\"text-xs font-mono text-muted-foreground px-2\">\n                              {currentPage}/{totalPages}\n                            </span>\n                            <Button\n                              variant=\"outline\"\n                              size=\"sm\"\n                              onClick={handleNextPage}\n                              disabled={offset + limit >= closedData.total}\n                              className=\"h-7 px-2 font-mono text-xs border-border/50\"\n                              data-testid=\"button-next-page\"\n                            >\n                              <ChevronRight className=\"h-3.5 w-3.5\" />\n                            </Button>\n                          </div>\n                        </div>\n                      )}\n                    </>\n                  ) : (\n                    <div className=\"text-center py-16\">\n                      <div className=\"h-16 w-16 mx-auto bg-muted/20 rounded-full flex items-center justify-center mb-4\">\n                        <Clock className=\"h-8 w-8 text-muted-foreground/50\" />\n                      </div>\n                      <p className=\"font-mono text-muted-foreground text-sm\">NO HAY OPERACIONES</p>\n                      <p className=\"text-xs text-muted-foreground mt-1\">Las operaciones aparecerÃ¡n cuando el bot venda activos</p>\n                    </div>\n                  )}\n                </CardContent>\n              </Card>\n            </TabsContent>\n          </Tabs>\n        </main>\n      </div>\n\n      {/* Dialog de confirmaciÃ³n para eliminar posiciÃ³n huÃ©rfana */}\n      <AlertDialog open={orphanDialogOpen} onOpenChange={setOrphanDialogOpen}>\n        <AlertDialogContent className=\"bg-card border-border\">\n          <AlertDialogHeader>\n            <AlertDialogTitle className=\"flex items-center gap-2 text-orange-400\">\n              <AlertTriangle className=\"h-5 w-5\" />\n              Eliminar PosiciÃ³n HuÃ©rfana\n            </AlertDialogTitle>\n            <AlertDialogDescription className=\"space-y-3\">\n              <p>\n                Esta acciÃ³n <strong>solo elimina el registro interno</strong> del bot (base de datos).\n                <strong> NO envÃ­a ninguna orden a Kraken.</strong>\n              </p>\n              {orphanToDelete && (\n                <div className=\"bg-muted/30 rounded-md p-3 font-mono text-sm\">\n                  <div><span className=\"text-muted-foreground\">Par:</span> {orphanToDelete.pair}</div>\n                  <div><span className=\"text-muted-foreground\">Lote:</span> {orphanToDelete.lotId.substring(0, 12)}...</div>\n                  <div><span className=\"text-muted-foreground\">Cantidad:</span> {parseFloat(orphanToDelete.amount).toFixed(8)}</div>\n                </div>\n              )}\n              <p className=\"text-orange-400 text-sm\">\n                Ãšsalo cuando el balance real en Kraken sea menor al mÃ­nimo (posiciÃ³n DUST) \n                o cuando ya vendiste manualmente fuera del bot.\n              </p>\n            </AlertDialogDescription>\n          </AlertDialogHeader>\n          <AlertDialogFooter>\n            <AlertDialogCancel>Cancelar</AlertDialogCancel>\n            <AlertDialogAction\n              onClick={confirmDeleteOrphan}\n              className=\"bg-orange-500 hover:bg-orange-600\"\n              disabled={deleteOrphanMutation.isPending}\n            >\n              {deleteOrphanMutation.isPending ? (\n                <Loader2 className=\"h-4 w-4 animate-spin mr-2\" />\n              ) : (\n                <Trash2 className=\"h-4 w-4 mr-2\" />\n              )}\n              Eliminar de BD\n            </AlertDialogAction>\n          </AlertDialogFooter>\n        </AlertDialogContent>\n      </AlertDialog>\n    </div>\n  );\n}\n","path":null,"size_bytes":46142,"size_tokens":null},"client/src/pages/Monitor.tsx":{"content":"import { useState, useRef, useEffect, useMemo } from \"react\";\nimport { Nav } from \"@/components/dashboard/Nav\";\nimport { useEventsFeed } from \"@/context/EventsWebSocketContext\";\nimport { BotEvent } from \"@/hooks/useEventsWebSocket\";\nimport { useTerminalWebSocket } from \"@/hooks/useTerminalWebSocket\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { \n  Wifi, WifiOff, RefreshCw, Trash2, Pause, Play, \n  Download, Copy, Search, X, ChevronDown, ChevronRight,\n  AlertCircle, AlertTriangle, Info, Terminal, Activity,\n  Eye, TrendingUp, TrendingDown, Minus\n} from \"lucide-react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { cn } from \"@/lib/utils\";\n\nconst LEVEL_COLORS: Record<string, string> = {\n  INFO: \"bg-blue-500/20 text-blue-400 border-blue-500/30\",\n  WARN: \"bg-yellow-500/20 text-yellow-400 border-yellow-500/30\",\n  ERROR: \"bg-red-500/20 text-red-400 border-red-500/30\",\n};\n\nconst LEVEL_ICONS: Record<string, React.ReactNode> = {\n  INFO: <Info className=\"h-3 w-3\" />,\n  WARN: <AlertTriangle className=\"h-3 w-3\" />,\n  ERROR: <AlertCircle className=\"h-3 w-3\" />,\n};\n\nconst DEFAULT_EVENT_TYPES = [\n  \"TRADE_EXECUTED\", \"TRADE_BLOCKED\", \"TRADE_FAILED\", \"TRADE_ADJUSTED\", \"TRADE_REJECTED_LOW_PROFIT\", \"TRADE_SKIPPED\",\n  \"STOP_LOSS_HIT\", \"TAKE_PROFIT_HIT\", \"TRAILING_STOP_HIT\",\n  \"BOT_STARTED\", \"BOT_STOPPED\", \"BOT_PAUSED\", \"BOT_RESUMED\",\n  \"ENGINE_TICK\", \"MARKET_SCAN_SUMMARY\",\n  \"DAILY_LIMIT_HIT\", \"DAILY_LIMIT_RESET\", \"PAIR_COOLDOWN\",\n  \"KRAKEN_ERROR\", \"KRAKEN_CONNECTED\", \"TELEGRAM_ERROR\", \"TELEGRAM_CONNECTED\", \"NONCE_ERROR\",\n  \"POSITION_OPENED\", \"POSITION_CLOSED\", \"ORPHAN_POSITION_CLEANED\",\n  \"SIGNAL_GENERATED\", \"BALANCE_CHECK\", \"SYSTEM_ERROR\",\n];\n\nconst DEFAULT_PAIRS = [\"BTC/USD\", \"ETH/USD\", \"SOL/USD\", \"XRP/USD\", \"TON/USD\"];\n\nexport default function Monitor() {\n  const [activeTab, setActiveTab] = useState(\"events\");\n  \n  return (\n    <div className=\"min-h-screen bg-background\">\n      <Nav />\n      <div className=\"p-4 md:p-6 max-w-[1800px] mx-auto\">\n        <Tabs value={activeTab} onValueChange={setActiveTab} className=\"w-full\">\n          <div className=\"flex items-center gap-4 mb-4\">\n            <h1 className=\"text-xl font-bold\">Monitor</h1>\n            <TabsList>\n              <TabsTrigger value=\"events\" className=\"gap-1\" data-testid=\"tab-events\">\n                <Activity className=\"h-4 w-4\" />\n                Eventos\n              </TabsTrigger>\n              <TabsTrigger value=\"terminal\" className=\"gap-1\" data-testid=\"tab-terminal\">\n                <Terminal className=\"h-4 w-4\" />\n                Terminal\n              </TabsTrigger>\n              <TabsTrigger value=\"diagnostic\" className=\"gap-1\" data-testid=\"tab-diagnostic\">\n                <Eye className=\"h-4 w-4\" />\n                DiagnÃ³stico\n              </TabsTrigger>\n            </TabsList>\n          </div>\n          \n          <TabsContent value=\"events\" className=\"mt-0\">\n            <EventsTab />\n          </TabsContent>\n          \n          <TabsContent value=\"terminal\" className=\"mt-0\">\n            <TerminalTab />\n          </TabsContent>\n          \n          <TabsContent value=\"diagnostic\" className=\"mt-0\">\n            <DiagnosticTab />\n          </TabsContent>\n        </Tabs>\n      </div>\n    </div>\n  );\n}\n\nfunction EventsTab() {\n  const { events, status, error, connect, disconnect, clearEvents, isConnected } = useEventsFeed();\n  \n  const [autoScroll, setAutoScroll] = useState(true);\n  const [selectedEvent, setSelectedEvent] = useState<BotEvent | null>(null);\n  const [searchText, setSearchText] = useState(\"\");\n  const [levelFilter, setLevelFilter] = useState<string[]>([\"INFO\", \"WARN\", \"ERROR\"]);\n  const [typeFilter, setTypeFilter] = useState<string[]>([]);\n  const [pairFilter, setPairFilter] = useState<string[]>([]);\n  const [showFilters, setShowFilters] = useState(false);\n  const [lastMessageTime, setLastMessageTime] = useState<Date | null>(null);\n  \n  const scrollRef = useRef<HTMLDivElement>(null);\n  const prevEventsLengthRef = useRef(events.length);\n\n  useEffect(() => {\n    if (events.length > 0) {\n      const latestEvent = events[0];\n      if (latestEvent?.timestamp) {\n        setLastMessageTime(new Date(latestEvent.timestamp));\n      }\n    }\n  }, [events]);\n\n  useEffect(() => {\n    if (autoScroll && events.length > prevEventsLengthRef.current && scrollRef.current) {\n      scrollRef.current.scrollTop = 0;\n    }\n    prevEventsLengthRef.current = events.length;\n  }, [events.length, autoScroll]);\n\n  const filteredEvents = useMemo(() => {\n    return events.filter((event) => {\n      if (levelFilter.length > 0 && !levelFilter.includes(event.level)) return false;\n      if (typeFilter.length > 0 && !typeFilter.includes(event.type)) return false;\n      if (pairFilter.length > 0) {\n        const eventPair = event.meta?.pair;\n        if (!eventPair || !pairFilter.includes(eventPair)) return false;\n      }\n      if (searchText) {\n        const searchLower = searchText.toLowerCase();\n        const messageMatch = event.message.toLowerCase().includes(searchLower);\n        const typeMatch = event.type.toLowerCase().includes(searchLower);\n        const metaMatch = event.meta ? JSON.stringify(event.meta).toLowerCase().includes(searchLower) : false;\n        if (!messageMatch && !typeMatch && !metaMatch) return false;\n      }\n      return true;\n    });\n  }, [events, levelFilter, typeFilter, pairFilter, searchText]);\n\n  const stats = useMemo(() => {\n    const last24h = events.filter(e => {\n      const eventTime = new Date(e.timestamp).getTime();\n      const now = Date.now();\n      return now - eventTime < 24 * 60 * 60 * 1000;\n    });\n    return {\n      total: events.length,\n      errors: last24h.filter(e => e.level === \"ERROR\").length,\n      warnings: last24h.filter(e => e.level === \"WARN\").length,\n      trades: last24h.filter(e => e.type === \"TRADE_EXECUTED\").length,\n    };\n  }, [events]);\n\n  const availableEventTypes = useMemo(() => {\n    const fromEvents = events.map(e => e.type);\n    const combined = new Set([...DEFAULT_EVENT_TYPES, ...fromEvents]);\n    return Array.from(combined).sort();\n  }, [events]);\n\n  const availablePairs = useMemo(() => {\n    const fromEvents = events.map(e => e.meta?.pair).filter((p): p is string => Boolean(p));\n    const combined = new Set([...DEFAULT_PAIRS, ...fromEvents]);\n    return Array.from(combined).sort();\n  }, [events]);\n\n  const handleCopyEvent = (event: BotEvent) => {\n    navigator.clipboard.writeText(JSON.stringify(event, null, 2));\n  };\n\n  const handleCopyAll = () => {\n    navigator.clipboard.writeText(JSON.stringify(filteredEvents, null, 2));\n  };\n\n  const handleDownload = () => {\n    const blob = new Blob([JSON.stringify(filteredEvents, null, 2)], { type: \"application/json\" });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = `krakenbot-logs-${new Date().toISOString().split(\"T\")[0]}.json`;\n    a.click();\n    URL.revokeObjectURL(url);\n  };\n\n  const toggleLevel = (level: string) => {\n    setLevelFilter(prev => \n      prev.includes(level) ? prev.filter(l => l !== level) : [...prev, level]\n    );\n  };\n\n  const formatTimestamp = (ts: string) => {\n    const date = new Date(ts);\n    return date.toLocaleTimeString(\"es-ES\", { hour: \"2-digit\", minute: \"2-digit\", second: \"2-digit\" });\n  };\n\n  const formatDate = (ts: string) => {\n    const date = new Date(ts);\n    return date.toLocaleDateString(\"es-ES\", { day: \"2-digit\", month: \"2-digit\" });\n  };\n\n  return (\n    <div className=\"flex flex-col lg:flex-row gap-4\">\n      <div className=\"flex-1 space-y-4\">\n        <div className=\"flex flex-wrap items-center gap-2 justify-between\">\n          <div className=\"flex items-center gap-2\">\n            <Badge \n              variant=\"outline\" \n              className={cn(\n                \"gap-1\",\n                isConnected ? \"border-green-500 text-green-400\" : \n                status === \"reconnecting\" ? \"border-yellow-500 text-yellow-400\" :\n                \"border-red-500 text-red-400\"\n              )}\n              data-testid=\"badge-ws-status\"\n            >\n              {isConnected ? <Wifi className=\"h-3 w-3\" /> : \n               status === \"reconnecting\" ? <RefreshCw className=\"h-3 w-3 animate-spin\" /> :\n               <WifiOff className=\"h-3 w-3\" />}\n              {status === \"connected\" ? \"Conectado\" : \n               status === \"reconnecting\" ? \"Reconectando...\" : \n               status === \"connecting\" ? \"Conectando...\" : \"Desconectado\"}\n            </Badge>\n          </div>\n          \n          <div className=\"flex items-center gap-2\">\n            <div className=\"text-xs text-muted-foreground hidden sm:flex gap-3\">\n              <span>Eventos: {stats.total}</span>\n              <span className=\"text-red-400\">Errores 24h: {stats.errors}</span>\n              <span className=\"text-yellow-400\">Avisos 24h: {stats.warnings}</span>\n              <span className=\"text-green-400\">Trades 24h: {stats.trades}</span>\n              {lastMessageTime && (\n                <span className=\"text-cyan-400\" data-testid=\"last-message-time\">\n                  Ãšltimo: {lastMessageTime.toLocaleTimeString(\"es-ES\", { hour: \"2-digit\", minute: \"2-digit\", second: \"2-digit\" })}\n                </span>\n              )}\n            </div>\n          </div>\n        </div>\n\n        <Card className=\"border-border/50\">\n          <CardHeader className=\"py-3 px-4\">\n            <div className=\"flex flex-wrap items-center gap-2 justify-between\">\n              <div className=\"flex items-center gap-2\">\n                <div className=\"relative\">\n                  <Search className=\"absolute left-2 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground\" />\n                  <Input\n                    placeholder=\"Buscar...\"\n                    value={searchText}\n                    onChange={(e) => setSearchText(e.target.value)}\n                    className=\"pl-8 h-8 w-40 sm:w-60\"\n                    data-testid=\"input-search\"\n                  />\n                  {searchText && (\n                    <button \n                      onClick={() => setSearchText(\"\")}\n                      className=\"absolute right-2 top-1/2 -translate-y-1/2\"\n                    >\n                      <X className=\"h-3 w-3 text-muted-foreground hover:text-foreground\" />\n                    </button>\n                  )}\n                </div>\n                \n                <div className=\"flex gap-1\">\n                  {[\"INFO\", \"WARN\", \"ERROR\"].map(level => (\n                    <Button\n                      key={level}\n                      variant=\"outline\"\n                      size=\"sm\"\n                      className={cn(\n                        \"h-8 px-2 text-xs\",\n                        levelFilter.includes(level) ? LEVEL_COLORS[level] : \"opacity-40\"\n                      )}\n                      onClick={() => toggleLevel(level)}\n                      data-testid={`button-filter-${level.toLowerCase()}`}\n                    >\n                      {LEVEL_ICONS[level]}\n                      <span className=\"hidden sm:inline ml-1\">{level}</span>\n                    </Button>\n                  ))}\n                </div>\n\n                <Button\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  className=\"h-8 text-xs\"\n                  onClick={() => setShowFilters(!showFilters)}\n                >\n                  Filtros\n                  {showFilters ? <ChevronDown className=\"ml-1 h-3 w-3\" /> : <ChevronRight className=\"ml-1 h-3 w-3\" />}\n                </Button>\n              </div>\n\n              <div className=\"flex items-center gap-1\">\n                <Button\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  className=\"h-8 w-8\"\n                  onClick={() => setAutoScroll(!autoScroll)}\n                  title={autoScroll ? \"Pausar auto-scroll\" : \"Reanudar auto-scroll\"}\n                  data-testid=\"button-autoscroll\"\n                >\n                  {autoScroll ? <Pause className=\"h-4 w-4\" /> : <Play className=\"h-4 w-4\" />}\n                </Button>\n                <Button\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  className=\"h-8 w-8\"\n                  onClick={clearEvents}\n                  title=\"Limpiar\"\n                  data-testid=\"button-clear\"\n                >\n                  <Trash2 className=\"h-4 w-4\" />\n                </Button>\n                <Button\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  className=\"h-8 w-8\"\n                  onClick={handleCopyAll}\n                  title=\"Copiar todo\"\n                  data-testid=\"button-copy-all\"\n                >\n                  <Copy className=\"h-4 w-4\" />\n                </Button>\n                <Button\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  className=\"h-8 w-8\"\n                  onClick={handleDownload}\n                  title=\"Descargar\"\n                  data-testid=\"button-download\"\n                >\n                  <Download className=\"h-4 w-4\" />\n                </Button>\n                {!isConnected && (\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    className=\"h-8\"\n                    onClick={connect}\n                    data-testid=\"button-reconnect\"\n                  >\n                    Reconectar\n                  </Button>\n                )}\n              </div>\n            </div>\n\n            {showFilters && (\n              <div className=\"mt-3 pt-3 border-t border-border/50 space-y-2\">\n                <div className=\"flex flex-wrap gap-1\" data-testid=\"filter-type-container\">\n                  <span className=\"text-xs text-muted-foreground mr-2\">Tipo:</span>\n                  {availableEventTypes.map((type: string) => (\n                    <Badge\n                      key={type}\n                      variant=\"outline\"\n                      className={cn(\n                        \"cursor-pointer text-xs\",\n                        typeFilter.includes(type) ? \"bg-primary/20\" : \"opacity-50\"\n                      )}\n                      onClick={() => setTypeFilter(prev => \n                        prev.includes(type) ? prev.filter(t => t !== type) : [...prev, type]\n                      )}\n                      data-testid={`filter-type-${type}`}\n                    >\n                      {type.replace(/_/g, \" \")}\n                    </Badge>\n                  ))}\n                  {typeFilter.length > 0 && (\n                    <Button variant=\"ghost\" size=\"sm\" className=\"h-5 text-xs\" onClick={() => setTypeFilter([])} data-testid=\"button-clear-type-filter\">\n                      Limpiar\n                    </Button>\n                  )}\n                </div>\n                <div className=\"flex flex-wrap gap-1\" data-testid=\"filter-pair-container\">\n                  <span className=\"text-xs text-muted-foreground mr-2\">Par:</span>\n                  {availablePairs.map((pair: string) => (\n                    <Badge\n                      key={pair}\n                      variant=\"outline\"\n                      className={cn(\n                        \"cursor-pointer text-xs\",\n                        pairFilter.includes(pair) ? \"bg-primary/20\" : \"opacity-50\"\n                      )}\n                      onClick={() => setPairFilter(prev => \n                        prev.includes(pair) ? prev.filter(p => p !== pair) : [...prev, pair]\n                      )}\n                      data-testid={`filter-pair-${pair.replace(\"/\", \"-\")}`}\n                    >\n                      {pair}\n                    </Badge>\n                  ))}\n                  {pairFilter.length > 0 && (\n                    <Button variant=\"ghost\" size=\"sm\" className=\"h-5 text-xs\" onClick={() => setPairFilter([])} data-testid=\"button-clear-pair-filter\">\n                      Limpiar\n                    </Button>\n                  )}\n                </div>\n              </div>\n            )}\n          </CardHeader>\n          \n          <CardContent className=\"p-0\">\n            <ScrollArea className=\"h-[calc(100vh-320px)]\" ref={scrollRef}>\n              <div className=\"font-mono text-xs divide-y divide-border/30\">\n                {filteredEvents.length === 0 ? (\n                  <div className=\"p-8 text-center text-muted-foreground\">\n                    {events.length === 0 ? \"Esperando eventos...\" : \"No hay eventos que coincidan con los filtros\"}\n                  </div>\n                ) : (\n                  filteredEvents.map((event, idx) => (\n                    <div\n                      key={event.id || `${event.timestamp}-${idx}`}\n                      className={cn(\n                        \"px-3 py-2 hover:bg-muted/30 cursor-pointer transition-colors\",\n                        selectedEvent?.id === event.id && \"bg-muted/50\"\n                      )}\n                      onClick={() => setSelectedEvent(event)}\n                      data-testid={`event-row-${event.id || idx}`}\n                    >\n                      <div className=\"flex items-start gap-2\">\n                        <span className=\"text-muted-foreground whitespace-nowrap\">\n                          {formatDate(event.timestamp)} {formatTimestamp(event.timestamp)}\n                        </span>\n                        <Badge \n                          variant=\"outline\" \n                          className={cn(\"text-[10px] px-1.5 py-0\", LEVEL_COLORS[event.level])}\n                        >\n                          {event.level}\n                        </Badge>\n                        <Badge variant=\"outline\" className=\"text-[10px] px-1.5 py-0 bg-muted/50\">\n                          {event.type.replace(/_/g, \" \")}\n                        </Badge>\n                        {event.meta?.pair && (\n                          <Badge variant=\"outline\" className=\"text-[10px] px-1.5 py-0\">\n                            {event.meta.pair}\n                          </Badge>\n                        )}\n                        <span className=\"text-foreground truncate flex-1\">\n                          {event.message}\n                        </span>\n                      </div>\n                    </div>\n                  ))\n                )}\n              </div>\n            </ScrollArea>\n          </CardContent>\n        </Card>\n      </div>\n\n      <div className=\"w-full lg:w-80 xl:w-96\" data-testid=\"event-detail-panel\">\n        <Card className=\"border-border/50 sticky top-20\">\n          <CardHeader className=\"py-3 px-4\">\n            <CardTitle className=\"text-sm\">Detalle del evento</CardTitle>\n          </CardHeader>\n          <CardContent className=\"p-4 pt-0\">\n            {selectedEvent ? (\n              <div className=\"space-y-3 text-xs\" data-testid=\"event-detail-content\">\n                <div className=\"flex justify-between items-start\">\n                  <Badge className={cn(LEVEL_COLORS[selectedEvent.level])} data-testid=\"detail-level-badge\">\n                    {selectedEvent.level}\n                  </Badge>\n                  <Button\n                    variant=\"ghost\"\n                    size=\"sm\"\n                    className=\"h-6 text-xs\"\n                    onClick={() => handleCopyEvent(selectedEvent)}\n                    data-testid=\"button-copy-event\"\n                  >\n                    <Copy className=\"h-3 w-3 mr-1\" />\n                    Copiar\n                  </Button>\n                </div>\n                \n                <div>\n                  <span className=\"text-muted-foreground\">Timestamp:</span>\n                  <p className=\"font-mono\" data-testid=\"detail-timestamp\">{new Date(selectedEvent.timestamp).toLocaleString(\"es-ES\")}</p>\n                </div>\n                \n                <div>\n                  <span className=\"text-muted-foreground\">Tipo:</span>\n                  <p className=\"font-mono\" data-testid=\"detail-type\">{selectedEvent.type}</p>\n                </div>\n                \n                <div>\n                  <span className=\"text-muted-foreground\">Mensaje:</span>\n                  <p className=\"break-words\" data-testid=\"detail-message\">{selectedEvent.message}</p>\n                </div>\n                \n                {selectedEvent.meta && (\n                  <div>\n                    <span className=\"text-muted-foreground\">Meta:</span>\n                    <pre className=\"mt-1 p-2 bg-muted/50 rounded text-[10px] overflow-x-auto max-h-60\" data-testid=\"detail-meta\">\n                      {JSON.stringify(selectedEvent.meta, null, 2)}\n                    </pre>\n                  </div>\n                )}\n              </div>\n            ) : (\n              <p className=\"text-muted-foreground text-sm\" data-testid=\"detail-empty-message\">\n                Selecciona un evento para ver los detalles\n              </p>\n            )}\n          </CardContent>\n        </Card>\n      </div>\n    </div>\n  );\n}\n\nfunction TerminalTab() {\n  const {\n    lines,\n    status,\n    error,\n    sources,\n    activeSource,\n    dockerEnabled,\n    lineCount,\n    lastLineTime,\n    connect,\n    startSource,\n    stopSource,\n    clearLines,\n    isConnected,\n  } = useTerminalWebSocket({ autoConnect: true });\n  \n  const [autoScroll, setAutoScroll] = useState(true);\n  const [isPaused, setIsPaused] = useState(false);\n  const scrollRef = useRef<HTMLDivElement>(null);\n  const prevLinesLengthRef = useRef(lines.length);\n\n  useEffect(() => {\n    if (autoScroll && !isPaused && lines.length > prevLinesLengthRef.current && scrollRef.current) {\n      const scrollArea = scrollRef.current.querySelector('[data-radix-scroll-area-viewport]');\n      if (scrollArea) {\n        scrollArea.scrollTop = scrollArea.scrollHeight;\n      }\n    }\n    prevLinesLengthRef.current = lines.length;\n  }, [lines.length, autoScroll, isPaused]);\n\n  const displayLines = isPaused ? lines.slice(0, prevLinesLengthRef.current) : lines;\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex flex-wrap items-center gap-2 justify-between\">\n        <div className=\"flex items-center gap-2\">\n          <Badge \n            variant=\"outline\" \n            className={cn(\n              \"gap-1\",\n              isConnected ? \"border-green-500 text-green-400\" : \n              status === \"reconnecting\" ? \"border-yellow-500 text-yellow-400\" :\n              \"border-red-500 text-red-400\"\n            )}\n            data-testid=\"terminal-ws-status\"\n          >\n            {isConnected ? <Wifi className=\"h-3 w-3\" /> : \n             status === \"reconnecting\" ? <RefreshCw className=\"h-3 w-3 animate-spin\" /> :\n             <WifiOff className=\"h-3 w-3\" />}\n            {status === \"connected\" ? \"Conectado\" : \n             status === \"reconnecting\" ? \"Reconectando...\" : \n             status === \"connecting\" ? \"Conectando...\" : \"Desconectado\"}\n          </Badge>\n          \n          {isConnected && (\n            <Select\n              value={activeSource || \"\"}\n              onValueChange={(value) => {\n                if (value) startSource(value);\n              }}\n            >\n              <SelectTrigger className=\"w-[200px] h-8\" data-testid=\"terminal-source-select\">\n                <SelectValue placeholder=\"Seleccionar fuente...\" />\n              </SelectTrigger>\n              <SelectContent>\n                {sources.length === 0 ? (\n                  <SelectItem value=\"__empty__\" disabled>\n                    {dockerEnabled ? \"Sin fuentes\" : \"Docker deshabilitado\"}\n                  </SelectItem>\n                ) : (\n                  sources.map((source) => (\n                    <SelectItem key={source.id} value={source.id} data-testid={`source-${source.id}`}>\n                      {source.name}\n                    </SelectItem>\n                  ))\n                )}\n              </SelectContent>\n            </Select>\n          )}\n          \n          {activeSource && (\n            <Button\n              variant=\"outline\"\n              size=\"sm\"\n              className=\"h-8\"\n              onClick={stopSource}\n              data-testid=\"button-stop-source\"\n            >\n              Detener\n            </Button>\n          )}\n        </div>\n        \n        <div className=\"flex items-center gap-2\">\n          <div className=\"text-xs text-muted-foreground hidden sm:flex gap-3\">\n            <span>LÃ­neas: {lineCount}</span>\n            {lastLineTime && (\n              <span className=\"text-cyan-400\" data-testid=\"terminal-last-line-time\">\n                Ãšltimo: {lastLineTime.toLocaleTimeString(\"es-ES\", { hour: \"2-digit\", minute: \"2-digit\", second: \"2-digit\" })}\n              </span>\n            )}\n          </div>\n          \n          <div className=\"flex items-center gap-1\">\n            <Button\n              variant=\"ghost\"\n              size=\"icon\"\n              className=\"h-8 w-8\"\n              onClick={() => {\n                setIsPaused(!isPaused);\n                if (isPaused) {\n                  prevLinesLengthRef.current = lines.length;\n                }\n              }}\n              title={isPaused ? \"Reanudar\" : \"Pausar\"}\n              data-testid=\"button-terminal-pause\"\n            >\n              {isPaused ? <Play className=\"h-4 w-4\" /> : <Pause className=\"h-4 w-4\" />}\n            </Button>\n            <Button\n              variant=\"ghost\"\n              size=\"icon\"\n              className=\"h-8 w-8\"\n              onClick={clearLines}\n              title=\"Limpiar\"\n              data-testid=\"button-terminal-clear\"\n            >\n              <Trash2 className=\"h-4 w-4\" />\n            </Button>\n            {!isConnected && (\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                className=\"h-8\"\n                onClick={connect}\n                data-testid=\"button-terminal-reconnect\"\n              >\n                Reconectar\n              </Button>\n            )}\n          </div>\n        </div>\n      </div>\n\n      {error && (\n        <div className=\"bg-red-500/10 border border-red-500/30 text-red-400 rounded p-3 text-sm\" data-testid=\"terminal-error\">\n          {error}\n        </div>\n      )}\n\n      <Card className=\"border-border/50 bg-black/80\">\n        <CardContent className=\"p-0\">\n          <ScrollArea className=\"h-[calc(100vh-280px)]\" ref={scrollRef}>\n            <div className=\"font-mono text-xs p-3 text-green-400 whitespace-pre-wrap\">\n              {!isConnected ? (\n                <div className=\"text-muted-foreground\">\n                  {status === \"connecting\" ? \"Conectando al servidor...\" : \"Desconectado. Haz clic en 'Reconectar'.\"}\n                </div>\n              ) : !activeSource ? (\n                <div className=\"text-muted-foreground\">\n                  Selecciona una fuente de logs para comenzar...\n                  {!dockerEnabled && (\n                    <div className=\"mt-2 text-yellow-400\">\n                      Docker deshabilitado. Configura ENABLE_DOCKER_LOGS_STREAM=true en el servidor para habilitar logs de Docker.\n                    </div>\n                  )}\n                </div>\n              ) : displayLines.length === 0 ? (\n                <div className=\"text-muted-foreground\">\n                  Esperando lÃ­neas de log...\n                </div>\n              ) : (\n                displayLines.map((logLine) => (\n                  <div \n                    key={logLine.id} \n                    className={cn(\n                      \"py-0.5\",\n                      logLine.isError && \"text-red-400\"\n                    )}\n                    data-testid={`log-line-${logLine.id}`}\n                  >\n                    {logLine.line}\n                  </div>\n                ))\n              )}\n            </div>\n          </ScrollArea>\n        </CardContent>\n      </Card>\n      \n      {isPaused && (\n        <div className=\"text-center text-yellow-400 text-sm\" data-testid=\"terminal-paused-indicator\">\n          Pausado - Nuevas lÃ­neas no se muestran\n        </div>\n      )}\n    </div>\n  );\n}\n\ninterface DiagnosticPair {\n  pair: string;\n  signal: string;\n  razon: string;\n  cooldownSec?: number;\n  exposureAvailable: number | { maxPairAvailable: number; maxTotalAvailable: number; maxAllowed: number };\n  hasPosition: boolean;\n  positionUsd?: number;\n}\n\ninterface DiagnosticData {\n  pairs: DiagnosticPair[];\n  positionMode: string;\n  usdBalance: number;\n  totalOpenPositions: number;\n  lastScanAt: string | null;\n}\n\nfunction DiagnosticTab() {\n  const { data, isLoading, isFetching, error, refetch } = useQuery<DiagnosticData>({\n    queryKey: [\"/api/scan/diagnostic\"],\n    refetchInterval: 10000,\n    staleTime: 0,\n  });\n\n  const getSignalBadge = (signal: string) => {\n    switch (signal) {\n      case \"BUY\":\n        return (\n          <Badge className=\"bg-green-500/20 text-green-400 border-green-500/30 gap-1\">\n            <TrendingUp className=\"h-3 w-3\" />\n            COMPRA\n          </Badge>\n        );\n      case \"SELL\":\n        return (\n          <Badge className=\"bg-red-500/20 text-red-400 border-red-500/30 gap-1\">\n            <TrendingDown className=\"h-3 w-3\" />\n            VENTA\n          </Badge>\n        );\n      default:\n        return (\n          <Badge className=\"bg-muted text-muted-foreground border-muted-foreground/30 gap-1\">\n            <Minus className=\"h-3 w-3\" />\n            SIN SEÃ‘AL\n          </Badge>\n        );\n    }\n  };\n\n  const formatTime = (isoString: string | null) => {\n    if (!isoString) return \"Nunca\";\n    const date = new Date(isoString);\n    return date.toLocaleTimeString(\"es-ES\", { hour: \"2-digit\", minute: \"2-digit\", second: \"2-digit\" });\n  };\n\n  return (\n    <div className=\"space-y-4\">\n      <Card>\n        <CardHeader className=\"flex flex-row items-center justify-between pb-2\">\n          <CardTitle className=\"text-lg\">DiagnÃ³stico de Escaneo</CardTitle>\n          <div className=\"flex items-center gap-2\">\n            {data && (\n              <span className=\"text-xs text-muted-foreground\">\n                Ãšltimo scan: {formatTime(data.lastScanAt)}\n              </span>\n            )}\n            <Button \n              variant=\"outline\" \n              size=\"sm\" \n              onClick={() => refetch()}\n              disabled={isFetching}\n              data-testid=\"btn-refresh-diagnostic\"\n            >\n              <RefreshCw className={cn(\"h-4 w-4\", isFetching && \"animate-spin\")} />\n              Actualizar\n            </Button>\n          </div>\n        </CardHeader>\n        <CardContent>\n          {error ? (\n            <div className=\"text-red-400 text-sm\" data-testid=\"diagnostic-error\">\n              Error al cargar diagnÃ³stico: {(error as Error).message}\n            </div>\n          ) : !data ? (\n            <div className=\"text-muted-foreground text-sm\">Cargando...</div>\n          ) : (\n            <>\n              <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 mb-4\">\n                <div className=\"bg-muted/30 rounded-lg p-3\">\n                  <div className=\"text-xs text-muted-foreground\">Modo</div>\n                  <div className=\"text-lg font-semibold\" data-testid=\"diagnostic-mode\">{data.positionMode}</div>\n                </div>\n                <div className=\"bg-muted/30 rounded-lg p-3\">\n                  <div className=\"text-xs text-muted-foreground\">Balance USD</div>\n                  <div className=\"text-lg font-semibold\" data-testid=\"diagnostic-balance\">${data.usdBalance.toFixed(2)}</div>\n                </div>\n                <div className=\"bg-muted/30 rounded-lg p-3\">\n                  <div className=\"text-xs text-muted-foreground\">Posiciones Abiertas</div>\n                  <div className=\"text-lg font-semibold\" data-testid=\"diagnostic-positions\">{data.totalOpenPositions}</div>\n                </div>\n                <div className=\"bg-muted/30 rounded-lg p-3\">\n                  <div className=\"text-xs text-muted-foreground\">Pares Escaneados</div>\n                  <div className=\"text-lg font-semibold\" data-testid=\"diagnostic-pairs-count\">{data.pairs.length}</div>\n                </div>\n              </div>\n\n              {data.pairs.length === 0 ? (\n                <div className=\"text-muted-foreground text-sm text-center py-8\" data-testid=\"diagnostic-no-data\">\n                  No hay datos de escaneo. Activa el bot para comenzar a escanear pares.\n                </div>\n              ) : (\n                <div className=\"overflow-x-auto\">\n                  <table className=\"w-full text-sm\" data-testid=\"diagnostic-table\">\n                    <thead>\n                      <tr className=\"border-b border-muted\">\n                        <th className=\"text-left py-2 px-3 font-medium\">Par</th>\n                        <th className=\"text-left py-2 px-3 font-medium\">SeÃ±al</th>\n                        <th className=\"text-left py-2 px-3 font-medium\">RazÃ³n</th>\n                        <th className=\"text-right py-2 px-3 font-medium\">Cooldown</th>\n                        <th className=\"text-right py-2 px-3 font-medium\">Disponible</th>\n                        <th className=\"text-center py-2 px-3 font-medium\">PosiciÃ³n</th>\n                      </tr>\n                    </thead>\n                    <tbody>\n                      {data.pairs.map((p) => (\n                        <tr \n                          key={p.pair} \n                          className=\"border-b border-muted/50 hover:bg-muted/20\"\n                          data-testid={`diagnostic-row-${p.pair.replace(\"/\", \"-\")}`}\n                        >\n                          <td className=\"py-2 px-3 font-mono\">{p.pair}</td>\n                          <td className=\"py-2 px-3\">{getSignalBadge(p.signal)}</td>\n                          <td className=\"py-2 px-3 text-muted-foreground\">{p.razon}</td>\n                          <td className=\"py-2 px-3 text-right font-mono text-muted-foreground\">\n                            {p.cooldownSec && p.cooldownSec > 0 ? `${p.cooldownSec}s` : \"-\"}\n                          </td>\n                          <td className=\"py-2 px-3 text-right font-mono\">\n                            ${typeof p.exposureAvailable === 'object' \n                              ? (p.exposureAvailable?.maxAllowed?.toFixed(2) || \"0.00\")\n                              : (p.exposureAvailable?.toFixed(2) || \"0.00\")}\n                          </td>\n                          <td className=\"py-2 px-3 text-center\">\n                            {p.hasPosition ? (\n                              <Badge variant=\"secondary\" className=\"bg-blue-500/20 text-blue-400\">\n                                ${p.positionUsd?.toFixed(0) || \"?\"}\n                              </Badge>\n                            ) : (\n                              <span className=\"text-muted-foreground\">-</span>\n                            )}\n                          </td>\n                        </tr>\n                      ))}\n                    </tbody>\n                  </table>\n                </div>\n              )}\n            </>\n          )}\n        </CardContent>\n      </Card>\n    </div>\n  );\n}\n","path":null,"size_bytes":35348,"size_tokens":null},"server/services/eventsWebSocket.ts":{"content":"import { WebSocketServer, WebSocket } from \"ws\";\nimport type { Server } from \"http\";\nimport { db } from \"../db\";\nimport { botEvents } from \"@shared/schema\";\nimport { desc } from \"drizzle-orm\";\nimport { log } from \"../index\";\n\nconst WS_PATH = \"/ws/events\";\nconst SNAPSHOT_LIMIT = 50;\nconst HEARTBEAT_INTERVAL = 30000;\n\ninterface WsClient extends WebSocket {\n  isAlive: boolean;\n  connectedAt: Date;\n}\n\ninterface WsMessage {\n  type: \"EVENTS_SNAPSHOT\" | \"BOT_EVENT\" | \"WS_STATUS\" | \"ERROR\";\n  payload: any;\n}\n\nclass EventsWebSocketServer {\n  private wss: WebSocketServer | null = null;\n  private clients: Set<WsClient> = new Set();\n  private heartbeatInterval: NodeJS.Timeout | null = null;\n\n  initialize(server: Server): void {\n    this.wss = new WebSocketServer({ \n      noServer: true,\n      perMessageDeflate: false,\n    });\n\n    this.wss.on(\"connection\", async (ws: WebSocket, req) => {\n      const client = ws as WsClient;\n      const url = new URL(req.url || \"\", `http://${req.headers.host}`);\n      const token = url.searchParams.get(\"token\");\n      const expectedToken = process.env.WS_ADMIN_TOKEN;\n\n      if (!expectedToken) {\n        log(`[WS] WS_ADMIN_TOKEN no configurado - conexiÃ³n sin autenticaciÃ³n permitida (desarrollo)`, \"websocket\");\n      } else if (token !== expectedToken) {\n        log(`[WS] ConexiÃ³n rechazada - token invÃ¡lido desde ${req.socket.remoteAddress}`, \"websocket\");\n        this.sendMessage(client, { type: \"ERROR\", payload: { message: \"Token invÃ¡lido\" } });\n        client.close(4001, \"Unauthorized\");\n        return;\n      }\n\n      client.isAlive = true;\n      client.connectedAt = new Date();\n      this.clients.add(client);\n\n      log(`[WS] Cliente conectado. Total: ${this.clients.size}`, \"websocket\");\n\n      setTimeout(async () => {\n        if (client.readyState !== WebSocket.OPEN) {\n          log(`[WS] Cliente cerrado antes de enviar datos iniciales`, \"websocket\");\n          return;\n        }\n        \n        this.sendMessage(client, {\n          type: \"WS_STATUS\",\n          payload: {\n            connectedAt: client.connectedAt.toISOString(),\n            serverTime: new Date().toISOString(),\n            clientsConnected: this.clients.size,\n          },\n        });\n        \n        try {\n          const snapshot = await this.getEventsSnapshot();\n          if (client.readyState === WebSocket.OPEN) {\n            this.sendMessage(client, {\n              type: \"EVENTS_SNAPSHOT\",\n              payload: snapshot,\n            });\n          }\n        } catch (error) {\n          log(`[WS] Error enviando snapshot: ${error}`, \"websocket\");\n        }\n      }, 500);\n\n      client.on(\"pong\", () => {\n        client.isAlive = true;\n      });\n\n      client.on(\"close\", () => {\n        this.clients.delete(client);\n        log(`[WS] Cliente desconectado. Total: ${this.clients.size}`, \"websocket\");\n      });\n\n      client.on(\"error\", (error) => {\n        log(`[WS] Error en cliente: ${error.message}`, \"websocket\");\n        this.clients.delete(client);\n      });\n    });\n\n    this.startHeartbeat();\n    log(`[WS] Servidor WebSocket inicializado en ${WS_PATH}`, \"websocket\");\n  }\n\n  private startHeartbeat(): void {\n    this.heartbeatInterval = setInterval(() => {\n      this.clients.forEach((client) => {\n        if (!client.isAlive) {\n          log(`[WS] Cliente muerto detectado, cerrando conexiÃ³n`, \"websocket\");\n          client.terminate();\n          this.clients.delete(client);\n          return;\n        }\n        client.isAlive = false;\n        client.ping();\n      });\n    }, HEARTBEAT_INTERVAL);\n  }\n\n  private sendMessage(client: WsClient, message: WsMessage): void {\n    if (client.readyState === WebSocket.OPEN) {\n      try {\n        client.send(JSON.stringify(message));\n      } catch (error) {\n        log(`[WS] Error enviando mensaje: ${error}`, \"websocket\");\n      }\n    }\n  }\n\n  private async getEventsSnapshot(): Promise<any[]> {\n    try {\n      const events = await db.select()\n        .from(botEvents)\n        .orderBy(desc(botEvents.timestamp))\n        .limit(SNAPSHOT_LIMIT);\n\n      return events.map(e => ({\n        id: e.id,\n        timestamp: e.timestamp,\n        level: e.level,\n        type: e.type,\n        message: e.message,\n        meta: e.meta ? JSON.parse(e.meta) : null,\n      }));\n    } catch (error) {\n      log(`[WS] Error obteniendo snapshot: ${error}`, \"websocket\");\n      return [];\n    }\n  }\n\n  broadcast(event: {\n    id?: number;\n    timestamp: string;\n    level: string;\n    type: string;\n    message: string;\n    meta?: any;\n    env?: string;\n    instanceId?: string;\n  }): void {\n    const message: WsMessage = {\n      type: \"BOT_EVENT\",\n      payload: event,\n    };\n\n    const messageStr = JSON.stringify(message);\n    let sentCount = 0;\n\n    this.clients.forEach((client) => {\n      if (client.readyState === WebSocket.OPEN) {\n        try {\n          client.send(messageStr);\n          sentCount++;\n        } catch (error) {\n          log(`[WS] Error en broadcast: ${error}`, \"websocket\");\n        }\n      }\n    });\n  }\n\n  getClientCount(): number {\n    return this.clients.size;\n  }\n\n  handleUpgrade(req: any, socket: any, head: any): void {\n    if (!this.wss) return;\n    this.wss.handleUpgrade(req, socket, head, (ws) => {\n      this.wss!.emit(\"connection\", ws, req);\n    });\n  }\n\n  shutdown(): void {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n    }\n    this.clients.forEach((client) => {\n      client.close(1001, \"Server shutting down\");\n    });\n    this.wss?.close();\n  }\n}\n\nexport const eventsWs = new EventsWebSocketServer();\n","path":null,"size_bytes":5564,"size_tokens":null},"client/src/hooks/useEventsWebSocket.ts":{"content":"import { useState, useEffect, useCallback, useRef, useSyncExternalStore } from \"react\";\n\nexport interface BotEvent {\n  id?: number;\n  timestamp: string;\n  level: \"INFO\" | \"WARN\" | \"ERROR\";\n  type: string;\n  message: string;\n  meta?: Record<string, any> | null;\n}\n\ntype WsStatus = \"connecting\" | \"connected\" | \"disconnected\" | \"reconnecting\";\n\ninterface WsState {\n  events: BotEvent[];\n  status: WsStatus;\n  error: string | null;\n}\n\ntype Listener = () => void;\n\ndeclare global {\n  interface Window {\n    __eventsWsSingleton?: EventsWebSocketSingleton;\n  }\n}\n\nclass EventsWebSocketSingleton {\n  private ws: WebSocket | null = null;\n  private state: WsState = { events: [], status: \"disconnected\", error: null };\n  private listeners: Set<Listener> = new Set();\n  private reconnectTimeout: NodeJS.Timeout | null = null;\n  private reconnectAttempts = 0;\n  private flushInterval: NodeJS.Timeout | null = null;\n  private eventBuffer: BotEvent[] = [];\n  private maxEvents = 500;\n  private refCount = 0;\n  private lastConnectTime = 0;\n  private connectLock = false;\n\n  static getInstance(): EventsWebSocketSingleton {\n    if (!window.__eventsWsSingleton) {\n      window.__eventsWsSingleton = new EventsWebSocketSingleton();\n    }\n    return window.__eventsWsSingleton;\n  }\n\n  subscribe(listener: Listener): () => void {\n    this.listeners.add(listener);\n    this.refCount++;\n    \n    if (this.refCount === 1 && this.state.status === \"disconnected\") {\n      this.connect();\n    }\n    \n    return () => {\n      this.listeners.delete(listener);\n      this.refCount--;\n    };\n  }\n\n  getSnapshot(): WsState {\n    return this.state;\n  }\n\n  private notify(): void {\n    this.listeners.forEach(listener => listener());\n  }\n\n  private setState(partial: Partial<WsState>): void {\n    this.state = { ...this.state, ...partial };\n    this.notify();\n  }\n\n  private getWsUrl(): string {\n    const protocol = window.location.protocol === \"https:\" ? \"wss:\" : \"ws:\";\n    const token = localStorage.getItem(\"WS_ADMIN_TOKEN\") || \"\";\n    return `${protocol}//${window.location.host}/ws/events${token ? `?token=${token}` : \"\"}`;\n  }\n\n  private flushBuffer = (): void => {\n    if (this.eventBuffer.length > 0) {\n      const newEvents = [...this.eventBuffer, ...this.state.events].slice(0, this.maxEvents);\n      this.eventBuffer = [];\n      this.setState({ events: newEvents });\n    }\n  };\n\n  connect(): void {\n    if (this.connectLock) return;\n    \n    if (this.ws?.readyState === WebSocket.OPEN || \n        this.ws?.readyState === WebSocket.CONNECTING) return;\n\n    const now = Date.now();\n    if (now - this.lastConnectTime < 2000) {\n      if (!this.reconnectTimeout) {\n        this.reconnectTimeout = setTimeout(() => {\n          this.reconnectTimeout = null;\n          this.connect();\n        }, 2000 - (now - this.lastConnectTime));\n      }\n      return;\n    }\n\n    this.connectLock = true;\n    this.lastConnectTime = now;\n    this.setState({ status: \"connecting\", error: null });\n\n    try {\n      const ws = new WebSocket(this.getWsUrl());\n      this.ws = ws;\n\n      ws.onopen = () => {\n        this.connectLock = false;\n        this.setState({ status: \"connected\", error: null });\n        this.reconnectAttempts = 0;\n\n        if (this.flushInterval) clearInterval(this.flushInterval);\n        this.flushInterval = setInterval(this.flushBuffer, 300);\n      };\n\n      ws.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n          \n          if (data.type === \"EVENTS_SNAPSHOT\") {\n            this.setState({ events: data.payload || [] });\n          } else if (data.type === \"BOT_EVENT\") {\n            this.eventBuffer.unshift(data.payload);\n          } else if (data.type === \"ERROR\") {\n            this.setState({ error: data.payload?.message || \"Error desconocido\" });\n          }\n        } catch (e) {\n          console.error(\"[WS] Error parseando mensaje:\", e);\n        }\n      };\n\n      ws.onclose = (event) => {\n        this.ws = null;\n        this.connectLock = false;\n        \n        if (this.flushInterval) {\n          clearInterval(this.flushInterval);\n          this.flushInterval = null;\n        }\n\n        if (event.code !== 4001 && event.code !== 1000 && this.refCount > 0) {\n          const delay = Math.max(2000, Math.min(2000 * Math.pow(2, this.reconnectAttempts), 30000));\n          this.reconnectAttempts++;\n          this.setState({ status: \"reconnecting\" });\n          \n          this.reconnectTimeout = setTimeout(() => {\n            if (this.refCount > 0) this.connect();\n          }, delay);\n        } else {\n          this.setState({ status: \"disconnected\" });\n        }\n      };\n\n      ws.onerror = () => {\n        this.setState({ error: \"Error de conexiÃ³n WebSocket\" });\n      };\n    } catch (e) {\n      this.connectLock = false;\n      this.setState({ error: \"No se pudo establecer conexiÃ³n WebSocket\", status: \"disconnected\" });\n    }\n  }\n\n  disconnect(): void {\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.flushInterval) {\n      clearInterval(this.flushInterval);\n      this.flushInterval = null;\n    }\n    if (this.ws) {\n      this.ws.close(1000, \"User disconnect\");\n      this.ws = null;\n    }\n    this.setState({ status: \"disconnected\" });\n  }\n\n  clearEvents(): void {\n    this.eventBuffer = [];\n    this.setState({ events: [] });\n  }\n}\n\ninterface UseEventsWebSocketOptions {\n  maxEvents?: number;\n  autoConnect?: boolean;\n}\n\nexport function useEventsWebSocket(_options: UseEventsWebSocketOptions = {}) {\n  const singleton = EventsWebSocketSingleton.getInstance();\n  \n  const state = useSyncExternalStore(\n    (listener) => singleton.subscribe(listener),\n    () => singleton.getSnapshot()\n  );\n\n  const connect = useCallback(() => singleton.connect(), [singleton]);\n  const disconnect = useCallback(() => singleton.disconnect(), [singleton]);\n  const clearEvents = useCallback(() => singleton.clearEvents(), [singleton]);\n\n  return {\n    events: state.events,\n    status: state.status,\n    error: state.error,\n    connect,\n    disconnect,\n    clearEvents,\n    isConnected: state.status === \"connected\",\n  };\n}\n","path":null,"size_bytes":6144,"size_tokens":null},"client/src/hooks/useTerminalWebSocket.ts":{"content":"import { useState, useEffect, useCallback, useRef } from \"react\";\n\nexport interface LogLine {\n  id: number;\n  timestamp: Date;\n  line: string;\n  sourceId: string;\n  isError?: boolean;\n}\n\nexport interface LogSource {\n  id: string;\n  name: string;\n  type: \"docker_compose\" | \"docker_container\" | \"file\";\n}\n\ntype WsStatus = \"connecting\" | \"connected\" | \"disconnected\" | \"reconnecting\";\n\ninterface UseTerminalWebSocketOptions {\n  maxLines?: number;\n  autoConnect?: boolean;\n}\n\nexport function useTerminalWebSocket(options: UseTerminalWebSocketOptions = {}) {\n  const { maxLines = 500, autoConnect = true } = options;\n  \n  const [lines, setLines] = useState<LogLine[]>([]);\n  const [status, setStatus] = useState<WsStatus>(\"disconnected\");\n  const [error, setError] = useState<string | null>(null);\n  const [sources, setSources] = useState<LogSource[]>([]);\n  const [activeSource, setActiveSource] = useState<string | null>(null);\n  const [dockerEnabled, setDockerEnabled] = useState(false);\n  const [lineCount, setLineCount] = useState(0);\n  const [lastLineTime, setLastLineTime] = useState<Date | null>(null);\n  \n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const reconnectAttemptsRef = useRef(0);\n  const lineIdRef = useRef(0);\n\n  const getWsUrl = useCallback(() => {\n    const protocol = window.location.protocol === \"https:\" ? \"wss:\" : \"ws:\";\n    const token = localStorage.getItem(\"TERMINAL_TOKEN\") || \"\";\n    return `${protocol}//${window.location.host}/ws/logs${token ? `?token=${token}` : \"\"}`;\n  }, []);\n\n  const connect = useCallback(() => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) return;\n\n    setStatus(\"connecting\");\n    setError(null);\n\n    try {\n      const ws = new WebSocket(getWsUrl());\n      wsRef.current = ws;\n\n      ws.onopen = () => {\n        setStatus(\"connected\");\n        setError(null);\n        reconnectAttemptsRef.current = 0;\n      };\n\n      ws.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n          \n          switch (data.type) {\n            case \"WS_STATUS\":\n              setSources(data.payload.availableSources || []);\n              setDockerEnabled(data.payload.dockerEnabled);\n              break;\n            case \"LOG_LINE\":\n              lineIdRef.current++;\n              const newLine: LogLine = {\n                id: lineIdRef.current,\n                timestamp: new Date(),\n                line: data.payload.line,\n                sourceId: data.payload.sourceId,\n                isError: data.payload.isError,\n              };\n              setLines((prev) => [...prev, newLine].slice(-maxLines));\n              setLineCount((c) => c + 1);\n              setLastLineTime(new Date());\n              break;\n            case \"SOURCE_CHANGED\":\n              setActiveSource(data.payload.sourceId);\n              setLines([]);\n              setLineCount(0);\n              break;\n            case \"SOURCE_STOPPED\":\n              setActiveSource(null);\n              break;\n            case \"ERROR\":\n              setError(data.payload?.message || \"Error desconocido\");\n              break;\n          }\n        } catch (e) {\n          console.error(\"[WS-LOGS] Error parseando mensaje:\", e);\n        }\n      };\n\n      ws.onclose = (event) => {\n        setStatus(\"disconnected\");\n        wsRef.current = null;\n        setActiveSource(null);\n\n        if (event.code !== 4001 && event.code !== 1000) {\n          const delay = Math.min(1000 * Math.pow(2, reconnectAttemptsRef.current), 10000);\n          reconnectAttemptsRef.current++;\n          setStatus(\"reconnecting\");\n          \n          reconnectTimeoutRef.current = setTimeout(() => {\n            connect();\n          }, delay);\n        }\n      };\n\n      ws.onerror = () => {\n        setError(\"Error de conexiÃ³n WebSocket\");\n      };\n    } catch (e) {\n      setError(\"No se pudo establecer conexiÃ³n WebSocket\");\n      setStatus(\"disconnected\");\n    }\n  }, [getWsUrl, maxLines]);\n\n  const disconnect = useCallback(() => {\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n    if (wsRef.current) {\n      wsRef.current.close(1000, \"User disconnect\");\n      wsRef.current = null;\n    }\n    setStatus(\"disconnected\");\n    setActiveSource(null);\n  }, []);\n\n  const startSource = useCallback((sourceId: string) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({ type: \"START_SOURCE\", sourceId }));\n    }\n  }, []);\n\n  const stopSource = useCallback(() => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify({ type: \"STOP_SOURCE\" }));\n    }\n  }, []);\n\n  const clearLines = useCallback(() => {\n    setLines([]);\n    setLineCount(0);\n  }, []);\n\n  useEffect(() => {\n    if (autoConnect) {\n      connect();\n    }\n    return () => {\n      disconnect();\n    };\n  }, [autoConnect, connect, disconnect]);\n\n  return {\n    lines,\n    status,\n    error,\n    sources,\n    activeSource,\n    dockerEnabled,\n    lineCount,\n    lastLineTime,\n    connect,\n    disconnect,\n    startSource,\n    stopSource,\n    clearLines,\n    isConnected: status === \"connected\",\n  };\n}\n","path":null,"size_bytes":5243,"size_tokens":null},"server/services/terminalWebSocket.ts":{"content":"import { WebSocketServer, WebSocket } from \"ws\";\nimport type { Server } from \"http\";\nimport { spawn, ChildProcess } from \"child_process\";\nimport { log } from \"../index\";\n\nconst WS_PATH = \"/ws/logs\";\nconst MAX_LOG_HISTORY = 200;\nconst HEARTBEAT_INTERVAL = 30000;\n\ninterface WsClient extends WebSocket {\n  isAlive: boolean;\n  connectedAt: Date;\n  activeSource: string | null;\n  activeProcess: ChildProcess | null;\n}\n\ninterface WsMessage {\n  type: \"LOG_LINE\" | \"LOG_HISTORY\" | \"WS_STATUS\" | \"ERROR\" | \"SOURCE_CHANGED\" | \"SOURCE_STOPPED\";\n  payload: any;\n}\n\ninterface LogSource {\n  id: string;\n  name: string;\n  type: \"docker_compose\" | \"docker_container\" | \"file\";\n  command?: string[];\n  containerName?: string;\n  filePath?: string;\n}\n\nconst PREDEFINED_SOURCES: LogSource[] = [\n  {\n    id: \"docker_compose\",\n    name: \"Docker Compose (todos)\",\n    type: \"docker_compose\",\n    command: [\"docker\", \"compose\", \"logs\", \"-f\", \"--tail=200\"],\n  },\n  {\n    id: \"krakenbot_container\",\n    name: \"KrakenBot Container\",\n    type: \"docker_container\",\n    containerName: \"kraken-bot-app\",\n  },\n  {\n    id: \"postgres_container\",\n    name: \"PostgreSQL Container\",\n    type: \"docker_container\",\n    containerName: \"kraken-bot-db\",\n  },\n  {\n    id: \"app_log\",\n    name: \"App Log File\",\n    type: \"file\",\n    filePath: \"/var/log/krakenbot/app.log\",\n  },\n];\n\nclass TerminalWebSocketServer {\n  private wss: WebSocketServer | null = null;\n  private clients: Set<WsClient> = new Set();\n  private heartbeatInterval: NodeJS.Timeout | null = null;\n  private dockerEnabled: boolean = false;\n\n  initialize(server: Server): void {\n    this.dockerEnabled = process.env.ENABLE_DOCKER_LOGS_STREAM === \"true\";\n\n    this.wss = new WebSocketServer({ \n      noServer: true,\n      perMessageDeflate: false,\n    });\n\n    this.wss.on(\"connection\", async (ws: WebSocket, req) => {\n      const client = ws as WsClient;\n      const url = new URL(req.url || \"\", `http://${req.headers.host}`);\n      const token = url.searchParams.get(\"token\");\n      const expectedToken = process.env.TERMINAL_TOKEN;\n\n      if (!expectedToken) {\n        log(`[WS-LOGS] TERMINAL_TOKEN no configurado - conexiÃ³n rechazada`, \"websocket\");\n        this.sendMessage(client, { type: \"ERROR\", payload: { message: \"TERMINAL_TOKEN no configurado\" } });\n        client.close(4001, \"Unauthorized\");\n        return;\n      }\n\n      if (token !== expectedToken) {\n        log(`[WS-LOGS] ConexiÃ³n rechazada - token invÃ¡lido desde ${req.socket.remoteAddress}`, \"websocket\");\n        this.sendMessage(client, { type: \"ERROR\", payload: { message: \"Token invÃ¡lido\" } });\n        client.close(4001, \"Unauthorized\");\n        return;\n      }\n\n      client.isAlive = true;\n      client.connectedAt = new Date();\n      client.activeSource = null;\n      client.activeProcess = null;\n      this.clients.add(client);\n\n      log(`[WS-LOGS] Cliente conectado. Total: ${this.clients.size}`, \"websocket\");\n\n      const availableSources = this.getAvailableSources();\n      this.sendMessage(client, {\n        type: \"WS_STATUS\",\n        payload: {\n          connectedAt: client.connectedAt.toISOString(),\n          serverTime: new Date().toISOString(),\n          dockerEnabled: this.dockerEnabled,\n          availableSources: availableSources.map(s => ({ id: s.id, name: s.name, type: s.type })),\n        },\n      });\n\n      client.on(\"message\", (data) => {\n        try {\n          const message = JSON.parse(data.toString());\n          this.handleClientMessage(client, message);\n        } catch (e) {\n          log(`[WS-LOGS] Error parseando mensaje: ${e}`, \"websocket\");\n        }\n      });\n\n      client.on(\"pong\", () => {\n        client.isAlive = true;\n      });\n\n      client.on(\"close\", () => {\n        this.stopClientProcess(client);\n        this.clients.delete(client);\n        log(`[WS-LOGS] Cliente desconectado. Total: ${this.clients.size}`, \"websocket\");\n      });\n\n      client.on(\"error\", (error) => {\n        log(`[WS-LOGS] Error en cliente: ${error.message}`, \"websocket\");\n        this.stopClientProcess(client);\n        this.clients.delete(client);\n      });\n    });\n\n    this.startHeartbeat();\n    log(`[WS-LOGS] Terminal WebSocket inicializado en ${WS_PATH} (docker: ${this.dockerEnabled})`, \"websocket\");\n  }\n\n  private getAvailableSources(): LogSource[] {\n    return PREDEFINED_SOURCES.filter(source => {\n      if (source.type === \"docker_compose\" || source.type === \"docker_container\") {\n        return this.dockerEnabled;\n      }\n      return true;\n    });\n  }\n\n  private handleClientMessage(client: WsClient, message: any): void {\n    switch (message.type) {\n      case \"START_SOURCE\":\n        this.startLogSource(client, message.sourceId);\n        break;\n      case \"STOP_SOURCE\":\n        this.stopClientProcess(client);\n        this.sendMessage(client, { type: \"SOURCE_STOPPED\", payload: { sourceId: client.activeSource } });\n        client.activeSource = null;\n        break;\n      default:\n        log(`[WS-LOGS] Mensaje desconocido: ${message.type}`, \"websocket\");\n    }\n  }\n\n  private startLogSource(client: WsClient, sourceId: string): void {\n    const source = this.getAvailableSources().find(s => s.id === sourceId);\n    \n    if (!source) {\n      this.sendMessage(client, { \n        type: \"ERROR\", \n        payload: { message: `Fuente no disponible: ${sourceId}` } \n      });\n      return;\n    }\n\n    this.stopClientProcess(client);\n\n    let command: string[];\n    \n    switch (source.type) {\n      case \"docker_compose\":\n        command = source.command || [\"docker\", \"compose\", \"logs\", \"-f\", \"--tail=200\"];\n        break;\n      case \"docker_container\":\n        command = [\"docker\", \"logs\", \"-f\", \"--tail=200\", source.containerName || \"\"];\n        break;\n      case \"file\":\n        command = [\"tail\", \"-f\", \"-n\", \"200\", source.filePath || \"\"];\n        break;\n      default:\n        this.sendMessage(client, { type: \"ERROR\", payload: { message: \"Tipo de fuente no soportado\" } });\n        return;\n    }\n\n    try {\n      const proc = spawn(command[0], command.slice(1), {\n        stdio: [\"ignore\", \"pipe\", \"pipe\"],\n      });\n\n      client.activeProcess = proc;\n      client.activeSource = sourceId;\n\n      log(`[WS-LOGS] Iniciando fuente ${sourceId}: ${command.join(\" \")}`, \"websocket\");\n\n      this.sendMessage(client, { \n        type: \"SOURCE_CHANGED\", \n        payload: { sourceId, sourceName: source.name } \n      });\n\n      proc.stdout?.on(\"data\", (data) => {\n        const lines = data.toString().split(\"\\n\").filter((l: string) => l.trim());\n        lines.forEach((line: string) => {\n          this.sendMessage(client, { type: \"LOG_LINE\", payload: { line, sourceId } });\n        });\n      });\n\n      proc.stderr?.on(\"data\", (data) => {\n        const lines = data.toString().split(\"\\n\").filter((l: string) => l.trim());\n        lines.forEach((line: string) => {\n          this.sendMessage(client, { type: \"LOG_LINE\", payload: { line, sourceId, isError: true } });\n        });\n      });\n\n      proc.on(\"close\", (code) => {\n        log(`[WS-LOGS] Proceso terminado (${sourceId}): cÃ³digo ${code}`, \"websocket\");\n        if (client.activeSource === sourceId) {\n          this.sendMessage(client, { \n            type: \"SOURCE_STOPPED\", \n            payload: { sourceId, exitCode: code } \n          });\n          client.activeSource = null;\n          client.activeProcess = null;\n        }\n      });\n\n      proc.on(\"error\", (err) => {\n        log(`[WS-LOGS] Error en proceso (${sourceId}): ${err.message}`, \"websocket\");\n        this.sendMessage(client, { \n          type: \"ERROR\", \n          payload: { message: `Error al iniciar fuente: ${err.message}` } \n        });\n        client.activeSource = null;\n        client.activeProcess = null;\n      });\n\n    } catch (error: any) {\n      log(`[WS-LOGS] Error spawning proceso: ${error.message}`, \"websocket\");\n      this.sendMessage(client, { \n        type: \"ERROR\", \n        payload: { message: `Error al ejecutar comando: ${error.message}` } \n      });\n    }\n  }\n\n  private stopClientProcess(client: WsClient): void {\n    if (client.activeProcess) {\n      try {\n        client.activeProcess.kill(\"SIGTERM\");\n      } catch (e) {\n        // Process may already be dead\n      }\n      client.activeProcess = null;\n    }\n  }\n\n  private startHeartbeat(): void {\n    this.heartbeatInterval = setInterval(() => {\n      this.clients.forEach((client) => {\n        if (!client.isAlive) {\n          log(`[WS-LOGS] Cliente muerto detectado, cerrando conexiÃ³n`, \"websocket\");\n          this.stopClientProcess(client);\n          client.terminate();\n          this.clients.delete(client);\n          return;\n        }\n        client.isAlive = false;\n        client.ping();\n      });\n    }, HEARTBEAT_INTERVAL);\n  }\n\n  private sendMessage(client: WsClient, message: WsMessage): void {\n    if (client.readyState === WebSocket.OPEN) {\n      try {\n        client.send(JSON.stringify(message));\n      } catch (error) {\n        log(`[WS-LOGS] Error enviando mensaje: ${error}`, \"websocket\");\n      }\n    }\n  }\n\n  getClientCount(): number {\n    return this.clients.size;\n  }\n\n  handleUpgrade(req: any, socket: any, head: any): void {\n    if (!this.wss) return;\n    this.wss.handleUpgrade(req, socket, head, (ws) => {\n      this.wss!.emit(\"connection\", ws, req);\n    });\n  }\n\n  shutdown(): void {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n    }\n    this.clients.forEach((client) => {\n      this.stopClientProcess(client);\n      client.close(1001, \"Server shutting down\");\n    });\n    if (this.wss) {\n      this.wss.close();\n    }\n  }\n}\n\nexport const terminalWsServer = new TerminalWebSocketServer();\n","path":null,"size_bytes":9606,"size_tokens":null},"client/src/context/EventsWebSocketContext.tsx":{"content":"import { ReactNode } from \"react\";\nimport { useEventsWebSocket } from \"@/hooks/useEventsWebSocket\";\n\ninterface EventsWebSocketProviderProps {\n  children: ReactNode;\n}\n\nexport function EventsWebSocketProvider({ children }: EventsWebSocketProviderProps) {\n  return <>{children}</>;\n}\n\nexport function useEventsFeed() {\n  return useEventsWebSocket();\n}\n","path":null,"size_bytes":350,"size_tokens":null},"server/services/environment.ts":{"content":"import { randomUUID } from \"crypto\";\nimport { hostname } from \"os\";\n\ntype EnvTag = \"REPLIT/DEV\" | \"NAS/PROD\";\n\nclass EnvironmentService {\n  private _envTag: EnvTag;\n  private _instanceId: string;\n  private _isReplit: boolean;\n\n  constructor() {\n    this._isReplit = !!(process.env.REPLIT_DEPLOYMENT || process.env.REPL_ID);\n    this._envTag = this._isReplit ? \"REPLIT/DEV\" : \"NAS/PROD\";\n    this._instanceId = `${hostname()}-${process.pid}-${randomUUID().slice(0, 8)}`;\n  }\n\n  get envTag(): EnvTag {\n    return this._envTag;\n  }\n\n  get instanceId(): string {\n    return this._instanceId;\n  }\n\n  get isReplit(): boolean {\n    return this._isReplit;\n  }\n\n  get isNAS(): boolean {\n    return !this._isReplit;\n  }\n\n  getMessagePrefix(dryRun: boolean): string {\n    if (this._isReplit || dryRun) {\n      return `[${this._envTag}][DRY_RUN] `;\n    }\n    return `[${this._envTag}] `;\n  }\n\n  getInfo(): { env: EnvTag; instanceId: string; isReplit: boolean; isNAS: boolean } {\n    return {\n      env: this._envTag,\n      instanceId: this._instanceId,\n      isReplit: this._isReplit,\n      isNAS: !this._isReplit,\n    };\n  }\n}\n\nexport const environment = new EnvironmentService();\n","path":null,"size_bytes":1170,"size_tokens":null},"client/src/components/dashboard/EnvironmentBadge.tsx":{"content":"import { useQuery } from \"@tanstack/react-query\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Server, TestTube, AlertTriangle } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\n\ninterface EnvironmentData {\n  env: \"REPLIT/DEV\" | \"NAS/PROD\";\n  instanceId: string;\n  isReplit: boolean;\n  isNAS: boolean;\n  dryRun: boolean;\n  gitCommit?: string;\n}\n\nexport function EnvironmentBadge({ compact = false }: { compact?: boolean }) {\n  const { data, isLoading } = useQuery<EnvironmentData>({\n    queryKey: [\"environment\"],\n    queryFn: async () => {\n      const res = await fetch(\"/api/environment\");\n      if (!res.ok) throw new Error(\"Failed to fetch environment\");\n      return res.json();\n    },\n    staleTime: 60000,\n  });\n\n  if (isLoading || !data) return null;\n\n  const isProduction = data.env === \"NAS/PROD\";\n  const showDryRunWarning = data.dryRun;\n\n  if (compact) {\n    return (\n      <div className=\"flex items-center gap-2\" data-testid=\"environment-badge-compact\">\n        <Badge \n          variant=\"outline\"\n          className={cn(\n            \"font-mono text-xs\",\n            isProduction \n              ? \"bg-green-500/10 text-green-500 border-green-500/30\" \n              : \"bg-yellow-500/10 text-yellow-500 border-yellow-500/30\"\n          )}\n        >\n          {isProduction ? <Server className=\"w-3 h-3 mr-1\" /> : <TestTube className=\"w-3 h-3 mr-1\" />}\n          {data.env}\n        </Badge>\n        {showDryRunWarning && (\n          <Badge \n            variant=\"outline\"\n            className=\"font-mono text-xs bg-orange-500/10 text-orange-500 border-orange-500/30\"\n          >\n            <AlertTriangle className=\"w-3 h-3 mr-1\" />\n            DRY_RUN\n          </Badge>\n        )}\n      </div>\n    );\n  }\n\n  return (\n    <div \n      className={cn(\n        \"p-3 rounded-lg border flex flex-col sm:flex-row items-start sm:items-center gap-2 sm:gap-4\",\n        isProduction \n          ? \"bg-green-500/5 border-green-500/20\" \n          : \"bg-yellow-500/5 border-yellow-500/20\"\n      )}\n      data-testid=\"environment-badge\"\n    >\n      <div className=\"flex items-center gap-2\">\n        {isProduction ? (\n          <Server className={cn(\"w-5 h-5\", isProduction ? \"text-green-500\" : \"text-yellow-500\")} />\n        ) : (\n          <TestTube className=\"w-5 h-5 text-yellow-500\" />\n        )}\n        <div>\n          <div className=\"flex items-center gap-2\">\n            <span className={cn(\n              \"font-mono font-bold text-sm\",\n              isProduction ? \"text-green-500\" : \"text-yellow-500\"\n            )}>\n              {data.env}\n            </span>\n            {showDryRunWarning && (\n              <Badge \n                variant=\"outline\"\n                className=\"font-mono text-xs bg-orange-500/10 text-orange-500 border-orange-500/30\"\n              >\n                DRY_RUN\n              </Badge>\n            )}\n          </div>\n          <p className=\"text-xs text-muted-foreground font-mono\">\n            ID: {data.instanceId} {data.gitCommit && <span className=\"opacity-60\">Â· v{data.gitCommit}</span>}\n          </p>\n        </div>\n      </div>\n      \n      {data.isReplit && (\n        <p className=\"text-xs text-muted-foreground\">\n          Entorno de desarrollo - No se envÃ­an Ã³rdenes reales\n        </p>\n      )}\n    </div>\n  );\n}\n","path":null,"size_bytes":3284,"size_tokens":null},"script/migrate.ts":{"content":"#!/usr/bin/env npx tsx\n/**\n * Non-interactive database migration script for Docker/NAS deployment.\n * This script runs before the app starts to ensure schema is up-to-date.\n * \n * Usage: npx tsx script/migrate.ts\n * \n * Features:\n * - No interactive prompts (unlike drizzle-kit push)\n * - Safe ADD COLUMN IF NOT EXISTS\n * - Backfills lot_id for existing positions\n * - Adds unique constraint only if safe\n */\n\nimport { drizzle } from \"drizzle-orm/node-postgres\";\nimport { sql } from \"drizzle-orm\";\nimport pg from \"pg\";\n\nconst { Pool } = pg;\n\nasync function runMigration() {\n  console.log(\"[migrate] Starting non-interactive database migration...\");\n  \n  const databaseUrl = process.env.DATABASE_URL;\n  if (!databaseUrl) {\n    console.error(\"[migrate] ERROR: DATABASE_URL not set\");\n    process.exit(1);\n  }\n  \n  const pool = new Pool({ connectionString: databaseUrl });\n  const db = drizzle(pool);\n  \n  try {\n    // bot_config columns\n    const botConfigMigrations = [\n      'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_max_open_lots_per_pair INTEGER DEFAULT 1',\n      'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_pair_overrides JSONB',\n      'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS dry_run_mode BOOLEAN DEFAULT false',\n      'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_min_entry_usd DECIMAL(10,2) DEFAULT 100.00',\n      'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_allow_under_min BOOLEAN DEFAULT true',\n      'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_be_at_pct DECIMAL(5,2) DEFAULT 1.50',\n      'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_trail_start_pct DECIMAL(5,2) DEFAULT 2.00',\n      'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_trail_distance_pct DECIMAL(5,2) DEFAULT 1.50',\n      'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_trail_step_pct DECIMAL(5,2) DEFAULT 0.25',\n      'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_tp_fixed_enabled BOOLEAN DEFAULT false',\n      'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_tp_fixed_pct DECIMAL(5,2) DEFAULT 10.00',\n      'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_scale_out_enabled BOOLEAN DEFAULT false',\n      'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_scale_out_pct DECIMAL(5,2) DEFAULT 35.00',\n      'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_min_part_usd DECIMAL(10,2) DEFAULT 50.00',\n      'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_scale_out_threshold DECIMAL(5,2) DEFAULT 80.00',\n      'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_fee_cushion_pct DECIMAL(5,2) DEFAULT 0.45',\n      'ALTER TABLE bot_config ADD COLUMN IF NOT EXISTS sg_fee_cushion_auto BOOLEAN DEFAULT true',\n    ];\n    \n    // open_positions columns\n    const openPositionsMigrations = [\n      'ALTER TABLE open_positions ADD COLUMN IF NOT EXISTS lot_id TEXT',\n      'ALTER TABLE open_positions ADD COLUMN IF NOT EXISTS sg_break_even_activated BOOLEAN DEFAULT false',\n      'ALTER TABLE open_positions ADD COLUMN IF NOT EXISTS sg_trailing_activated BOOLEAN DEFAULT false',\n      'ALTER TABLE open_positions ADD COLUMN IF NOT EXISTS sg_current_stop_price DECIMAL(18,8)',\n      'ALTER TABLE open_positions ADD COLUMN IF NOT EXISTS sg_scale_out_done BOOLEAN DEFAULT false',\n      'ALTER TABLE open_positions ADD COLUMN IF NOT EXISTS config_snapshot_json JSONB',\n    ];\n    \n    console.log(\"[migrate] Applying bot_config migrations...\");\n    for (const migration of botConfigMigrations) {\n      try {\n        await db.execute(sql.raw(migration));\n      } catch (e) {\n        // Ignore errors (column may already exist)\n      }\n    }\n    \n    console.log(\"[migrate] Applying open_positions migrations...\");\n    for (const migration of openPositionsMigrations) {\n      try {\n        await db.execute(sql.raw(migration));\n      } catch (e) {\n        // Ignore errors\n      }\n    }\n    \n    // Backfill lot_id for existing positions\n    console.log(\"[migrate] Backfilling lot_id for existing positions...\");\n    try {\n      await db.execute(sql`\n        UPDATE open_positions \n        SET lot_id = 'LEGACY-' || id::text || '-' || SUBSTRING(MD5(pair || opened_at::text) FROM 1 FOR 6)\n        WHERE lot_id IS NULL\n      `);\n    } catch (e) {\n      console.log(\"[migrate] lot_id backfill note:\", e);\n    }\n    \n    // Add unique constraint if safe\n    console.log(\"[migrate] Checking lot_id uniqueness...\");\n    try {\n      const duplicates = await db.execute(sql`\n        SELECT lot_id, COUNT(*) FROM open_positions \n        WHERE lot_id IS NOT NULL \n        GROUP BY lot_id \n        HAVING COUNT(*) > 1\n      `);\n      \n      if (duplicates.rows.length === 0) {\n        // Check if constraint already exists\n        const constraintExists = await db.execute(sql`\n          SELECT constraint_name FROM information_schema.table_constraints \n          WHERE table_name = 'open_positions' AND constraint_name = 'open_positions_lot_id_unique'\n        `);\n        \n        if (constraintExists.rows.length === 0) {\n          console.log(\"[migrate] Adding unique constraint on lot_id...\");\n          await db.execute(sql`\n            ALTER TABLE open_positions ADD CONSTRAINT open_positions_lot_id_unique UNIQUE (lot_id)\n          `);\n        } else {\n          console.log(\"[migrate] lot_id unique constraint already exists\");\n        }\n      } else {\n        console.log(\"[migrate] WARNING: Duplicate lot_ids found, skipping unique constraint\");\n      }\n    } catch (e) {\n      console.log(\"[migrate] Constraint note:\", e);\n    }\n    \n    console.log(\"[migrate] Migration completed successfully!\");\n    await pool.end();\n    process.exit(0);\n  } catch (error) {\n    console.error(\"[migrate] Migration failed:\", error);\n    await pool.end();\n    process.exit(1);\n  }\n}\n\nrunMigration();\n","path":null,"size_bytes":5719,"size_tokens":null},"server/tests/smartguard-sizing-test.ts":{"content":"/**\n * SMART_GUARD Sizing Test Script\n * \n * Tests the following cases:\n * - Case A: balance=199, sgMinEntryUsd=100, allowUnderMin=true â†’ compra mÃ­nima = 100\n * - Case B: balance=70, allowUnderMin=true â†’ compra = ~70 (>=20)\n * - Case C: balance=70, allowUnderMin=false â†’ bloqueo MIN_ORDER_USD\n * - Case D: maxTotalExposure alcanzada â†’ bloqueo EXPOSURE_ZERO\n * \n * Run with: npx tsx server/tests/smartguard-sizing-test.ts\n */\n\nconst SG_ABSOLUTE_MIN_USD = 20;\n\ninterface MinimumValidationParams {\n  positionMode: string;\n  orderUsdFinal: number;\n  orderUsdProposed: number;\n  usdDisponible: number;\n  exposureAvailable: number;\n  pair: string;\n  sgMinEntryUsd?: number;\n  sgAllowUnderMin?: boolean;\n  dryRun?: boolean;\n  env?: string;\n}\n\ninterface MinimumValidationResult {\n  valid: boolean;\n  skipReason?: \"MIN_ORDER_ABSOLUTE\" | \"MIN_ORDER_USD\";\n  message?: string;\n}\n\nfunction validateMinimumsOrSkip(params: MinimumValidationParams): MinimumValidationResult {\n  const {\n    positionMode,\n    orderUsdFinal,\n    sgMinEntryUsd = 100,\n    sgAllowUnderMin = true,\n  } = params;\n\n  if (orderUsdFinal < SG_ABSOLUTE_MIN_USD) {\n    return {\n      valid: false,\n      skipReason: \"MIN_ORDER_ABSOLUTE\",\n      message: `Trade bloqueado: orderUsdFinal $${orderUsdFinal.toFixed(2)} < mÃ­nimo absoluto $${SG_ABSOLUTE_MIN_USD}`,\n    };\n  }\n\n  if (positionMode === \"SMART_GUARD\" && !sgAllowUnderMin && orderUsdFinal < sgMinEntryUsd) {\n    return {\n      valid: false,\n      skipReason: \"MIN_ORDER_USD\",\n      message: `Trade bloqueado: orderUsdFinal $${orderUsdFinal.toFixed(2)} < sgMinEntryUsd $${sgMinEntryUsd.toFixed(2)} (sgAllowUnderMin=OFF)`,\n    };\n  }\n\n  return { valid: true };\n}\n\ninterface TestCase {\n  name: string;\n  balance: number;\n  sgMinEntryUsd: number;\n  sgAllowUnderMin: boolean;\n  riskPerTradePct: number;\n  maxTradeUSD: number;\n  currentTotalExposure: number;\n  maxTotalExposurePct: number;\n  expectedOutcome: \"TRADE\" | \"MIN_ORDER_ABSOLUTE\" | \"MIN_ORDER_USD\" | \"EXPOSURE_ZERO\";\n  expectedOrderUsdFinal?: number;\n}\n\nfunction calculateSmartGuardSizing(\n  balance: number,\n  sgMinEntryUsd: number,\n  sgAllowUnderMin: boolean,\n  riskPerTradePct: number,\n  maxTradeUSD: number,\n  currentTotalExposure: number,\n  maxTotalExposurePct: number\n): { orderUsdFinal: number; skipReason?: string; message?: string } {\n  const usdDisponible = balance * 0.95;\n  \n  const riskBasedAmount = balance * (riskPerTradePct / 100);\n  const maxByRisk = Math.min(riskBasedAmount, maxTradeUSD);\n  const orderUsdProposed = Math.min(maxByRisk, usdDisponible);\n  \n  let tradeAmountUSD: number;\n  \n  if (usdDisponible >= sgMinEntryUsd) {\n    tradeAmountUSD = Math.max(orderUsdProposed, sgMinEntryUsd);\n    tradeAmountUSD = Math.min(tradeAmountUSD, usdDisponible, maxTradeUSD);\n  } else if (sgAllowUnderMin) {\n    tradeAmountUSD = usdDisponible;\n  } else {\n    tradeAmountUSD = usdDisponible;\n  }\n  \n  const maxTotalExposureUsd = balance * (maxTotalExposurePct / 100);\n  const maxTotalAvailable = Math.max(0, maxTotalExposureUsd - currentTotalExposure);\n  const maxByBalance = balance * 0.95;\n  const effectiveMaxAllowed = Math.min(maxTotalAvailable, maxByBalance);\n  \n  const minVolume = 0.00005;\n  const currentPrice = 90000;\n  const minRequiredUSD = minVolume * currentPrice;\n  \n  if (effectiveMaxAllowed < minRequiredUSD) {\n    return {\n      orderUsdFinal: 0,\n      skipReason: \"EXPOSURE_ZERO\",\n      message: `Sin exposiciÃ³n disponible. effectiveMaxAllowed=$${effectiveMaxAllowed.toFixed(2)} < minRequired=$${minRequiredUSD.toFixed(2)}`,\n    };\n  }\n  \n  const orderUsdFinal = tradeAmountUSD;\n  \n  const validation = validateMinimumsOrSkip({\n    positionMode: \"SMART_GUARD\",\n    orderUsdFinal,\n    orderUsdProposed,\n    usdDisponible,\n    exposureAvailable: effectiveMaxAllowed,\n    pair: \"BTC/USD\",\n    sgMinEntryUsd,\n    sgAllowUnderMin,\n  });\n  \n  if (!validation.valid) {\n    return {\n      orderUsdFinal,\n      skipReason: validation.skipReason,\n      message: validation.message,\n    };\n  }\n  \n  return { orderUsdFinal };\n}\n\nconst testCases: TestCase[] = [\n  {\n    name: \"Case A: balance=199, sgMinEntryUsd=100, allowUnderMin=true\",\n    balance: 199,\n    sgMinEntryUsd: 100,\n    sgAllowUnderMin: true,\n    riskPerTradePct: 15,\n    maxTradeUSD: 100,\n    currentTotalExposure: 0,\n    maxTotalExposurePct: 60,\n    expectedOutcome: \"TRADE\",\n    expectedOrderUsdFinal: 100,\n  },\n  {\n    name: \"Case B: balance=70, allowUnderMin=true â†’ compra ~66.5 (>=20)\",\n    balance: 70,\n    sgMinEntryUsd: 100,\n    sgAllowUnderMin: true,\n    riskPerTradePct: 15,\n    maxTradeUSD: 100,\n    currentTotalExposure: 0,\n    maxTotalExposurePct: 60,\n    expectedOutcome: \"TRADE\",\n    expectedOrderUsdFinal: 66.5,\n  },\n  {\n    name: \"Case C: balance=70, allowUnderMin=false â†’ bloqueo MIN_ORDER_USD\",\n    balance: 70,\n    sgMinEntryUsd: 100,\n    sgAllowUnderMin: false,\n    riskPerTradePct: 15,\n    maxTradeUSD: 100,\n    currentTotalExposure: 0,\n    maxTotalExposurePct: 60,\n    expectedOutcome: \"MIN_ORDER_USD\",\n  },\n  {\n    name: \"Case D: maxTotalExposure alcanzada â†’ bloqueo EXPOSURE_ZERO\",\n    balance: 199,\n    sgMinEntryUsd: 100,\n    sgAllowUnderMin: true,\n    riskPerTradePct: 15,\n    maxTradeUSD: 100,\n    currentTotalExposure: 120,\n    maxTotalExposurePct: 60,\n    expectedOutcome: \"EXPOSURE_ZERO\",\n  },\n  {\n    name: \"Case E: balance=15 (bajo absoluto) â†’ bloqueo MIN_ORDER_ABSOLUTE\",\n    balance: 15,\n    sgMinEntryUsd: 100,\n    sgAllowUnderMin: true,\n    riskPerTradePct: 15,\n    maxTradeUSD: 100,\n    currentTotalExposure: 0,\n    maxTotalExposurePct: 60,\n    expectedOutcome: \"MIN_ORDER_ABSOLUTE\",\n  },\n];\n\nconsole.log(\"=\".repeat(80));\nconsole.log(\"SMART_GUARD SIZING TEST SCRIPT\");\nconsole.log(\"=\".repeat(80));\nconsole.log(\"\");\n\nlet passed = 0;\nlet failed = 0;\n\nfor (const tc of testCases) {\n  const result = calculateSmartGuardSizing(\n    tc.balance,\n    tc.sgMinEntryUsd,\n    tc.sgAllowUnderMin,\n    tc.riskPerTradePct,\n    tc.maxTradeUSD,\n    tc.currentTotalExposure,\n    tc.maxTotalExposurePct\n  );\n  \n  const actualOutcome = result.skipReason || \"TRADE\";\n  const isOutcomeCorrect = actualOutcome === tc.expectedOutcome;\n  const isAmountCorrect = tc.expectedOrderUsdFinal === undefined || \n    Math.abs(result.orderUsdFinal - tc.expectedOrderUsdFinal) < 0.1;\n  \n  const testPassed = isOutcomeCorrect && isAmountCorrect;\n  \n  console.log(`TEST: ${tc.name}`);\n  console.log(`  Input: balance=$${tc.balance}, sgMinEntryUsd=$${tc.sgMinEntryUsd}, allowUnderMin=${tc.sgAllowUnderMin}`);\n  console.log(`  Input: riskPct=${tc.riskPerTradePct}%, maxTrade=$${tc.maxTradeUSD}, currentExposure=$${tc.currentTotalExposure}, maxExposurePct=${tc.maxTotalExposurePct}%`);\n  console.log(`  Expected: outcome=${tc.expectedOutcome}${tc.expectedOrderUsdFinal ? `, orderUsdFinal=$${tc.expectedOrderUsdFinal}` : \"\"}`);\n  console.log(`  Actual: outcome=${actualOutcome}, orderUsdFinal=$${result.orderUsdFinal.toFixed(2)}${result.message ? ` (${result.message})` : \"\"}`);\n  console.log(`  Result: ${testPassed ? \"âœ… PASSED\" : \"âŒ FAILED\"}`);\n  console.log(\"\");\n  \n  if (testPassed) passed++;\n  else failed++;\n}\n\nconsole.log(\"=\".repeat(80));\nconsole.log(`SUMMARY: ${passed} passed, ${failed} failed`);\nconsole.log(\"=\".repeat(80));\n\nprocess.exit(failed > 0 ? 1 : 0);\n","path":null,"size_bytes":7235,"size_tokens":null},"server/services/fifoMatcher.ts":{"content":"import { db } from \"../db\";\nimport { storage } from \"../storage\";\nimport { sql, eq, and } from \"drizzle-orm\";\nimport { \n  openPositions as openPositionsTable,\n  lotMatches as lotMatchesTable,\n  tradeFills as tradeFillsTable\n} from \"@shared/schema\";\nimport type { TradeFill, OpenPosition, LotMatch } from \"@shared/schema\";\n\nexport interface MatchResult {\n  sellFillTxid: string;\n  pair: string;\n  totalMatched: number;\n  remainingUnmatched: number;\n  lotsUpdated: number;\n  lotsClosed: number;\n  matchesCreated: LotMatch[];\n  orphanQty: number;\n  pnlNet: number;\n  fullyMatched: boolean;\n}\n\nexport class FifoMatcher {\n  async processSellFill(sellFill: TradeFill): Promise<MatchResult> {\n    const result: MatchResult = {\n      sellFillTxid: sellFill.txid,\n      pair: sellFill.pair,\n      totalMatched: 0,\n      remainingUnmatched: parseFloat(sellFill.amount),\n      lotsUpdated: 0,\n      lotsClosed: 0,\n      matchesCreated: [],\n      orphanQty: 0,\n      pnlNet: 0,\n      fullyMatched: false,\n    };\n\n    const sellQty = parseFloat(sellFill.amount);\n    const sellPrice = parseFloat(sellFill.price);\n    const sellFeeTotal = parseFloat(sellFill.fee);\n    let sellRemaining = sellQty;\n\n    // Use transaction with row-level locking - ALL operations inside tx\n    await db.transaction(async (tx) => {\n      // SELECT FOR UPDATE to lock lots for this pair\n      const openLots = await tx.select().from(openPositionsTable)\n        .where(sql`${openPositionsTable.pair} = ${sellFill.pair} \n          AND (${openPositionsTable.qtyRemaining} > 0 OR ${openPositionsTable.qtyRemaining} IS NULL)`)\n        .orderBy(openPositionsTable.openedAt)\n        .for(\"update\");\n      \n      if (openLots.length === 0) {\n        console.log(`[FifoMatcher] No open lots for ${sellFill.pair}, orphan qty=${sellRemaining.toFixed(8)}`);\n        result.orphanQty = sellRemaining;\n        result.remainingUnmatched = sellRemaining;\n        return;\n      }\n\n      for (const lot of openLots) {\n        if (sellRemaining <= 0.00000001) break;\n\n        const lotQtyRemaining = parseFloat(lot.qtyRemaining || lot.amount);\n        if (lotQtyRemaining <= 0.00000001) continue;\n        \n        const matchQty = Math.min(sellRemaining, lotQtyRemaining);\n        \n        // Check for existing match WITHIN TRANSACTION (idempotency)\n        const existingMatches = await tx.select().from(lotMatchesTable)\n          .where(and(\n            eq(lotMatchesTable.sellFillTxid, sellFill.txid),\n            eq(lotMatchesTable.lotId, lot.lotId)\n          ));\n        \n        if (existingMatches.length > 0) {\n          const existingMatch = existingMatches[0];\n          console.log(`[FifoMatcher] Match already exists for ${sellFill.txid} + ${lot.lotId}, adjusting sellRemaining`);\n          sellRemaining -= parseFloat(existingMatch.matchedQty);\n          result.totalMatched += parseFloat(existingMatch.matchedQty);\n          result.pnlNet += parseFloat(existingMatch.pnlNet);\n          continue;\n        }\n\n        const buyPrice = parseFloat(lot.entryPrice);\n        const buyFeeTotal = this.getBuyFee(lot);\n        const buyFeeAllocated = (matchQty / parseFloat(lot.amount)) * buyFeeTotal;\n        const sellFeeAllocated = (matchQty / sellQty) * sellFeeTotal;\n\n        const revenue = matchQty * sellPrice;\n        const cost = matchQty * buyPrice;\n        const pnlGross = revenue - cost;\n        const pnlNet = pnlGross - buyFeeAllocated - sellFeeAllocated;\n\n        const newQtyRemaining = lotQtyRemaining - matchQty;\n        const newQtyFilled = parseFloat(lot.qtyFilled || \"0\") + matchQty;\n\n        try {\n          // Create lot match WITHIN TRANSACTION\n          const [match] = await tx.insert(lotMatchesTable).values({\n            sellFillTxid: sellFill.txid,\n            lotId: lot.lotId,\n            matchedQty: matchQty.toFixed(8),\n            buyPrice: buyPrice.toFixed(8),\n            sellPrice: sellPrice.toFixed(8),\n            buyFeeAllocated: buyFeeAllocated.toFixed(8),\n            sellFeeAllocated: sellFeeAllocated.toFixed(8),\n            pnlNet: pnlNet.toFixed(8),\n          }).returning();\n          \n          result.matchesCreated.push(match);\n          result.pnlNet += pnlNet;\n          sellRemaining -= matchQty;\n          result.totalMatched += matchQty;\n        } catch (error: any) {\n          if (error.code === '23505') {\n            // Duplicate - race condition, reconcile within tx\n            const existing = await tx.select().from(lotMatchesTable)\n              .where(and(\n                eq(lotMatchesTable.sellFillTxid, sellFill.txid),\n                eq(lotMatchesTable.lotId, lot.lotId)\n              ));\n            if (existing.length > 0) {\n              sellRemaining -= parseFloat(existing[0].matchedQty);\n              result.totalMatched += parseFloat(existing[0].matchedQty);\n              result.pnlNet += parseFloat(existing[0].pnlNet);\n            }\n            continue;\n          }\n          console.error(`[FifoMatcher] Error creating match:`, error.message);\n          throw error;\n        }\n\n        // Update lot quantities within transaction\n        await tx.update(openPositionsTable)\n          .set({ \n            qtyRemaining: newQtyRemaining.toFixed(8), \n            qtyFilled: newQtyFilled.toFixed(8),\n            updatedAt: new Date() \n          })\n          .where(eq(openPositionsTable.lotId, lot.lotId));\n        result.lotsUpdated++;\n\n        if (newQtyRemaining <= 0.00000001) {\n          await tx.delete(openPositionsTable)\n            .where(eq(openPositionsTable.lotId, lot.lotId));\n          result.lotsClosed++;\n          console.log(`[FifoMatcher] Lot ${lot.lotId} fully closed`);\n        }\n      }\n\n      // Only mark fill as matched if fully processed (sellRemaining â‰ˆ 0)\n      if (sellRemaining <= 0.00000001) {\n        await tx.update(tradeFillsTable)\n          .set({ matched: true })\n          .where(eq(tradeFillsTable.txid, sellFill.txid));\n        result.fullyMatched = true;\n      }\n    });\n\n    result.remainingUnmatched = sellRemaining;\n    if (sellRemaining > 0.00000001) {\n      result.orphanQty = sellRemaining;\n      console.log(`[FifoMatcher] ${sellRemaining.toFixed(8)} qty unmatched (no more open lots) - fill NOT marked as matched for retry`);\n    }\n    \n    console.log(`[FifoMatcher] Processed ${sellFill.txid}: matched=${result.totalMatched.toFixed(8)}, lots_closed=${result.lotsClosed}, pnl=${result.pnlNet.toFixed(2)}, fullyMatched=${result.fullyMatched}`);\n    \n    return result;\n  }\n\n  private getBuyFee(lot: OpenPosition): number {\n    // Try to get actual fee from config snapshot\n    if (lot.configSnapshotJson) {\n      const snapshot = lot.configSnapshotJson as any;\n      if (snapshot.entryFee) {\n        return parseFloat(snapshot.entryFee);\n      }\n    }\n    // Fallback: estimate from cost at Kraken rate (0.4% taker)\n    const amount = parseFloat(lot.amount);\n    const price = parseFloat(lot.entryPrice);\n    const cost = amount * price;\n    return cost * 0.004;\n  }\n\n  async processAllUnmatchedSells(): Promise<{ processed: number; errors: string[] }> {\n    const pairs = [\"BTC/USD\", \"ETH/USD\", \"SOL/USD\", \"XRP/USD\", \"TON/USD\"];\n    let processed = 0;\n    const errors: string[] = [];\n\n    for (const pair of pairs) {\n      const unmatchedSells = await storage.getUnmatchedSellFills(pair);\n      for (const sellFill of unmatchedSells) {\n        try {\n          await this.processSellFill(sellFill);\n          processed++;\n        } catch (error: any) {\n          errors.push(`${sellFill.txid}: ${error.message}`);\n        }\n      }\n    }\n\n    return { processed, errors };\n  }\n\n  async initializeLots(): Promise<number> {\n    return await storage.initializeQtyRemainingForAll();\n  }\n}\n\nexport const fifoMatcher = new FifoMatcher();\n","path":null,"size_bytes":7715,"size_tokens":null},"server/utils/confidence.ts":{"content":"/**\n * Confidence normalization utilities\n * \n * Convention:\n * - Internal (signals/positions): 0..1 scale\n * - Display (UI/Telegram/logs) and ML features: 0..100 scale\n */\n\n/**\n * Convert any confidence value to percentage (0..100)\n * Accepts both 0..1 and 0..100 inputs\n */\nexport function toConfidencePct(value: unknown, fallback = 50): number {\n  if (value === null || value === undefined) return fallback;\n  const n = typeof value === \"number\" ? value : parseFloat(String(value));\n  if (!Number.isFinite(n)) return fallback;\n  const pct = n <= 1 ? n * 100 : n;\n  return Math.max(0, Math.min(100, pct));\n}\n\n/**\n * Convert any confidence value to unit (0..1)\n * Accepts both 0..1 and 0..100 inputs\n */\nexport function toConfidenceUnit(value: unknown, fallback = 0): number {\n  if (value === null || value === undefined) return fallback;\n  const n = typeof value === \"number\" ? value : parseFloat(String(value));\n  if (!Number.isFinite(n)) return fallback;\n  const unit = n > 1 ? n / 100 : n;\n  return Math.max(0, Math.min(1, unit));\n}\n","path":null,"size_bytes":1038,"size_tokens":null}},"version":2}